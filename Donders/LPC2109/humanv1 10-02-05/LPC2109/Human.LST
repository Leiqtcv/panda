ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 1   


ARM COMPILER V2.11, COMPILATION OF MODULE Human
OBJECT MODULE PLACED IN Human.OBJ
COMPILER INVOKED BY: C:\Keil\ARM\BIN\CA.exe Human.c THUMB BROWSE TABS(4) 

stmt  level    source

    1          /*************************************************************************
    2                                      Human.c
    3          
    4          Project                     Controller                  DJH MBFYS CNS UMCN
    5          --------------------------------------------------------------------------
    6          Versie  0.00    30-mar-2006 Start uitzoeken mogelijkheid toepassen micro 
    7                                      controller voor lokalisatie experimenten en
    8                                      de ontwikkeling van de interrupt routines
    9                  1.00    14-jan-2008 Toevoegen van commentaar
   10                  1.02    04-feb-2008 Resetten van boog en sky leds 
   11                  1.03    03-mar-2009 Leds+Blink
   12                  1.30    19-okt-2009 Toevoeg stim Las
   13          **************************************************************************/
   14          #include <lpc21xx.h>
   15          #include <stdio.h>
   16          #include <inttypes.h>
   17          
   18          #include "Human.h"
   19          #include "Config.h"
   20          #include "Clock.h"
   21          #include "Serial.h"
   22          #include "i2c.h"
   23          #include "ADC.h"                                               
   24          
   25          char version[] = "LPC2119\t - Human \t1.30 19-Oct-2009\n";
   26          
   27          char inBuf[80];             // gebruikt voor RS232 communicatie
   28          char outBuf[80];
   29          int  inpPnt, outPnt;        // de bijbehorende pointers
   30          char wrd[10];               // geheugen voor 1 woord uit inBuf
   31          int32_t  nBuffer[12];       // stimulus plus parameters uit inBuf
   32          int  nStatus;               // toestand state-machine
   33          int  nStimLeds = 0;         // index stimLeds in record stim;
   34          unsigned int startTime;     // begin van de ITI, daarna begin van een trial                         
   35          unsigned int curTime;       // de huidige tijd in msec
   36          int nStim   = 0;
   37          int newStim = 0;
   38          recStim stim[20];           // er kunnen maximaal 20 simuli in 1 trial
   39                                      // dit kan uitgebreid worden
   40          
   41          int tmp[7];
   42          recLedIC Leds[3][2][4];     // [1-voor/2-achter] [Interne selectie PCA 9532 LS0..LS3]
   43                                      // {3-parallel voor]
   44          recLedIC Sky[13];           // 5,9,14,20,27,35,44,54,65 graden
   45          
   46          int boards[8]   = {0xF7,0xFB,0xFD,0xFE,0x7F,0xBF,0xDF,0xEF};  // pre selectie speaker
   47          int speakers[8] = {0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01};
   48          int gain1[8]    = {0x7F,0xDF,0xF7,0xFD,0x7F,0xDF,0xF7,0xFD};  // snd1
   49          int gain2[8]    = {0xBF,0xEF,0xFB,0xFE,0xBF,0xEF,0xFB,0xFE};  // snd2
   50          // signaal: bit=0->signaal2, bit=1->signaal1
   51          int statusBoards[8][3];  // [board][signal, gain1..4, gain5..8]
   52                                   // 0x4E=board, 0x40=signal, 0x44 gain1..4, 0x42 gain1..8  
   53          //q int lastBoard = 0;
   54          int  tBuf[6];       /*  tijd doorgebracht in een toestand
   55                                  0 = inlezen van een trial
   56                                  1 = wachten op start commando PC
   57                                  2 = start ITI
   58                                  3 = duur van een trial
   59                                  4 = duur wegschrijven trial gegevens
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 2   

   60                                  5 = N.U.
   61                              */        
   62          
   63          int  snd12Flag;     // trigger mode RP2's
   64                              // 1=RP2_1, 2=RP2_2, 3=beide RP2's
   65          int  tmpSnd1[4];    // [0]=flag, [1]time mode [2]=time [3]=index
   66          int  tmpSnd2[4];
   67          
   68          void Delay (unsigned long a)
   69          {
   70   1          while (--a != 0);
   71   1      }
   72          /**************************************************************************************
   73              Voor het aansturen van de boog- en skyleds worden PCA 9532 IC's gebruikt.
   74              De PCA 9532 is een 16-bit I2C led dimmer
   75          **************************************************************************************/
   76          void LedOnOff(int index, int level, int OnOff, int parallel)
   77          {
   78   1          int n, ic, led, ls, tmp;
   79   1          unsigned char buffer[4];
   80   1          int PWM1 = 0x14;    // (autoincrement (16) + register
   81   1          int LS0  = 0x06;    
   82   1          int LS1  = 0x07;    
   83   1          int LS2  = 0x08;    
   84   1          int LS3  = 0x09;
   85   1                          //   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 
             -29 30 31}
   86   1          int ledsIndex[] = { 13,12,11,10, 9, 8, 7, 6, 5, 4, 3, 2, 1,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,
             -17,15,14};
   87   1      
   88   1          // Leds aan de voorzijde zijn genummerd van 1..29, de linker led = 30 en de rechter = 31
   89   1          // De leds aan de achterzijde van 101..129
   90   1          if (index > 100) led = index - 100; else led = index; // led in de range van 1..29 
   91   1          led = ledsIndex[led-1];                               // hernummering ivm elektronica
   92   1          if (led <= 16) ic = 0; else ic = 1;                   // IC 1..2
   93   1          led = led - ic*16;                                    // led 1..16
   94   1          ls = (led-1)/4;                                       // led selector 1..4
   95   1      
   96   1          if (index < 100) n = 0; else n = 1;
   97   1          if (parallel == true) n = 2;
   98   1          buffer[0] = Leds[n][ic][ls].address;                  // adres led-IC
   99   1          I2C_SendByte(0x72, 1, buffer);                        // laad pre-selectie met adres
  100   1      
  101   1          // set level
  102   1          buffer[0] = PWM1;               // subaddress
  103   1          buffer[1] = 0;                  // PSC1
  104   1          buffer[2] = level & 0xFF;
  105   1          I2C_SendByte(0xC0, 3, buffer);  // preselectie bepaalt welk IC adres C0 heeft
  106   1      
  107   1          // update data
  108   1      //  if (led > 8) led = led - 8;
  109   1          led = (led-1) % 4;
  110   1          tmp = (0x03 << (2*(led)));      // 11 = blink at PWM1 rate
  111   1          if (OnOff == ON)
  112   1              Leds[n][ic][ls].data |= tmp;
  113   1          else 
  114   1              Leds[n][ic][ls].data &= ~tmp;
  115   1      
  116   1          switch(ls)
  117   1          {
  118   2          case 0: buffer[0] = LS0; break;
  119   2          case 1: buffer[0] = LS1; break;
  120   2          case 2: buffer[0] = LS2; break;
  121   2          case 3: buffer[0] = LS3; break;
  122   2          }
  123   1      //  if (led < 5)
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 3   

  124   1          {
  125   2              buffer[1] = Leds[n][ic][ls].data & 0xFF;
  126   2          }
  127   1      //  else
  128   1          {
  129   2      //      buffer[1] = ((Leds[n][ic].data >> 8) & 0xFF);
  130   2          }
  131   1          I2C_SendByte(0xC0, 2, buffer);
  132   1      
  133   1          buffer[0] = 0xFF;
  134   1          I2C_SendByte(0x72,1,buffer);
  135   1              
  136   1      }
  137          
  138          void ClearArc(void)
  139          {
  140   1          int index;
  141   1          for (index = 1; index <= 31; index++)
  142   1              LedOnOff(index, 0, OFF, false);
  143   1          for (index = 101; index <=129; index++)
  144   1              LedOnOff(index, 0, OFF, false);
  145   1          for (index = 1; index <= 31; index++)
  146   1              LedOnOff(index, 0, OFF, true);
  147   1      }
  148          
  149          void ClearSky(void)
  150          {
  151   1          int spaak, led;
  152   1          SkyOnOff(0, 1, 0, OFF);
  153   1          SkyOnOff(0, 2, 0, OFF);
  154   1          for (spaak = 1; spaak <= 12; spaak++)
  155   1          {
  156   2              for (led = 0; led <= 7; led++)
  157   2              {
  158   3                  SkyOnOff(spaak, led, 0, OFF);
  159   3              }
  160   2          }
  161   1      }
  162          
  163          void SkyOnOff(int spaak, int led, int level, int OnOff)
  164          {
  165   1          int tmp;
  166   1          unsigned char buffer[4];
  167   1          int PWM1 = 0x14;    // (autoincrement (16) + register
  168   1          int LS0  = 0x06;    
  169   1          int LS1  = 0x07;    
  170   1      
  171   1          if (spaak == 0)
  172   1          {
  173   2              buffer[0] = 0xEF;
  174   2          }
  175   1          else
  176   1          {
  177   2              if (spaak < 9)
  178   2                  buffer[0] = ~(1 << (spaak-1));
  179   2              else
  180   2                  buffer[0] = ~(1 << (spaak-9));
  181   2          }
  182   1          I2C_SendByte(Sky[spaak].address, 1, buffer);  // laad pre-selectie met spaak-IC
  183   1          // set level
  184   1          buffer[0] = PWM1;   // subaddress
  185   1          buffer[1] = 0;      // PSC1
  186   1          buffer[2] = level & 0xFF;
  187   1          I2C_SendByte(0xC0, 3, buffer);
  188   1          // update data
  189   1          if (spaak == 0)
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 4   

  190   1          {
  191   2              buffer[0] = LS0;
  192   2              tmp = (0x03 << (2*(led-1)));
  193   2              if (OnOff == ON)
  194   2                  Sky[spaak].data |= tmp;
  195   2              else 
  196   2                  Sky[spaak].data &= ~tmp;
  197   2              buffer[1] = Sky[spaak].data;
  198   2          }
  199   1          else
  200   1          {
  201   2              tmp = (0x03 << (2*(led-1)));
  202   2              if (OnOff == ON)
  203   2                  Sky[spaak].data |= tmp;
  204   2              else 
  205   2                  Sky[spaak].data &= ~tmp;
  206   2              if (led < 5)
  207   2              {
  208   3                  buffer[0] = LS0;
  209   3                  buffer[1] = (Sky[spaak].data & 0xFF);
  210   3              }
  211   2              else
  212   2              {
  213   3                  buffer[0] = LS1;
  214   3                  buffer[1] = ((Sky[spaak].data >> 8) & 0xFF);
  215   3              }
  216   2          }
  217   1          I2C_SendByte(0xC0, 2, buffer);
  218   1          buffer[0] = 0xFF;
  219   1          I2C_SendByte(Sky[spaak].address, 1, buffer);
  220   1      }
  221          
  222          int main (void)
  223          {
  224   1          int num, EOL, abort;
  225   1          int inChar;
  226   1          int i, n, done;
  227   1          unsigned int Seconds;
  228   1          int LS0 = 0x06;
  229   1          int LS1 = 0x07;
  230   1          
  231   1          num      = 0;
  232   1          EOL      = 0;
  233   1          abort    = 0;
  234   1          if (InitAll()  != 0)
  235   1              return -1;
  236   1      
  237   1          nStatus = statInit;
  238   1          Clock_Reset();
  239   1          curTime = 0;
  240   1      
  241   1          done = 0;
  242   1          for (;;)
  243   1          {
  244   2              if (UART0_RxNumber() > 0)
  245   2              {
  246   3                  inChar = UART0_Get();
  247   3                  if (inChar == ESCAPE) abort = 1;
  248   3                  if (inChar == ENTER)  
  249   3                  {
  250   4                      EOL   = 1;          // new command
  251   4                      inBuf[num] = 0;
  252   4                      splitInput();
  253   4                  }
  254   3                  if (EOL == 0) inBuf[num++] = (char) inChar;
  255   3              }
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 5   

  256   2              curTime = Clock_GetTicks();
  257   2      
  258   2              if (abort == 1)
  259   2              {
  260   3      //          nStatus = statAbort;
  261   3                  InitAll();
  262   3                  nStatus = statInit;
  263   3                  Clock_Reset();
  264   3                  curTime = 0;
  265   3                  EOL = 0;
  266   3                  num = 0;
  267   3                  abort = 0;
  268   3              }
  269   2              if ((EOL == 1) && (nBuffer[1] == cmdTime)) GetTime();
  270   2              if (nStatus == statInit)
  271   2              {
  272   3                  if (EOL == 1)
  273   3                  {
  274   4                      if (nBuffer[1] == cmdSpeakersOff) SpeakersOff();
  275   4                      if (nBuffer[1] == cmdInfo)   ReturnInfo();      
  276   4                      if (nBuffer[1] == cmdGetPIO) GetPIO();
  277   4      
  278   4                      if (nBuffer[1] == cmdNewTrial) 
  279   4                      {
  280   5                          startTime = nBuffer[2];     // ITI
  281   5                          Clock_Reset();
  282   5                          curTime = 0;
  283   5                          nStatus = statTrial;
  284   5                          nStim = 0;
  285   5                          newStim = nBuffer[3];       // komt van PC
  286   5                          i = startTime;
  287   5                          n = sprintf(outBuf,"%d\n",i); 
  288   5                          i = UART0_Str(outBuf, n);
  289   5                          tmpSnd1[0] = 0;
  290   5                          tmpSnd2[0] = 0;
  291   5                      }
  292   4                      EOL = 0;
  293   4                      num = 0;
  294   4                  }
  295   3              }
  296   2      
  297   2              if (nStatus == statTrial)
  298   2              {
  299   3                  if (EOL == 1)
  300   3                  {
  301   4                      switch (nBuffer[1])
  302   4                      {
  303   5                      case stimLed:   stim[nStim].status    = statInit;
  304   5                                  stim[nStim].kind      = stimLed;
  305   5                                  stim[nStim].posX      = nBuffer[2];
  306   5                                  stim[nStim].posY      = nBuffer[3];     
  307   5                                  stim[nStim].level     = nBuffer[4];     
  308   5                                  stim[nStim].startRef  = nBuffer[5];
  309   5                                  stim[nStim].startTime = nBuffer[6]; 
  310   5                                  stim[nStim].stopRef   = nBuffer[7]; 
  311   5                                  stim[nStim].stopTime  = nBuffer[8]; 
  312   5                                  break;
  313   5                      case stimLeds:  stim[nStim].status    = statInit;
  314   5                                  stim[nStim].kind      = stimLeds;
  315   5                                  stim[nStim].posX      = nBuffer[2];
  316   5                                  stim[nStim].posY      = nBuffer[3];     
  317   5                                  stim[nStim].level     = nBuffer[4];     
  318   5                                  stim[nStim].startRef  = nBuffer[5];
  319   5                                  stim[nStim].startTime = nBuffer[6]; 
  320   5                                  stim[nStim].stopRef   = nBuffer[7]; 
  321   5                                  stim[nStim].stopTime  = nBuffer[8]; 
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 6   

  322   5                                  stim[nStim].index     = nBuffer[9]; 
  323   5                                  nStimLeds = nStim;
  324   5                                  break;
  325   5                      case stimBlink: stim[nStim].status    = statInit;
  326   5                                  stim[nStim].kind      = stimBlink;
  327   5                                  stim[nStim].posX      = nBuffer[2];
  328   5                                  stim[nStim].posY      = nBuffer[3];     
  329   5                                  stim[nStim].level     = nBuffer[4];     
  330   5                                  stim[nStim].startRef  = nBuffer[5];
  331   5                                  stim[nStim].startTime = nBuffer[6]; 
  332   5                                  stim[nStim].stopRef   = nBuffer[7]; 
  333   5                                  stim[nStim].stopTime  = nBuffer[8]; 
  334   5                                  stim[nStim].index     = nBuffer[9]; 
  335   5                                  break;
  336   5                      case stimAcq:   stim[nStim].status    = statInit;
  337   5                                  stim[nStim].kind      = stimAcq;
  338   5                                  stim[nStim].startRef  = nBuffer[2];
  339   5                                  stim[nStim].startTime = nBuffer[3]; 
  340   5                                  break;
  341   5                      case stimSnd1:  stim[nStim].status    = statInit;
  342   5                                  stim[nStim].kind      = stimSnd1;
  343   5                                  stim[nStim].posX      = nBuffer[2];
  344   5                                  stim[nStim].posY      = nBuffer[3];     
  345   5                                  stim[nStim].index     = nBuffer[4]; 
  346   5                                  stim[nStim].level     = nBuffer[5];     
  347   5                                  stim[nStim].startRef  = nBuffer[6];
  348   5                                  stim[nStim].startTime = nBuffer[7];
  349   5                                  stim[nStim].width     = nBuffer[8];
  350   5                                  tmpSnd1[0] = 1;
  351   5                                  tmpSnd1[1] = nBuffer[6];
  352   5                                  tmpSnd1[2] = nBuffer[7]; 
  353   5                                  tmpSnd1[3] = nStim;
  354   5                                  break;
  355   5                      case stimSnd2:  stim[nStim].status    = statInit;
  356   5                                  stim[nStim].kind      = stimSnd2;
  357   5                                  stim[nStim].posX      = nBuffer[2];
  358   5                                  stim[nStim].posY      = nBuffer[3];     
  359   5                                  stim[nStim].index     = nBuffer[4]; 
  360   5                                  stim[nStim].level     = nBuffer[5];     
  361   5                                  stim[nStim].startRef  = nBuffer[6];
  362   5                                  stim[nStim].startTime = nBuffer[7]; 
  363   5                                  stim[nStim].width     = nBuffer[8];
  364   5                                  tmpSnd2[0] = 1;
  365   5                                  tmpSnd2[1] = nBuffer[6];
  366   5                                  tmpSnd2[2] = nBuffer[7];
  367   5                                  tmpSnd2[3] = nStim;
  368   5                                  break;
  369   5                      case stimTrg0:stim[nStim].status    = statInit;
  370   5                                  stim[nStim].kind      = stimTrg0;
  371   5                                  stim[nStim].edge      = nBuffer[2];
  372   5                                  stim[nStim].bitNo     = nBuffer[3];
  373   5                                  stim[nStim].startRef  = nBuffer[4];
  374   5                                  stim[nStim].startTime = nBuffer[5]; 
  375   5                                  stim[nStim].event     = nBuffer[6];
  376   5                                  break;
  377   5                      case stimSky:   stim[nStim].status    = statInit;
  378   5                                  stim[nStim].kind      = stimSky;
  379   5                                  stim[nStim].posX      = nBuffer[2];
  380   5                                  stim[nStim].posY      = nBuffer[3];     
  381   5                                  stim[nStim].level     = nBuffer[4];     
  382   5                                  stim[nStim].startRef  = nBuffer[5];
  383   5                                  stim[nStim].startTime = nBuffer[6]; 
  384   5                                  stim[nStim].stopRef   = nBuffer[7]; 
  385   5                                  stim[nStim].stopTime  = nBuffer[8]; 
  386   5                                  break;
  387   5                      case stimInp1:  stim[nStim].status = statDone;    // start en duur wordt bepaald door SND1
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 7   

  388   5                                  stim[nStim].kind      = stimInp1;
  389   5                                  break;
  390   5                      case stimInp2:  stim[nStim].status = statDone;
  391   5                                  stim[nStim].kind      = stimInp2;
  392   5                                  break;
  393   5                      case stimLas:   stim[nStim].status = statInit;
  394   5                                  stim[nStim].kind       = stimLas;
  395   5                                  stim[nStim].bitNo      = nBuffer[2];
  396   5                                  stim[nStim].startRef   = nBuffer[3];
  397   5                                  stim[nStim].startTime  = nBuffer[4];    
  398   5                                  stim[nStim].stopRef    = nBuffer[5];    
  399   5                                  stim[nStim].stopTime   = nBuffer[6];    
  400   5                                  break;
  401   5                      }
  402   4                      if (nStim < (newStim-1))
  403   4                          nStim++;
  404   4                      else
  405   4                      {
  406   5                          nStatus = statWait;
  407   5                          tBuf[0] = curTime;
  408   5                          Clock_Reset();
  409   5                          snd12Flag = 0;
  410   5                          // sndflag=3 betekend dat beide rp2's gelijk moeten worden getriggerd.
  411   5                          for (i = 0; i < 3; i++) 
  412   5                          {
  413   6                              if (tmpSnd1[i] == tmpSnd2[i]) snd12Flag++;
  414   6                          }
  415   5                      }
  416   4                      i = curTime;
  417   4                      n = sprintf(outBuf,"%d\n",i);
  418   4                      i = UART0_Str(outBuf, n);
  419   4                      EOL = 0;
  420   4                      num = 0;
  421   4                  }
  422   3              }
  423   2      
  424   2              if (nStatus == statWait)
  425   2              {
  426   3                  if (EOL == 1)
  427   3                  {
  428   4                      if (nBuffer[1] == cmdStart)
  429   4                      {
  430   5                          tBuf[1] = curTime;
  431   5                          Clock_Reset();
  432   5                          curTime = 0;
  433   5                          nStatus = statITI;
  434   5                          EOL = 0;
  435   5                          num = 0;
  436   5                      }
  437   4                  }
  438   3              }
  439   2      
  440   2              if (nStatus == statITI)
  441   2              {
  442   3                  if (curTime >= startTime)
  443   3                  {
  444   4                      nStatus   = statRun;
  445   4                      startTime = curTime;
  446   4                      tBuf[2] = curTime;
  447   4                      Clock_Reset();
  448   4                      curTime = 0;
  449   4                  }
  450   3              }
  451   2      
  452   2              if (nStatus == statRun)
  453   2              {
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 8   

  454   3                  done = 0;
  455   3                  for (i = 0; i <= nStim; i++)
  456   3                  {
  457   4                      switch(stim[i].kind)
  458   4                      {
  459   5                      case stimLed:  done += ExecLed(i);  break;
  460   5                      case stimLeds: done += ExecLeds(i); break;
  461   5                      case stimBlink:done += ExecBlink(i);break;
  462   5                      case stimSnd1: done += ExecSnd(i);  break;
  463   5                      case stimSnd2: done += ExecSnd(i);  break;
  464   5                      case stimTrg0: done += ExecTrg0(i); break;
  465   5                      case stimAcq:  done += ExecAcq(i);  break;
  466   5                      case stimSky:  done += ExecSky(i);  break;
  467   5                      case stimLas:  done += ExecLas(i);  break;
  468   5                      }
  469   4                  }
  470   3                  curTime = Clock_GetTicks();
  471   3                  
  472   3                  if (done == 0)
  473   3                  {
  474   4                      tBuf[3] = curTime;
  475   4                      nStatus = statWaitPC;
  476   4      //              EOL = 0;
  477   4      //              num = 0;
  478   4                  }
  479   3              }
  480   2      
  481   2              if (nStatus == statWaitPC)
  482   2              {
  483   3                  if (EOL == 1)
  484   3                  {
  485   4                      if (nBuffer[1] == cmdDataMicro)
  486   4                      {
  487   5                          Clock_Reset();
  488   5                          curTime = 0;
  489   5                          ReturnDataMicro();
  490   5                          Clock_Reset();
  491   5                          curTime = 0;
  492   5                          nStatus = statInit;
  493   5                          EOL = 0;
  494   5                          num = 0;
  495   5                      }
  496   4                  }
  497   3              }
  498   2      
  499   2              curTime = Clock_GetTicks();
  500   2              Seconds = Clock_GetSeconds();
  501   2              if ((Seconds & 0x01) > 0) ClrBitsPar(0x01); else SetBitsPar(0x01);
  502   2              if (EOL == 1)
  503   2              {
  504   3                  if (nBuffer[1] == cmdReady)
  505   3                  {
  506   4                      if ((nStatus == statWaitPC) || (nStatus == statRun))
  507   4                          i = done;
  508   4                      else
  509   4                           i = -1;
  510   4                      n = sprintf(outBuf,"%d\n",i); 
  511   4                      i = UART0_Str(outBuf, n);
  512   4                  }
  513   3                  EOL = 0;
  514   3                  num = 0;
  515   3              }
  516   2          }
  517   1      
  518   1          return 0;
  519   1      }
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 9   

  520          
  521          int InitAll()
  522          {
  523   1          unsigned char buffer[4];
  524   1          int n, i;
  525   1          
  526   1          LPCinit();
  527   1          IODIR0  = 0x00000FF0;   // P0.4-P0.11 as output bit 0..7
  528   1                                  // PO.18-P0.25 as input bit 0..7
  529   1          IOSET0 |= 0x00000FF0;   // LED off 
  530   1      
  531   1          Clock_Init();           // interrupt 0
  532   1          I2C_Init();             // interrupt 1
  533   1          UART0_Init();           // interrupt 2
  534   1          ADC_Init();             // interrupt 3, channel 0
  535   1      
  536   1      //  nieuw: voor-onder, voor-boven, achter-onder, achter-boven.
  537   1          for (n=0; n < 3; n++)
  538   1          {
  539   2              for (i=0; i < 4; i++)
  540   2              {
  541   3                  Leds[n][0][i].data    = 0; 
  542   3                  Leds[n][0][i].level   = 0;
  543   3                  Leds[n][1][i].data    = 0; 
  544   3                  Leds[n][1][i].level   = 0;
  545   3              }
  546   2          }
  547   1          for (i=0; i < 4; i++)
  548   1          {
  549   2              Leds[0][0][i].address = 0xF7; // Voor 1-15
  550   2              Leds[0][1][i].address = 0xFB; // Voor 16-31
  551   2              Leds[1][0][i].address = 0xFD; // Achter 101-115
  552   2              Leds[1][1][i].address = 0xFE; // Achter 116-129
  553   2              Leds[2][0][i].address = 0x7F; // Voor 1-15 parallel voor blinken
  554   2              Leds[2][1][i].address = 0xBF; // Voor 16-31  parallel
  555   2          }
  556   1      
  557   1      
  558   1          Sky[ 0].address  = 0x76;  Sky[ 0].data   = 0; Sky[ 0].level   = 0x00;
  559   1          Sky[ 1].address  = 0x74;  Sky[ 1].data   = 0; Sky[ 1].level   = 0x00;
  560   1          Sky[ 2].address  = 0x74;  Sky[ 2].data   = 0; Sky[ 2].level   = 0x00;
  561   1          Sky[ 3].address  = 0x74;  Sky[ 3].data   = 0; Sky[ 3].level   = 0x00;
  562   1          Sky[ 4].address  = 0x74;  Sky[ 4].data   = 0; Sky[ 4].level   = 0x00;
  563   1          Sky[ 5].address  = 0x74;  Sky[ 5].data   = 0; Sky[ 5].level   = 0x00;
  564   1          Sky[ 6].address  = 0x74;  Sky[ 6].data   = 0; Sky[ 6].level   = 0x00;
  565   1          Sky[ 7].address  = 0x74;  Sky[ 7].data   = 0; Sky[ 7].level   = 0x00;
  566   1          Sky[ 8].address  = 0x74;  Sky[ 8].data   = 0; Sky[ 8].level   = 0x00;
  567   1          Sky[ 9].address  = 0x76;  Sky[ 9].data   = 0; Sky[ 9].level   = 0x00;
  568   1          Sky[10].address  = 0x76;  Sky[10].data   = 0; Sky[10].level   = 0x00;
  569   1          Sky[11].address  = 0x76;  Sky[11].data   = 0; Sky[11].level   = 0x00;
  570   1          Sky[12].address  = 0x76;  Sky[12].data   = 0; Sky[12].level   = 0x00;
  571   1          ClearSky();
  572   1          ClearArc();
  573   1      
  574   1          buffer[0] = 0x00;
  575   1          buffer[1] = 0x76;
  576   1          buffer[2] = 0x00;                                                          
  577   1          buffer[3] = 0x00;
  578   1          I2C_SendByte(0x70, 4, buffer);
  579   1      
  580   1          for (i=0; i < 8; i++)
  581   1          {
  582   2              buffer[0] = boards[i];
  583   2              I2C_SendByte(0x4E, 1, buffer);
  584   2              buffer[0] = 0xFF;
  585   2              I2C_SendByte(0x42, 1, buffer);
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 10  

  586   2              I2C_SendByte(0x44, 1, buffer);
  587   2              statusBoards[i][0] = 0xFF;  
  588   2              statusBoards[i][1] = 0xFF;  
  589   2              statusBoards[i][2] = 0xFF;  
  590   2          }
  591   1          ClrBitsPar(outRP2_1);  // sound trigger
  592   1          ClrBitsPar(outRP2_2);  // sound trigger
  593   1          ClrBitsPar(outRA16);   // acq   trigger
  594   1      
  595   1          return(0);
  596   1      }
  597          void getWord(void) 
  598          {
  599   1          int pnt = 0;
  600   1          while ((inBuf[inpPnt] != ';') && (inBuf[inpPnt] != '\0'))
  601   1          {
  602   2              wrd[pnt++] = inBuf[inpPnt++];
  603   2          }
  604   1          wrd[pnt] = '\0';
  605   1          if (inBuf[inpPnt] == '\0') inpPnt = -1; else inpPnt++;
  606   1      }
  607          
  608          int getVal(void) 
  609          {
  610   1          int val = 0;
  611   1          int pnt = 0;
  612   1          if (wrd[0] == '-')
  613   1          {
  614   2              val = -1*(wrd[1] - '0');
  615   2              pnt = 2;
  616   2              while (wrd[pnt] != '\0')
  617   2              {
  618   3                  val *= 10;
  619   3                  val -= wrd[pnt++] - '0';
  620   3              }
  621   2          }
  622   1          else
  623   1          {
  624   2              val = (wrd[0]- '0');
  625   2              pnt = 1;
  626   2              while (wrd[pnt] != '\0')
  627   2              {
  628   3                  val *= 10;
  629   3                  val += wrd[pnt++] - '0';
  630   3              }
  631   2          }
  632   1          return val;
  633   1      }
  634          
  635          void splitInput(void)                   
  636          {
  637   1          outPnt = 0;
  638   1          if (inBuf[0] == '$')
  639   1          {
  640   2              inpPnt = 1;
  641   2              outPnt = 1;
  642   2              while (inpPnt != -1)
  643   2              {
  644   3                  getWord();
  645   3                  nBuffer[outPnt++] = getVal();
  646   3              }
  647   2          }
  648   1          nBuffer[0] = outPnt-1;
  649   1      }
  650          
  651          void ReturnInfo(void)
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 11  

  652          {
  653   1          int n, i;
  654   1      
  655   1          n = 0;
  656   1          while ((n < 80) && (version[n] > 0)) n++;
  657   1          i = UART0_Str(version, n);
  658   1          nBuffer[1] = 0;
  659   1      }
  660          
  661           void GetSamples(void)                 
  662          {
  663   1          adc_buffer buffer;
  664   1          int start, i, n;
  665   1          start = Clock_GetTicks();
  666   1          buffer  = ADC_GetSamples();
  667   1          n = sprintf(outBuf,"%d;%d;%d;%d;%d\n",start, 
  668   1          buffer.data[0],buffer.data[1],buffer.data[2],buffer.data[3]);
  669   1          i = UART0_Str(outBuf, n);
  670   1      }
  671          
  672          void ChannelOn(void)
  673          {
  674   1          ADC_Select(nBuffer[2]);
  675   1      }
  676          
  677          void ChannelOff(void)
  678          {
  679   1          ADC_Select(-1*nBuffer[2]);
  680   1      }
  681          void GetPIO(void)
  682          {
  683   1          int i, n, val;
  684   1      
  685   1          val = GetBitsPar();
  686   1          n = sprintf(outBuf,"%d\n",val);
  687   1          i = UART0_Str(outBuf, n);
  688   1      }
  689          
  690          void Trigger(int bit, int Up)
  691          {
  692   1          if (Up == true)
  693   1          {
  694   2              SetBitsPar(bit);
  695   2              Delay(10000);            // 10000 ca 1.5 mSec
  696   2              ClrBitsPar(bit);
  697   2          }
  698   1          else
  699   1          {
  700   2              ClrBitsPar(bit);
  701   2              Delay(10000);            
  702   2              SetBitsPar(bit);
  703   2          }
  704   1      }
  705          
  706          void SetBitsPar(int i)
  707          {
  708   1          IOSET0 = (i & 0xFF) << 4;          
  709   1      }
  710          
  711          
  712          void ClrBitsPar(int i)
  713          {
  714   1          IOCLR0 = (i & 0xFF) << 4;
  715   1      }
  716          
  717          int GetBitsPar(void)
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 12  

  718          {
  719   1          int i;
  720   1          i = (IOPIN0 >> 17) & 0x00FF;
  721   1          return i;
  722   1      }
  723          
  724          int TstBitPar(int bit)
  725          {
  726   1          int i;
  727   1          i = GetBitsPar();
  728   1          i = (i & bit);
  729   1      
  730   1          return i;
  731   1      }
  732          void WaitForEnter(void)
  733          {
  734   1          int inChar;
  735   1          inChar = 0;
  736   1          
  737   1          while (inChar == 0)
  738   1          {
  739   2              if (UART0_RxNumber() > 0)
  740   2              {
  741   3                  inChar = UART0_Get();
  742   3              }
  743   2          }
  744   1      }
  745          
  746          void ReturnDataMicro(void)
  747          {
  748   1          int t0, i, n, lp;
  749   1      
  750   1          n = sprintf(outBuf,"%d;%d;%d\n",startTime,curTime,nStim);
  751   1          i = UART0_Str(outBuf, n);
  752   1          WaitForEnter();
  753   1      
  754   1          // find start acq
  755   1          t0 = 0; // incase of missing acq
  756   1          for (lp=0; lp <=nStim; lp++)
  757   1          {
  758   2              if (stim[lp].kind == stimAcq)
  759   2              {
  760   3                  t0 = stim[lp].startTime;
  761   3              }
  762   2          }
  763   1      
  764   1          for (lp=0; lp <= nStim; lp++)
  765   1          {
  766   2              switch (stim[lp].kind)
  767   2              {
  768   3              case stimLed:   n = sprintf(outBuf,"%4d;%4d;%4d;%5d;%5d;%4d;   1; NaN; NaN\n",
  769   3                              stimLed, stim[lp].posX,stim[lp].posY, 
  770   3                              stim[lp].startTime-t0,stim[lp].stopTime-t0, stim[lp].level);
  771   3                              break;                                                   
  772   3              case stimLeds:  n = sprintf(outBuf,"%4d;%4d;%4d;%5d;%5d;%4d;   %d; NaN; NaN\n",
  773   3                              stimLeds, stim[lp].posX,stim[lp].posY, 
  774   3                              stim[lp].startTime-t0,stim[lp].stopTime-t0, stim[lp].level, stim[lp].index);
  775   3                              break;                                                   
  776   3              case stimBlink: n = sprintf(outBuf,"%4d;%4d;%4d;%5d;%5d;%4d;   %d; NaN; NaN\n",
  777   3                              stimBlink, stim[lp].posX,stim[lp].posY, 
  778   3                              stim[lp].startTime-t0,stim[lp].stopTime-t0, stim[lp].level, stim[lp].index);
  779   3                              break;                                                   
  780   3              case stimSnd1:  n = sprintf(outBuf,"%4d;%4d;%4d;%5d;%5d;%4d;%4d;%4d; NaN\n",
  781   3                              stimSnd1, stim[lp].posX,stim[lp].posY,           
  782   3                              stim[lp].startTime-t0,stim[lp].stopTime-t0,stim[lp].level,
  783   3                              stim[lp].index,stim[lp].width);
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 13  

  784   3                              break;
  785   3              case stimSnd2:  n = sprintf(outBuf,"%4d;%4d;%4d;%5d;%5d;%4d;%4d;%4d; NaN\n",
  786   3                              stimSnd2, stim[lp].posX,stim[lp].posY,           
  787   3                              stim[lp].startTime-t0,stim[lp].stopTime-t0,stim[lp].level,
  788   3                              stim[lp].index,stim[lp].width);
  789   3                              break;
  790   3              case stimAcq:   n = sprintf(outBuf,"%4d; NaN; NaN;%5d;  NaN; NaN; NaN; NaN; NaN\n",
  791   3                              stimAcq, stim[lp].startTime-t0);
  792   3                              break;
  793   3              case stimTrg0:  n = sprintf(outBuf,"%4d; NaN; NaN;%5d;%5d; NaN; NaN;%4d;%4d\n",
  794   3                              stimTrg0, stim[lp].startTime-t0,stim[lp].stopTime-t0,
  795   3                              stim[lp].bitNo,stim[lp].edge);
  796   3                              break;
  797   3              case stimSky:   n = sprintf(outBuf,"%4d;%4d;%4d;%5d;%5d;%4d;   1; NaN; NaN\n",
  798   3                              stimSky, stim[lp].posX,stim[lp].posY, 
  799   3                              stim[lp].startTime-t0,stim[lp].stopTime-t0, stim[lp].level);
  800   3                              break;                                                   
  801   3              case stimLas:   n = sprintf(outBuf,"%4d; NaN; NaN;%5d;%5d; NaN; NaN;%4d; NaN\n",
  802   3                              stimLas, stim[lp].startTime-t0,stim[lp].stopTime-t0,
  803   3                              stim[lp].bitNo);
  804   3                              break;
  805   3              case stimInp1:  n = sprintf(outBuf,"%4d; NaN; NaN; NaN;  NaN; NaN; NaN; NaN; NaN\n", stimInp1);
  806   3                              break;
  807   3              case stimInp2:  n = sprintf(outBuf,"%4d; NaN; NaN; NaN;  NaN; NaN; NaN; NaN; NaN\n", stimInp2);
  808   3                              break;
  809   3              }
  810   2              i = UART0_Str(outBuf, n);
  811   2              WaitForEnter();
  812   2          }
  813   1      
  814   1          tBuf[4] = Clock_GetTicks();
  815   1          n = sprintf(outBuf,"%d;%d;%d;%d;%d\n",
  816   1                  tBuf[0],tBuf[1],tBuf[2],tBuf[3],tBuf[4]);
  817   1          i = UART0_Str(outBuf, n);
  818   1          WaitForEnter();
  819   1      }
  820          
  821          int ExecLed(int i)
  822          { 
  823   1          curTime = Clock_GetTicks();
  824   1          if (stim[i].status == statInit)
  825   1          {
  826   2              if ((stim[i].startRef == 0) && (curTime >= stim[i].startTime))
  827   2              {
  828   3                  LedOnOff(stim[i].posY, stim[i].level, ON, false);
  829   3                  curTime = Clock_GetTicks();
  830   3                  stim[i].startTime = curTime;
  831   3                  stim[i].status = statRun;
  832   3              }
  833   2              return 1;
  834   2          }
  835   1          
  836   1          if (stim[i].status == statRun)
  837   1          {
  838   2              if ((stim[i].stopRef == 0) && (curTime >= stim[i].stopTime))
  839   2              {
  840   3                  LedOnOff(stim[i].posY, stim[i].level, OFF, false);
  841   3                  curTime = Clock_GetTicks();
  842   3                  stim[i].stopTime = curTime;
  843   3                  stim[i].status = statDone;
  844   3                  return 0;
  845   3              }
  846   2              return 1;
  847   2          }
  848   1      
  849   1          return 0;
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 14  

  850   1      }
  851          
  852          int ExecLeds(int i)
  853          {   
  854   1          int n;
  855   1          curTime = Clock_GetTicks();
  856   1          if (stim[i].status == statInit)
  857   1          {
  858   2              if ((stim[i].startRef == 0) && (curTime >= stim[i].startTime))
  859   2              {
  860   3                  for (n = 1;n < 30; n++)
  861   3                      LedOnOff(n, stim[i].level, ON, false);
  862   3                  curTime = Clock_GetTicks();
  863   3                  stim[i].startTime = curTime;
  864   3                  stim[i].status = statRun;
  865   3              }
  866   2              return 1;
  867   2          }
  868   1          
  869   1          if (stim[i].status == statRun)
  870   1          {
  871   2              if ((stim[i].stopRef == 0) && (curTime >= stim[i].stopTime))
  872   2              {
  873   3                  for (n = 1;n < 30; n++)
  874   3                      LedOnOff(n, stim[i].level, OFF, false);
  875   3                  curTime = Clock_GetTicks();
  876   3                  stim[i].stopTime = curTime;
  877   3                  stim[i].status = statDone;
  878   3                  return 0;
  879   3              }
  880   2              return 1;
  881   2          }
  882   1      
  883   1          return 0;
  884   1      }
  885          //qq
  886          int ExecBlink(int i)
  887          { 
  888   1          curTime = Clock_GetTicks();
  889   1          if (stim[i].status == statInit)
  890   1          {
  891   2              if ((stim[i].startRef == 0) && (curTime >= stim[i].startTime))
  892   2              {
  893   3                  LedOnOff(stim[i].posY, stim[nStimLeds].level, OFF, false);
  894   3                  LedOnOff(stim[i].posY, stim[i].level, ON, true);
  895   3                  curTime = Clock_GetTicks();
  896   3                  stim[i].startTime = curTime;
  897   3                  stim[i].status = statRun;
  898   3              }
  899   2              return 1;
  900   2          }
  901   1          
  902   1          if (stim[i].status == statRun)                     
  903   1          {
  904   2              if ((stim[i].stopRef == 0) && (curTime >= stim[i].stopTime))
  905   2              {
  906   3                  LedOnOff(stim[i].posY, stim[0].level, OFF, true);
  907   3                  LedOnOff(stim[i].posY, stim[nStimLeds].level, ON, false);
  908   3                  curTime = Clock_GetTicks();
  909   3                  stim[i].stopTime = curTime;
  910   3                  stim[i].status = statDone;
  911   3                  return 0;
  912   3              }
  913   2              return 1;
  914   2          }
  915   1      
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 15  

  916   1          return 0;
  917   1      }
  918          
  919          int ExecSky(int i)
  920          { 
  921   1          curTime = Clock_GetTicks();
  922   1          if (stim[i].status == statInit)
  923   1          {
  924   2              if ((stim[i].startRef == 0) && (curTime >= stim[i].startTime))
  925   2              {
  926   3                  SkyOnOff(stim[i].posX, stim[i].posY, stim[i].level, ON);
  927   3                  curTime = Clock_GetTicks();
  928   3                  stim[i].startTime = curTime;
  929   3                  stim[i].status = statRun;
  930   3              }
  931   2              return 1;
  932   2          }
  933   1          
  934   1          if (stim[i].status == statRun)
  935   1          {
  936   2              if ((stim[i].stopRef == 0) && (curTime >= stim[i].stopTime))
  937   2              {
  938   3                  SkyOnOff(stim[i].posX, stim[i].posY, stim[i].level, OFF);
  939   3                  curTime = Clock_GetTicks();
  940   3                  stim[i].stopTime = curTime;
  941   3                  stim[i].status = statDone;
  942   3                  return 0;
  943   3              }
  944   2              return 1;
  945   2          }
  946   1      
  947   1          return 0;
  948   1      
  949   1      }     
  950          
  951          int ExecSnd(int i)
  952          {
  953   1          int n, tmp, board, address, bit, speaker;
  954   1          unsigned char buffer[2];
  955   1          curTime = Clock_GetTicks();
  956   1          if (stim[i].status == statInit)
  957   1          {
  958   2              if ((stim[i].startRef == 0) && (curTime >= stim[i].startTime))
  959   2              {
  960   3                  // Select board en speaker
  961   3                  n = stim[i].posY + 2;
  962   3                  // speaker 30=1, speaker 31=2
  963   3                  if (n == 32) n = 1;
  964   3                  if (n == 33) n = 2;
  965   3                  // < 100 voor- anders achterzijde
  966   3                  if (n < 100) board = n / 8; else board = ((n - 100) / 8) + 4;
  967   3                  if (n > 100) n = n - 100 + 32;  // correctie voor/achter en board 4=board 0
  968   3                  speaker = n - 8*board;
  969   3      
  970   3                  address   = 0x4E;
  971   3                  buffer[0] = boards[board]; 
  972   3                  I2C_SendByte(address, 1, buffer);
  973   3      
  974   3                  // Set signal 1 or 2
  975   3                  tmp = statusBoards[board][0];
  976   3      
  977   3                  if (stim[i].kind == stimSnd1) 
  978   3                      tmp |= speakers[speaker];       // set speakerbit
  979   3                  else
  980   3                      tmp &= ~speakers[speaker];      // clr speakerbit 
  981   3      
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 16  

  982   3                  statusBoards[board][0] = tmp;
  983   3                  buffer[0] = tmp;
  984   3                  address   = 0x40;
  985   3                  I2C_SendByte(address, 1, buffer);
  986   3      
  987   3                  if (speaker < 4)
  988   3                  {
  989   4                      address  = 0x44;
  990   4                      tmp = statusBoards[board][1];
  991   4                      if (stim[i].kind == stimSnd1)
  992   4                          tmp &= gain1[speaker];
  993   4                      else
  994   4                          tmp &= gain2[speaker];
  995   4                      statusBoards[board][1] = tmp;
  996   4                  }
  997   3                  else
  998   3                  {
  999   4                      address  = 0x42;
 1000   4                      tmp = statusBoards[board][2];
 1001   4                      if (stim[i].kind == stimSnd1)
 1002   4                          tmp &= gain1[speaker];
 1003   4                      else
 1004   4                          tmp &= gain2[speaker];
 1005   4                      statusBoards[board][2] = tmp;
 1006   4                  }
 1007   3      
 1008   3                  buffer[0] = tmp;
 1009   3                  I2C_SendByte(address, 1, buffer);
 1010   3                  
 1011   3                  // Trigger TDT
 1012   3                  curTime = Clock_GetTicks();
 1013   3                  
 1014   3                  if (snd12Flag == 3) // beide triggeren
 1015   3                  {
 1016   4                      if (stim[i].kind == stimSnd1) tmpSnd1[0] = 0; else tmpSnd2[0] = 0; 
 1017   4                      if ((tmpSnd1[0] == 0) && (tmpSnd2[0] == 0)) // beide geladen
 1018   4                      {
 1019   5                          Trigger(outRP2_1 | outRP2_2,true);
 1020   5                          stim[tmpSnd1[3]].startTime = curTime;
 1021   5                          stim[tmpSnd1[3]].status    = statRun;
 1022   5                          stim[tmpSnd2[3]].startTime = curTime;
 1023   5                          stim[tmpSnd2[3]].status    = statRun;
 1024   5                      }
 1025   4                  }
 1026   3                  else
 1027   3                  {
 1028   4                      if (stim[i].kind == stimSnd1) 
 1029   4                          Trigger(outRP2_1,true); // Start
 1030   4                      else
 1031   4                          Trigger(outRP2_2,true);
 1032   4      
 1033   4                      stim[i].startTime = curTime;
 1034   4                      stim[i].status    = statRun;
 1035   4                  }
 1036   3                  
 1037   3              }
 1038   2              return 1;
 1039   2          }
 1040   1          if (stim[i].status == statRun)
 1041   1          {
 1042   2              if (curTime > (stim[i].startTime+100))
 1043   2              {
 1044   3                  if (stim[i].kind == stimSnd1)
 1045   3                      bit = TstBitPar(inpRP2_1);
 1046   3                  else
 1047   3                      bit = TstBitPar(inpRP2_2);
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 17  

 1048   3                  if (bit == 0)
 1049   3                  {
 1050   4                      stim[i].stopTime = curTime;
 1051   4                      stim[i].status   = statDone;
 1052   4                      // Select board
 1053   4                      n = stim[i].posY + 2;
 1054   4                      // speaker 30=1, speaker 31=2
 1055   4                      if (n == 32) n = 1;
 1056   4                      if (n == 33) n = 2;
 1057   4                      if (n < 100) board = n / 8; else board = ((n - 100) / 8) + 4;
 1058   4                      if (n > 100) n = n - 100 + 32;  // correctie voor/achter en board 4=board 0
 1059   4                      speaker = n - 8*board;
 1060   4                      address   = 0x4E;
 1061   4                      buffer[0] = boards[board]; 
 1062   4                      I2C_SendByte(address, 1, buffer);
 1063   4      
 1064   4                      if (speaker < 4)
 1065   4                      {
 1066   5                          address  = 0x44;
 1067   5                          tmp = statusBoards[board][1];
 1068   5                          if (stim[i].kind == stimSnd1)
 1069   5                              tmp |= ~gain1[speaker];
 1070   5                          else
 1071   5                              tmp |= ~gain2[speaker];
 1072   5                          statusBoards[board][1] = tmp;
 1073   5                      }
 1074   4                      else
 1075   4                      {
 1076   5                          address  = 0x42;
 1077   5                          tmp = statusBoards[board][2];
 1078   5                          if (stim[i].kind == stimSnd1)
 1079   5                              tmp |= ~gain1[speaker];
 1080   5                          else
 1081   5                              tmp |= ~gain2[speaker];
 1082   5                          statusBoards[board][2] = tmp;
 1083   5                      }
 1084   4      
 1085   4                      buffer[0] = tmp;
 1086   4                      I2C_SendByte(address, 1, buffer);
 1087   4                      return 0;
 1088   4                  }
 1089   3              }
 1090   2              return 1;
 1091   2          }
 1092   1          return 0;
 1093   1      }
 1094          
 1095          void SpeakersOff(void)
 1096          { // niet goed, per board moeten sig en speakers worden gereset.
 1097   1          int address;
 1098   1          unsigned char buffer[2];
 1099   1      
 1100   1          address   = 0x4E;   // board
 1101   1          buffer[0] = 0xFF;   I2C_SendByte(address, 1, buffer);
 1102   1      
 1103   1          address   = 0x40;   // signal
 1104   1          buffer[0] = 0xFF;   I2C_SendByte(address, 1, buffer);
 1105   1          
 1106   1          buffer[0] = 0xFF;   // speakers
 1107   1          address  = 0x44;    I2C_SendByte(address, 1, buffer);
 1108   1          address  = 0x42;    I2C_SendByte(address, 1, buffer);
 1109   1      }
 1110          void ExecEvent(int event)
 1111          {
 1112   1          int i, time;
 1113   1          time = Clock_GetTicks();
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 18  

 1114   1          for (i = 0; i <= nStim; i++)
 1115   1          {
 1116   2              if (stim[i].startRef == event)
 1117   2              {
 1118   3                  stim[i].startRef = 0;
 1119   3                  stim[i].startTime += time;
 1120   3              }
 1121   2              if (stim[i].stopRef == event)
 1122   2              {
 1123   3                  stim[i].stopRef = 0;
 1124   3                  stim[i].stopTime += time;
 1125   3              }
 1126   2          }
 1127   1      }
 1128          
 1129          int ExecTrg0(int i)
 1130          {
 1131   1          int bit;
 1132   1          curTime = Clock_GetTicks();
 1133   1          if (stim[i].status == statInit)
 1134   1          {
 1135   2              if ((stim[i].startRef == 0) && (curTime >= stim[i].startTime))
 1136   2              {
 1137   3                  bit = TstBitPar(inpExtTrigger);
 1138   3                  if (stim[i].edge == 1)
 1139   3                  {
 1140   4                      if (bit == 0)
 1141   4                      {
 1142   5                          stim[i].startTime = curTime;
 1143   5                          stim[i].status    = statRun;
 1144   5                      }
 1145   4                  }
 1146   3                  else
 1147   3                  {
 1148   4                      if (bit > 0)
 1149   4                      {
 1150   5                          stim[i].startTime = curTime;
 1151   5                          stim[i].status    = statRun;
 1152   5                      }
 1153   4                  }
 1154   3              }
 1155   2              return 1;
 1156   2          }
 1157   1          if (stim[i].status == statRun)
 1158   1          {
 1159   2              bit = TstBitPar(inpExtTrigger);
 1160   2              if (stim[i].edge == 1)
 1161   2              {
 1162   3                  if (bit > 0)
 1163   3                  {
 1164   4                      stim[i].stopTime = curTime;
 1165   4                      stim[i].status   = statDone;
 1166   4                      ExecEvent(stim[i].event);
 1167   4                      return 0;
 1168   4                  }
 1169   3              }
 1170   2              else
 1171   2              {
 1172   3                  if (bit == 0)
 1173   3                  {
 1174   4                      stim[i].stopTime = curTime;
 1175   4                      stim[i].status   = statDone;
 1176   4                      ExecEvent(stim[i].event);
 1177   4                      return 0;
 1178   4                  }
 1179   3              }
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 19  

 1180   2              return 1;
 1181   2          }
 1182   1          return 0;
 1183   1      }
 1184          
 1185          int ExecLas(int i) 
 1186          {
 1187   1          int bitNo = (1 << (stim[i].bitNo-1));
 1188   1          curTime = Clock_GetTicks();
 1189   1      
 1190   1          if (stim[i].status == statInit) 
 1191   1          {
 1192   2              if ((stim[i].startRef == 0) && (curTime >= stim[i].startTime)) 
 1193   2              {
 1194   3                  curTime = Clock_GetTicks();
 1195   3                  stim[i].startTime = curTime;
 1196   3                  stim[i].status = statRun;
 1197   3                  SetBitsPar(bitNo);
 1198   3              } 
 1199   2              return 1;
 1200   2          }
 1201   1      
 1202   1          if (stim[i].status == statRun) 
 1203   1          {
 1204   2              if ((stim[i].stopRef == 0) && (curTime >= stim[i].stopTime)) 
 1205   2              {
 1206   3                  curTime = Clock_GetTicks();
 1207   3                  stim[i].stopTime = curTime;
 1208   3                  stim[i].status = statDone;
 1209   3                  ClrBitsPar(bitNo);
 1210   3                  return 0; 
 1211   3              } 
 1212   2              return 1;
 1213   2          }
 1214   1          return 0;
 1215   1      }
 1216          
 1217          int ExecAcq(int i)
 1218          {
 1219   1          int bit;
 1220   1      
 1221   1          curTime = Clock_GetTicks();
 1222   1          if (stim[i].status == statInit)
 1223   1          {
 1224   2              if ((stim[i].startRef == 0) && (curTime >= stim[i].startTime))
 1225   2              {
 1226   3                  stim[i].startTime = curTime;
 1227   3                  Trigger(outRA16,true);
 1228   3                  stim[i].status = statRun;                      
 1229   3              }
 1230   2              return 1;
 1231   2          }
 1232   1      
 1233   1          if (stim[i].status == statRun)
 1234   1          {
 1235   2              if (curTime > (stim[i].startTime+100))
 1236   2              {                                        
 1237   3                  bit = TstBitPar(inpRA16);
 1238   3                  if (bit == 0)
 1239   3                  {
 1240   4                      stim[i].stopTime = curTime;
 1241   4                      stim[i].status = statDone;
 1242   4                      return 0;
 1243   4                  }
 1244   3              }
 1245   2              return 1;
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 20  

 1246   2          }
 1247   1      
 1248   1          return 0;
 1249   1      }
 1250          
 1251          void GetTime()
 1252          {
 1253   1          int val, n, i;
 1254   1          val = Clock_GetTicks();
 1255   1          n = sprintf(outBuf,"%d\n",val);
 1256   1          i = UART0_Str(outBuf, n);
 1257   1          nBuffer[1] = 0;
 1258   1      }
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 21  

ASSEMBLY LISTING OF GENERATED OBJECT CODE



*** EXTERNALS:
 EXTERN CODE16 (sprintf?T)
 EXTERN CODE16 (LPCinit?T)
 EXTERN CODE16 (Clock_Init?T)
 EXTERN CODE16 (Clock_GetTicks?T)
 EXTERN CODE16 (Clock_GetSeconds?T)
 EXTERN CODE16 (Clock_Reset?T)
 EXTERN CODE16 (UART0_Init?T)
 EXTERN CODE16 (UART0_RxNumber?T)
 EXTERN CODE16 (UART0_Get?T)
 EXTERN CODE16 (UART0_Str?T)
 EXTERN CODE16 (I2C_Init?T)
 EXTERN CODE16 (I2C_SendByte?T)
 EXTERN CODE16 (ADC_Init?T)
 EXTERN CODE16 (ADC_Select?T)
 EXTERN CODE16 (ADC_GetSamples?T)
 EXTERN CODE16 (?C?SDIV?T)
 EXTERN NUMBER (__startup)



*** PUBLICS:
 PUBLIC         InitAll?T
 PUBLIC         LedOnOff?T
 PUBLIC         SkyOnOff?T
 PUBLIC         ClearSky?T
 PUBLIC         ClearArc?T
 PUBLIC         getWord?T
 PUBLIC         getVal?T
 PUBLIC         splitInput?T
 PUBLIC         ReturnInfo?T
 PUBLIC         ChannelOn?T
 PUBLIC         ChannelOff?T
 PUBLIC         GetPIO?T
 PUBLIC         Trigger?T
 PUBLIC         ReturnDataMicro?T
 PUBLIC         SpeakersOff?T
 PUBLIC         ExecLed?T
 PUBLIC         ExecLeds?T
 PUBLIC         ExecBlink?T
 PUBLIC         ExecSky?T
 PUBLIC         ExecSnd?T
 PUBLIC         ExecEvent?T
 PUBLIC         ExecTrg0?T
 PUBLIC         ExecAcq?T
 PUBLIC         ExecLas?T
 PUBLIC         ClrBitsPar?T
 PUBLIC         SetBitsPar?T
 PUBLIC         GetBitsPar?T
 PUBLIC         TstBitPar?T
 PUBLIC         GetTime?T
 PUBLIC         Delay?T
 PUBLIC         main
 PUBLIC         GetSamples?T
 PUBLIC         WaitForEnter?T
 PUBLIC         version
 PUBLIC         inBuf
 PUBLIC         outBuf
 PUBLIC         inpPnt
 PUBLIC         outPnt
 PUBLIC         wrd
 PUBLIC         nBuffer
 PUBLIC         nStatus
 PUBLIC         nStimLeds
 PUBLIC         startTime
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 22  

 PUBLIC         curTime
 PUBLIC         nStim
 PUBLIC         newStim
 PUBLIC         stim
 PUBLIC         tmp
 PUBLIC         Leds
 PUBLIC         Sky
 PUBLIC         boards
 PUBLIC         speakers
 PUBLIC         gain1
 PUBLIC         gain2
 PUBLIC         statusBoards
 PUBLIC         tBuf
 PUBLIC         snd12Flag
 PUBLIC         tmpSnd1
 PUBLIC         tmpSnd2



*** DATA SEGMENT '?CON?Human':
 00000000          ?tpl?0001:
 00000000           BEGIN_INIT
 00000000  0000000D  DD          0xD
 00000004  0000000C  DD          0xC
 00000008  0000000B  DD          0xB
 0000000C  0000000A  DD          0xA
 00000010  00000009  DD          0x9
 00000014  00000008  DD          0x8
 00000018  00000007  DD          0x7
 0000001C  00000006  DD          0x6
 00000020  00000005  DD          0x5
 00000024  00000004  DD          0x4
 00000028  00000003  DD          0x3
 0000002C  00000002  DD          0x2
 00000030  00000001  DD          0x1
 00000034  00000020  DD          0x20
 00000038  0000001F  DD          0x1F
 0000003C  0000001E  DD          0x1E
 00000040  0000001D  DD          0x1D
 00000044  0000001C  DD          0x1C
 00000048  0000001B  DD          0x1B
 0000004C  0000001A  DD          0x1A
 00000050  00000019  DD          0x19
 00000054  00000018  DD          0x18
 00000058  00000017  DD          0x17
 0000005C  00000016  DD          0x16
 00000060  00000015  DD          0x15
 00000064  00000014  DD          0x14
 00000068  00000013  DD          0x13
 0000006C  00000012  DD          0x12
 00000070  00000011  DD          0x11
 00000074  0000000F  DD          0xF
 00000078  0000000E  DD          0xE
 0000007C           END_INIT
 0000007C          ??S_11:
 0000007C            DB          '%4d; NaN; NaN; NaN;  NaN; NaN; NaN; Na'
 000000A2            DB          'N; NaN',0x0A,0x00
 000000AA          ??S_10:
 000000AA            DB          '%4d; NaN; NaN;%5d;%5d; NaN; NaN;%4d; N'
 000000D0            DB          'aN',0x0A,0x00
 000000D4          ??S_9:
 000000D4            DB          '%4d; NaN; NaN;%5d;%5d; NaN; NaN;%4d;%4'
 000000FA            DB          'd',0x0A,0x00
 000000FD          ??S_8:
 000000FD            DB          '%4d; NaN; NaN;%5d;  NaN; NaN; NaN; NaN'
 00000123            DB          '; NaN',0x0A,0x00
 0000012A          ??S_7:
 0000012A            DB          '%4d;%4d;%4d;%5d;%5d;%4d;%4d;%4d; NaN',0x0A
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 23  

 0000014F            DB          0x00
 00000150          ??S_6:
 00000150            DB          '%4d;%4d;%4d;%5d;%5d;%4d;   %d; NaN; Na'
 00000176            DB          'N',0x0A,0x00
 00000179          ??S_5:
 00000179            DB          '%4d;%4d;%4d;%5d;%5d;%4d;   1; NaN; NaN'
 0000019F            DB          0x0A,0x00
 000001A1          ??S_4:
 000001A1            DB          '%d;%d;%d',0x0A,0x00
 000001AB          ??S_3:
 000001AB            DB          '%d;%d;%d;%d;%d',0x0A,0x00
 000001BB          ??S_2:
 000001BB            DB          '%d',0x0A,0x00

*** DATA SEGMENT '?DT0?Human':
 00000000          inpPnt:
 00000000            DS          4
 00000004          outPnt:
 00000004            DS          4
 00000008          nBuffer:
 00000008            DS          48
 00000038          nStatus:
 00000038            DS          4
 0000003C          nStimLeds:
 0000003C           BEGIN_INIT
 0000003C  00000000  DD          0x0
 00000040           END_INIT
 00000040          startTime:
 00000040            DS          4
 00000044          curTime:
 00000044            DS          4
 00000048          nStim:
 00000048           BEGIN_INIT
 00000048  00000000  DD          0x0
 0000004C           END_INIT
 0000004C          newStim:
 0000004C           BEGIN_INIT
 0000004C  00000000  DD          0x0
 00000050           END_INIT
 00000050          stim:
 00000050            DS          1200
 00000500          tmp:
 00000500            DS          28
 0000051C          Leds:
 0000051C            DS          288
 0000063C          Sky:
 0000063C            DS          156
 000006D8          boards:
 000006D8           BEGIN_INIT
 000006D8  000000F7  DD          0xF7
 000006DC  000000FB  DD          0xFB
 000006E0  000000FD  DD          0xFD
 000006E4  000000FE  DD          0xFE
 000006E8  0000007F  DD          0x7F
 000006EC  000000BF  DD          0xBF
 000006F0  000000DF  DD          0xDF
 000006F4  000000EF  DD          0xEF
 000006F8           END_INIT
 000006F8          speakers:
 000006F8           BEGIN_INIT
 000006F8  00000080  DD          0x80
 000006FC  00000040  DD          0x40
 00000700  00000020  DD          0x20
 00000704  00000010  DD          0x10
 00000708  00000008  DD          0x8
 0000070C  00000004  DD          0x4
 00000710  00000002  DD          0x2
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 24  

 00000714  00000001  DD          0x1
 00000718           END_INIT
 00000718          gain1:
 00000718           BEGIN_INIT
 00000718  0000007F  DD          0x7F
 0000071C  000000DF  DD          0xDF
 00000720  000000F7  DD          0xF7
 00000724  000000FD  DD          0xFD
 00000728  0000007F  DD          0x7F
 0000072C  000000DF  DD          0xDF
 00000730  000000F7  DD          0xF7
 00000734  000000FD  DD          0xFD
 00000738           END_INIT
 00000738          gain2:
 00000738           BEGIN_INIT
 00000738  000000BF  DD          0xBF
 0000073C  000000EF  DD          0xEF
 00000740  000000FB  DD          0xFB
 00000744  000000FE  DD          0xFE
 00000748  000000BF  DD          0xBF
 0000074C  000000EF  DD          0xEF
 00000750  000000FB  DD          0xFB
 00000754  000000FE  DD          0xFE
 00000758           END_INIT
 00000758          statusBoards:
 00000758            DS          96
 000007B8          tBuf:
 000007B8            DS          24
 000007D0          snd12Flag:
 000007D0            DS          4
 000007D4          tmpSnd1:
 000007D4            DS          16
 000007E4          tmpSnd2:
 000007E4            DS          16
 000007F4          version:
 000007F4           BEGIN_INIT
 000007F4            DB          'LPC2119',0x09,' - Human ',0x09,'1.30 1'
 0000080C            DB          '9-Oct-2009',0x0A,0x00
 00000818           END_INIT
 00000818          inBuf:
 00000818            DS          80
 00000868          outBuf:
 00000868            DS          80
 000008B8          wrd:
 000008B8            DS          10



*** CODE SEGMENT '?PR?Delay?T?Human':
   68: void Delay (unsigned long a)
 00000000  ---- Variable 'a' assigned to Register 'R0' ----
   70:     while (--a != 0);
 00000000          L_1:
 00000000  1C01      MOV         R1,R0 ; a
 00000002  3901      SUB         R1,#0x1
 00000004  1C08      MOV         R0,R1 ; a
 00000006  2900      CMP         R1,#0x0 ; a
 00000008  D1FA      BNE         L_1  ; T=0x00000000
   71: }
 0000000A  4770      BX          R14
 0000000C          ENDP ; 'Delay?T'


*** CODE SEGMENT '?PR?LedOnOff?T?Human':
   76: void LedOnOff(int index, int level, int OnOff, int parallel)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C1E      MOV         R6,R3 ; parallel
 00000004  ---- Variable 'parallel' assigned to Register 'R6' ----
 00000004  1C14      MOV         R4,R2 ; OnOff
 00000006  ---- Variable 'OnOff' assigned to Register 'R4' ----
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 25  

 00000006  1C0D      MOV         R5,R1 ; level
 00000008  ---- Variable 'level' assigned to Register 'R5' ----
 00000008  1C07      MOV         R7,R0 ; index
 0000000A  ---- Variable 'index' assigned to Register 'R7' ----
 0000000A  B0A9      SUB         R13,#0xA4
   77: {
 0000000C            ; SCOPE-START
   80:     int PWM1 = 0x14;    // (autoincrement (16) + register
 0000000C  2014      MOV         R0,#0x14
 0000000E  9005      STR         R0,[R13,#0x14] ; PWM1
   81:     int LS0  = 0x06;    
 00000010  2006      MOV         R0,#0x6
 00000012  9006      STR         R0,[R13,#0x18] ; LS0
   82:     int LS1  = 0x07;    
 00000014  2007      MOV         R0,#0x7
 00000016  9007      STR         R0,[R13,#0x1C] ; LS1
   83:     int LS2  = 0x08;    
 00000018  2008      MOV         R0,#0x8
 0000001A  9008      STR         R0,[R13,#0x20] ; LS2
   84:     int LS3  = 0x09;
 0000001C  2009      MOV         R0,#0x9
 0000001E  9009      STR         R0,[R13,#0x24] ; LS3
   86:     int ledsIndex[] = { 13,12,11,10, 9, 8, 7, 6, 5, 4, 3, 2, 1,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,15,14
             -};
 00000020  4800      LDR         R1,=?tpl?0001 ; ?tpl?0001
 00000022  A80A      ADD         R0,R13,#0x28
 00000024  227C      MOV         R2,#0x7C
 00000026          L_310:
 00000026  780B      LDRB        R3,[R1,#0x0]
 00000028  7003      STRB        R3,[R0,#0x0]
 0000002A  1C49      ADD         R1,R1,#0x1
 0000002C  1C40      ADD         R0,R0,#0x1
 0000002E  1E52      SUB         R2,R2,#0x1
 00000030  D1F9      BNE         L_310  ; T=0x00000026
   90:     if (index > 100) led = index - 100; else led = index; // led in de range van 1..29 
 00000032  2F64      CMP         R7,#0x64 ; index
 00000034  DD03      BLE         L_5  ; T=0x0000003E
 00000036  1C38      MOV         R0,R7 ; index
 00000038  3864      SUB         R0,#0x64
 0000003A  9002      STR         R0,[R13,#0x8] ; led
 0000003C  E000      B           L_6  ; T=0x00000040
 0000003E          L_5:
 0000003E  9702      STR         R7,[R13,#0x8] ; index
 00000040          L_6:
   91:     led = ledsIndex[led-1];                               // hernummering ivm elektronica
 00000040  9902      LDR         R1,[R13,#0x8] ; led
 00000042  0089      LSL         R1,R1,#0x2
 00000044  A809      ADD         R0,R13,#0x24
 00000046  5840      LDR         R0,[R0,R1]
 00000048  9002      STR         R0,[R13,#0x8] ; led
   92:     if (led <= 16) ic = 0; else ic = 1;                   // IC 1..2
 0000004A  9802      LDR         R0,[R13,#0x8] ; led
 0000004C  2810      CMP         R0,#0x10
 0000004E  DC02      BGT         L_7  ; T=0x00000056
 00000050  2100      MOV         R1,#0x0
 00000052  9101      STR         R1,[R13,#0x4] ; ic
 00000054  E001      B           L_8  ; T=0x0000005A
 00000056          L_7:
 00000056  2101      MOV         R1,#0x1
 00000058  9101      STR         R1,[R13,#0x4] ; ic
 0000005A          L_8:
   93:     led = led - ic*16;                                    // led 1..16
 0000005A  9A01      LDR         R2,[R13,#0x4] ; ic
 0000005C  0111      LSL         R1,R2,#0x4
 0000005E  1A40      SUB         R0,R1
 00000060  9002      STR         R0,[R13,#0x8] ; led
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 26  

   94:     ls = (led-1)/4;                                       // led selector 1..4
 00000062  9802      LDR         R0,[R13,#0x8] ; led
 00000064  3801      SUB         R0,#0x1
 00000066  2104      MOV         R1,#0x4
 00000068  F7FF      BL          ?C?SDIV?T  ; T=0x0001  (1) ; ?C?SDIV?T
 0000006A  FFCA      BL          ?C?SDIV?T  ; T=0x0001  (2) ; ?C?SDIV?T
 0000006C  1C08      MOV         R0,R1
 0000006E  9003      STR         R0,[R13,#0xC] ; ls
   96:     if (index < 100) n = 0; else n = 1;
 00000070  2F64      CMP         R7,#0x64 ; index
 00000072  DA02      BGE         L_9  ; T=0x0000007A
 00000074  2000      MOV         R0,#0x0
 00000076  9000      STR         R0,[R13,#0x0] ; n
 00000078  E001      B           L_10  ; T=0x0000007E
 0000007A          L_9:
 0000007A  2001      MOV         R0,#0x1
 0000007C  9000      STR         R0,[R13,#0x0] ; n
 0000007E          L_10:
   97:     if (parallel == true) n = 2;
 0000007E  2E01      CMP         R6,#0x1 ; parallel
 00000080  D101      BNE         L_11  ; T=0x00000086
 00000082  2002      MOV         R0,#0x2
 00000084  9000      STR         R0,[R13,#0x0] ; n
 00000086          L_11:
   98:     buffer[0] = Leds[n][ic][ls].address;                  // adres led-IC
 00000086  2030      MOV         R0,#0x30
 00000088  4350      MUL         R0,R2
 0000008A  9900      LDR         R1,[R13,#0x0] ; n
 0000008C  2260      MOV         R2,#0x60
 0000008E  4351      MUL         R1,R2
 00000090  1809      ADD         R1,R0
 00000092  9803      LDR         R0,[R13,#0xC] ; ls
 00000094  220C      MOV         R2,#0xC
 00000096  4350      MUL         R0,R2
 00000098  1809      ADD         R1,R0
 0000009A  4800      LDR         R0,=Leds ; Leds
 0000009C  5841      LDR         R1,[R0,R1]
 0000009E  A804      ADD         R0,R13,#0x10
 000000A0  7001      STRB        R1,[R0,#0x0] ; buffer
   99:      I2C_SendByte(0x72, 1, buffer);                       // laad pre-selectie met adres
 000000A2  AA04      ADD         R2,R13,#0x10
 000000A4  2072      MOV         R0,#0x72
 000000A6  2101      MOV         R1,#0x1
 000000A8  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 000000AA  FFAA      BL          I2C_SendByte?T  ; T=0x0001  (2)
  102:     buffer[0] = PWM1;               // subaddress
 000000AC  9905      LDR         R1,[R13,#0x14] ; PWM1
 000000AE  A804      ADD         R0,R13,#0x10
 000000B0  7001      STRB        R1,[R0,#0x0] ; buffer
  103:     buffer[1] = 0;                  // PSC1
 000000B2  2100      MOV         R1,#0x0
 000000B4  2011      MOV         R0,#0x11
 000000B6  4468      ADD         R0,R13
 000000B8  7001      STRB        R1,[R0,#0x0] ; buffer+1
  104:     buffer[2] = level & 0xFF;
 000000BA  21FF      MOV         R1,#0xFF
 000000BC  4029      AND         R1,R5 ; level
 000000BE  2012      MOV         R0,#0x12
 000000C0  4468      ADD         R0,R13
 000000C2  7001      STRB        R1,[R0,#0x0] ; buffer+2
  105:     I2C_SendByte(0xC0, 3, buffer);  // preselectie bepaalt welk IC adres C0 heeft
 000000C4  AA04      ADD         R2,R13,#0x10
 000000C6  20C0      MOV         R0,#0xC0
 000000C8  2103      MOV         R1,#0x3
 000000CA  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 000000CC  FF99      BL          I2C_SendByte?T  ; T=0x0001  (2)
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 27  

  109:     led = (led-1) % 4;
 000000CE  9802      LDR         R0,[R13,#0x8] ; led
 000000D0  3801      SUB         R0,#0x1
 000000D2  2104      MOV         R1,#0x4
 000000D4  F7FF      BL          ?C?SDIV?T  ; T=0x0001  (1) ; ?C?SDIV?T
 000000D6  FF94      BL          ?C?SDIV?T  ; T=0x0001  (2) ; ?C?SDIV?T
 000000D8  1C01      MOV         R1,R0
 000000DA  9102      STR         R1,[R13,#0x8] ; led
  110:     tmp = (0x03 << (2*(led)));      // 11 = blink at PWM1 rate
 000000DC  9802      LDR         R0,[R13,#0x8] ; led
 000000DE  0040      LSL         R0,R0,#0x1
 000000E0  2303      MOV         R3,#0x3
 000000E2  4083      LSL         R3,R0
 000000E4  ---- Variable 'tmp' assigned to Register 'R3' ----
  111:     if (OnOff == ON)
 000000E4  2C01      CMP         R4,#0x1 ; OnOff
 000000E6  D110      BNE         L_12  ; T=0x0000010A
  112:         Leds[n][ic][ls].data |= tmp;
 000000E8  9801      LDR         R0,[R13,#0x4] ; ic
 000000EA  2130      MOV         R1,#0x30
 000000EC  4348      MUL         R0,R1
 000000EE  9900      LDR         R1,[R13,#0x0] ; n
 000000F0  2260      MOV         R2,#0x60
 000000F2  4351      MUL         R1,R2
 000000F4  1809      ADD         R1,R0
 000000F6  9803      LDR         R0,[R13,#0xC] ; ls
 000000F8  220C      MOV         R2,#0xC
 000000FA  4350      MUL         R0,R2
 000000FC  1809      ADD         R1,R0
 000000FE  4800      LDR         R0,=Leds + 0x4 ; Leds+4
 00000100  1840      ADD         R0,R1 ; Leds+4
 00000102  6801      LDR         R1,[R0,#0x0]
 00000104  4319      ORR         R1,R3 ; tmp
 00000106  6001      STR         R1,[R0,#0x0]
 00000108  E00F      B           L_13  ; T=0x0000012A
 0000010A          L_12:
  114:         Leds[n][ic][ls].data &= ~tmp;
 0000010A  9801      LDR         R0,[R13,#0x4] ; ic
 0000010C  2130      MOV         R1,#0x30
 0000010E  4348      MUL         R0,R1
 00000110  9900      LDR         R1,[R13,#0x0] ; n
 00000112  2260      MOV         R2,#0x60
 00000114  4351      MUL         R1,R2
 00000116  1809      ADD         R1,R0
 00000118  9803      LDR         R0,[R13,#0xC] ; ls
 0000011A  220C      MOV         R2,#0xC
 0000011C  4350      MUL         R0,R2
 0000011E  1809      ADD         R1,R0
 00000120  4800      LDR         R0,=Leds + 0x4 ; Leds+4
 00000122  1840      ADD         R0,R1 ; Leds+4
 00000124  6801      LDR         R1,[R0,#0x0]
 00000126  4399      BIC         R1,R3 ; tmp
 00000128  6001      STR         R1,[R0,#0x0]
 0000012A          L_13:
  116:     switch(ls)
 0000012A  9803      LDR         R0,[R13,#0xC] ; ls
 0000012C  2801      CMP         R0,#0x1
 0000012E  D009      BEQ         L_16  ; T=0x00000144
 00000130  2802      CMP         R0,#0x2
 00000132  D00B      BEQ         L_17  ; T=0x0000014C
 00000134  2803      CMP         R0,#0x3
 00000136  D00D      BEQ         L_18  ; T=0x00000154
 00000138  2800      CMP         R0,#0x0
 0000013A  D10E      BNE         L_14  ; T=0x0000015A
  118:     case 0: buffer[0] = LS0; break;
 0000013C          L_15:
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 28  

 0000013C  9906      LDR         R1,[R13,#0x18] ; LS0
 0000013E  A804      ADD         R0,R13,#0x10
 00000140  7001      STRB        R1,[R0,#0x0] ; buffer
 00000142  E00A      B           L_14  ; T=0x0000015A
  119:     case 1: buffer[0] = LS1; break;
 00000144          L_16:
 00000144  9907      LDR         R1,[R13,#0x1C] ; LS1
 00000146  A804      ADD         R0,R13,#0x10
 00000148  7001      STRB        R1,[R0,#0x0] ; buffer
 0000014A  E006      B           L_14  ; T=0x0000015A
  120:     case 2: buffer[0] = LS2; break;
 0000014C          L_17:
 0000014C  9908      LDR         R1,[R13,#0x20] ; LS2
 0000014E  A804      ADD         R0,R13,#0x10
 00000150  7001      STRB        R1,[R0,#0x0] ; buffer
 00000152  E002      B           L_14  ; T=0x0000015A
  121:     case 3: buffer[0] = LS3; break;
 00000154          L_18:
 00000154  9909      LDR         R1,[R13,#0x24] ; LS3
 00000156  A804      ADD         R0,R13,#0x10
 00000158  7001      STRB        R1,[R0,#0x0] ; buffer
  122:     }
 0000015A          L_14:
  125:         buffer[1] = Leds[n][ic][ls].data & 0xFF;
 0000015A  9801      LDR         R0,[R13,#0x4] ; ic
 0000015C  2130      MOV         R1,#0x30
 0000015E  4348      MUL         R0,R1
 00000160  9900      LDR         R1,[R13,#0x0] ; n
 00000162  2260      MOV         R2,#0x60
 00000164  4351      MUL         R1,R2
 00000166  1809      ADD         R1,R0
 00000168  9803      LDR         R0,[R13,#0xC] ; ls
 0000016A  220C      MOV         R2,#0xC
 0000016C  4350      MUL         R0,R2
 0000016E  1809      ADD         R1,R0
 00000170  4800      LDR         R0,=Leds + 0x4 ; Leds+4
 00000172  5841      LDR         R1,[R0,R1]
 00000174  20FF      MOV         R0,#0xFF
 00000176  4001      AND         R1,R0
 00000178  2011      MOV         R0,#0x11
 0000017A  4468      ADD         R0,R13
 0000017C  7001      STRB        R1,[R0,#0x0] ; buffer+1
  131:     I2C_SendByte(0xC0, 2, buffer);
 0000017E  AA04      ADD         R2,R13,#0x10
 00000180  20C0      MOV         R0,#0xC0
 00000182  2102      MOV         R1,#0x2
 00000184  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 00000186  FF3C      BL          I2C_SendByte?T  ; T=0x0001  (2)
  133:     buffer[0] = 0xFF;
 00000188  21FF      MOV         R1,#0xFF
 0000018A  A804      ADD         R0,R13,#0x10
 0000018C  7001      STRB        R1,[R0,#0x0] ; buffer
  134:     I2C_SendByte(0x72,1,buffer);
 0000018E  AA04      ADD         R2,R13,#0x10
 00000190  2072      MOV         R0,#0x72
 00000192  2101      MOV         R1,#0x1
 00000194  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 00000196  FF34      BL          I2C_SendByte?T  ; T=0x0001  (2)
 00000198            ; SCOPE-END
  136: }
 00000198  B029      ADD         R13,#0xA4
 0000019A  BCF0      POP         {R4-R7}
 0000019C  BC08      POP         {R3}
 0000019E  4718      BX          R3
 000001A0          ENDP ; 'LedOnOff?T'


*** CODE SEGMENT '?PR?ClearArc?T?Human':
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 29  

  138: void ClearArc(void)
 00000000  B510      PUSH        {R4,LR}
  139: {
 00000002            ; SCOPE-START
  141:     for (index = 1; index <= 31; index++)
 00000002  2401      MOV         R4,#0x1
 00000004  ---- Variable 'index' assigned to Register 'R4' ----
 00000004          L_22:
  142:         LedOnOff(index, 0, OFF, false);
 00000004  1C20      MOV         R0,R4
 00000006  2100      MOV         R1,#0x0
 00000008  2200      MOV         R2,#0x0
 0000000A  2300      MOV         R3,#0x0
 0000000C  F7FF      BL          LedOnOff?T  ; T=0x0001  (1)
 0000000E  FFF8      BL          LedOnOff?T  ; T=0x0001  (2)
 00000010  3401      ADD         R4,#0x1
 00000012  2C1F      CMP         R4,#0x1F ; index
 00000014  DDF6      BLE         L_22  ; T=0x00000004
  143:     for (index = 101; index <=129; index++)
 00000016  2465      MOV         R4,#0x65
 00000018          L_27:
  144:         LedOnOff(index, 0, OFF, false);
 00000018  1C20      MOV         R0,R4
 0000001A  2100      MOV         R1,#0x0
 0000001C  2200      MOV         R2,#0x0
 0000001E  2300      MOV         R3,#0x0
 00000020  F7FF      BL          LedOnOff?T  ; T=0x0001  (1)
 00000022  FFEE      BL          LedOnOff?T  ; T=0x0001  (2)
 00000024  3401      ADD         R4,#0x1
 00000026  2C81      CMP         R4,#0x81 ; index
 00000028  DDF6      BLE         L_27  ; T=0x00000018
  145:     for (index = 1; index <= 31; index++)
 0000002A  2401      MOV         R4,#0x1
 0000002C          L_32:
  146:         LedOnOff(index, 0, OFF, true);
 0000002C  1C20      MOV         R0,R4
 0000002E  2100      MOV         R1,#0x0
 00000030  2200      MOV         R2,#0x0
 00000032  2301      MOV         R3,#0x1
 00000034  F7FF      BL          LedOnOff?T  ; T=0x0001  (1)
 00000036  FFE4      BL          LedOnOff?T  ; T=0x0001  (2)
 00000038  3401      ADD         R4,#0x1
 0000003A  2C1F      CMP         R4,#0x1F ; index
 0000003C  DDF6      BLE         L_32  ; T=0x0000002C
 0000003E            ; SCOPE-END
  147: }
 0000003E  BC10      POP         {R4}
 00000040  BC08      POP         {R3}
 00000042  4718      BX          R3
 00000044          ENDP ; 'ClearArc?T'


*** CODE SEGMENT '?PR?ClearSky?T?Human':
  149: void ClearSky(void)
 00000000  B530      PUSH        {R4-R5,LR}
  150: {
 00000002            ; SCOPE-START
  152:     SkyOnOff(0, 1, 0, OFF);
 00000002  2000      MOV         R0,#0x0
 00000004  2101      MOV         R1,#0x1
 00000006  2200      MOV         R2,#0x0
 00000008  2300      MOV         R3,#0x0
 0000000A  F7FF      BL          SkyOnOff?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          SkyOnOff?T  ; T=0x0001  (2)
  153:     SkyOnOff(0, 2, 0, OFF);
 0000000E  2000      MOV         R0,#0x0
 00000010  2102      MOV         R1,#0x2
 00000012  2200      MOV         R2,#0x0
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 30  

 00000014  2300      MOV         R3,#0x0
 00000016  F7FF      BL          SkyOnOff?T  ; T=0x0001  (1)
 00000018  FFF3      BL          SkyOnOff?T  ; T=0x0001  (2)
  154:     for (spaak = 1; spaak <= 12; spaak++)
 0000001A  2401      MOV         R4,#0x1
 0000001C  ---- Variable 'spaak' assigned to Register 'R4' ----
  156:         for (led = 0; led <= 7; led++)
 0000001C          L_43:
 0000001C  2500      MOV         R5,#0x0
 0000001E  ---- Variable 'led' assigned to Register 'R5' ----
 0000001E          L_42:
  158:             SkyOnOff(spaak, led, 0, OFF);
 0000001E  1C20      MOV         R0,R4
 00000020  1C29      MOV         R1,R5
 00000022  2200      MOV         R2,#0x0
 00000024  2300      MOV         R3,#0x0
 00000026  F7FF      BL          SkyOnOff?T  ; T=0x0001  (1)
 00000028  FFEB      BL          SkyOnOff?T  ; T=0x0001  (2)
  159:         }
 0000002A  3501      ADD         R5,#0x1
 0000002C  2D07      CMP         R5,#0x7 ; led
 0000002E  DDF6      BLE         L_42  ; T=0x0000001E
  160:     }
 00000030  3401      ADD         R4,#0x1
 00000032  2C0C      CMP         R4,#0xC ; spaak
 00000034  DDF2      BLE         L_43  ; T=0x0000001C
 00000036            ; SCOPE-END
  161: }
 00000036  BC30      POP         {R4-R5}
 00000038  BC08      POP         {R3}
 0000003A  4718      BX          R3
 0000003C          ENDP ; 'ClearSky?T'


*** CODE SEGMENT '?PR?SkyOnOff?T?Human':
  163: void SkyOnOff(int spaak, int led, int level, int OnOff)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C1E      MOV         R6,R3 ; OnOff
 00000004  ---- Variable 'OnOff' assigned to Register 'R6' ----
 00000004  1C17      MOV         R7,R2 ; level
 00000006  ---- Variable 'level' assigned to Register 'R7' ----
 00000006  1C0D      MOV         R5,R1 ; led
 00000008  ---- Variable 'led' assigned to Register 'R5' ----
 00000008  1C04      MOV         R4,R0 ; spaak
 0000000A  ---- Variable 'spaak' assigned to Register 'R4' ----
 0000000A  B085      SUB         R13,#0x14
  164: {
 0000000C            ; SCOPE-START
  167:     int PWM1 = 0x14;    // (autoincrement (16) + register
 0000000C  2014      MOV         R0,#0x14
 0000000E  9002      STR         R0,[R13,#0x8] ; PWM1
  168:     int LS0  = 0x06;    
 00000010  2006      MOV         R0,#0x6
 00000012  9003      STR         R0,[R13,#0xC] ; LS0
  169:     int LS1  = 0x07;    
 00000014  2007      MOV         R0,#0x7
 00000016  9004      STR         R0,[R13,#0x10] ; LS1
  171:     if (spaak == 0)
 00000018  2C00      CMP         R4,#0x0 ; spaak
 0000001A  D103      BNE         L_44  ; T=0x00000024
  173:         buffer[0] = 0xEF;
 0000001C  21EF      MOV         R1,#0xEF
 0000001E  A801      ADD         R0,R13,#0x4
 00000020  7001      STRB        R1,[R0,#0x0] ; buffer
  174:     }
 00000022  E010      B           L_45  ; T=0x00000046
 00000024          L_44:
  177:         if (spaak < 9)
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 31  

 00000024  2C09      CMP         R4,#0x9 ; spaak
 00000026  DA07      BGE         L_46  ; T=0x00000038
  178:             buffer[0] = ~(1 << (spaak-1));
 00000028  1C20      MOV         R0,R4 ; spaak
 0000002A  3801      SUB         R0,#0x1
 0000002C  2101      MOV         R1,#0x1
 0000002E  4081      LSL         R1,R0
 00000030  43C9      MVN         R1,R1
 00000032  A801      ADD         R0,R13,#0x4
 00000034  7001      STRB        R1,[R0,#0x0] ; buffer
 00000036  E006      B           L_45  ; T=0x00000046
 00000038          L_46:
  180:             buffer[0] = ~(1 << (spaak-9));
 00000038  1C20      MOV         R0,R4 ; spaak
 0000003A  3809      SUB         R0,#0x9
 0000003C  2101      MOV         R1,#0x1
 0000003E  4081      LSL         R1,R0
 00000040  43C9      MVN         R1,R1
 00000042  A801      ADD         R0,R13,#0x4
 00000044  7001      STRB        R1,[R0,#0x0] ; buffer
  181:     }
 00000046          L_45:
  182:      I2C_SendByte(Sky[spaak].address, 1, buffer);  // laad pre-selectie met spaak-IC
 00000046  210C      MOV         R1,#0xC
 00000048  4361      MUL         R1,R4 ; spaak
 0000004A  4800      LDR         R0,=Sky ; Sky
 0000004C  5840      LDR         R0,[R0,R1]
 0000004E  AA01      ADD         R2,R13,#0x4
 00000050  2101      MOV         R1,#0x1
 00000052  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 00000054  FFD5      BL          I2C_SendByte?T  ; T=0x0001  (2)
  184:     buffer[0] = PWM1;   // subaddress
 00000056  9902      LDR         R1,[R13,#0x8] ; PWM1
 00000058  A801      ADD         R0,R13,#0x4
 0000005A  7001      STRB        R1,[R0,#0x0] ; buffer
  185:     buffer[1] = 0;      // PSC1
 0000005C  2100      MOV         R1,#0x0
 0000005E  2005      MOV         R0,#0x5
 00000060  4468      ADD         R0,R13
 00000062  7001      STRB        R1,[R0,#0x0] ; buffer+1
  186:     buffer[2] = level & 0xFF;
 00000064  21FF      MOV         R1,#0xFF
 00000066  4039      AND         R1,R7 ; level
 00000068  2006      MOV         R0,#0x6
 0000006A  4468      ADD         R0,R13
 0000006C  7001      STRB        R1,[R0,#0x0] ; buffer+2
  187:     I2C_SendByte(0xC0, 3, buffer);
 0000006E  AA01      ADD         R2,R13,#0x4
 00000070  20C0      MOV         R0,#0xC0
 00000072  2103      MOV         R1,#0x3
 00000074  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 00000076  FFC4      BL          I2C_SendByte?T  ; T=0x0001  (2)
  189:     if (spaak == 0)
 00000078  2C00      CMP         R4,#0x0 ; spaak
 0000007A  D123      BNE         L_48  ; T=0x000000C4
  191:         buffer[0] = LS0;
 0000007C  9903      LDR         R1,[R13,#0xC] ; LS0
 0000007E  A801      ADD         R0,R13,#0x4
 00000080  7001      STRB        R1,[R0,#0x0] ; buffer
  192:         tmp = (0x03 << (2*(led-1)));
 00000082  1C29      MOV         R1,R5 ; led
 00000084  3901      SUB         R1,#0x1
 00000086  0049      LSL         R1,R1,#0x1 ; led
 00000088  2003      MOV         R0,#0x3
 0000008A  4088      LSL         R0,R1
 0000008C  9000      STR         R0,[R13,#0x0] ; tmp
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 32  

  193:         if (OnOff == ON)
 0000008E  2E01      CMP         R6,#0x1 ; OnOff
 00000090  D108      BNE         L_49  ; T=0x000000A4
  194:             Sky[spaak].data |= tmp;
 00000092  9A00      LDR         R2,[R13,#0x0] ; tmp
 00000094  210C      MOV         R1,#0xC
 00000096  4361      MUL         R1,R4 ; spaak
 00000098  4800      LDR         R0,=Sky + 0x4 ; Sky+4
 0000009A  1840      ADD         R0,R1 ; Sky+4
 0000009C  6801      LDR         R1,[R0,#0x0]
 0000009E  4311      ORR         R1,R2
 000000A0  6001      STR         R1,[R0,#0x0]
 000000A2  E007      B           L_50  ; T=0x000000B4
 000000A4          L_49:
  196:             Sky[spaak].data &= ~tmp;
 000000A4  9A00      LDR         R2,[R13,#0x0] ; tmp
 000000A6  210C      MOV         R1,#0xC
 000000A8  4361      MUL         R1,R4 ; spaak
 000000AA  4800      LDR         R0,=Sky + 0x4 ; Sky+4
 000000AC  1840      ADD         R0,R1 ; Sky+4
 000000AE  6801      LDR         R1,[R0,#0x0]
 000000B0  4391      BIC         R1,R2
 000000B2  6001      STR         R1,[R0,#0x0]
 000000B4          L_50:
  197:         buffer[1] = Sky[spaak].data;
 000000B4  210C      MOV         R1,#0xC
 000000B6  4361      MUL         R1,R4 ; spaak
 000000B8  4800      LDR         R0,=Sky + 0x4 ; Sky+4
 000000BA  5841      LDR         R1,[R0,R1]
 000000BC  2005      MOV         R0,#0x5
 000000BE  4468      ADD         R0,R13
 000000C0  7001      STRB        R1,[R0,#0x0] ; buffer+1
  198:     }
 000000C2  E034      B           L_51  ; T=0x0000012E
 000000C4          L_48:
  201:         tmp = (0x03 << (2*(led-1)));
 000000C4  1C29      MOV         R1,R5 ; led
 000000C6  3901      SUB         R1,#0x1
 000000C8  0049      LSL         R1,R1,#0x1 ; led
 000000CA  2003      MOV         R0,#0x3
 000000CC  4088      LSL         R0,R1
 000000CE  9000      STR         R0,[R13,#0x0] ; tmp
  202:         if (OnOff == ON)
 000000D0  2E01      CMP         R6,#0x1 ; OnOff
 000000D2  D108      BNE         L_52  ; T=0x000000E6
  203:             Sky[spaak].data |= tmp;
 000000D4  9A00      LDR         R2,[R13,#0x0] ; tmp
 000000D6  210C      MOV         R1,#0xC
 000000D8  4361      MUL         R1,R4 ; spaak
 000000DA  4800      LDR         R0,=Sky + 0x4 ; Sky+4
 000000DC  1840      ADD         R0,R1 ; Sky+4
 000000DE  6801      LDR         R1,[R0,#0x0]
 000000E0  4311      ORR         R1,R2
 000000E2  6001      STR         R1,[R0,#0x0]
 000000E4  E007      B           L_53  ; T=0x000000F6
 000000E6          L_52:
  205:             Sky[spaak].data &= ~tmp;
 000000E6  9A00      LDR         R2,[R13,#0x0] ; tmp
 000000E8  210C      MOV         R1,#0xC
 000000EA  4361      MUL         R1,R4 ; spaak
 000000EC  4800      LDR         R0,=Sky + 0x4 ; Sky+4
 000000EE  1840      ADD         R0,R1 ; Sky+4
 000000F0  6801      LDR         R1,[R0,#0x0]
 000000F2  4391      BIC         R1,R2
 000000F4  6001      STR         R1,[R0,#0x0]
 000000F6          L_53:
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 33  

  206:         if (led < 5)
 000000F6  2D05      CMP         R5,#0x5 ; led
 000000F8  DA0C      BGE         L_54  ; T=0x00000114
  208:             buffer[0] = LS0;
 000000FA  9903      LDR         R1,[R13,#0xC] ; LS0
 000000FC  A801      ADD         R0,R13,#0x4
 000000FE  7001      STRB        R1,[R0,#0x0] ; buffer
  209:             buffer[1] = (Sky[spaak].data & 0xFF);
 00000100  210C      MOV         R1,#0xC
 00000102  4361      MUL         R1,R4 ; spaak
 00000104  4800      LDR         R0,=Sky + 0x4 ; Sky+4
 00000106  5841      LDR         R1,[R0,R1]
 00000108  20FF      MOV         R0,#0xFF
 0000010A  4001      AND         R1,R0
 0000010C  2005      MOV         R0,#0x5
 0000010E  4468      ADD         R0,R13
 00000110  7001      STRB        R1,[R0,#0x0] ; buffer+1
  210:         }
 00000112  E00C      B           L_51  ; T=0x0000012E
 00000114          L_54:
  213:             buffer[0] = LS1;
 00000114  9904      LDR         R1,[R13,#0x10] ; LS1
 00000116  A801      ADD         R0,R13,#0x4
 00000118  7001      STRB        R1,[R0,#0x0] ; buffer
  214:             buffer[1] = ((Sky[spaak].data >> 8) & 0xFF);
 0000011A  210C      MOV         R1,#0xC
 0000011C  4361      MUL         R1,R4 ; spaak
 0000011E  4800      LDR         R0,=Sky + 0x4 ; Sky+4
 00000120  5841      LDR         R1,[R0,R1]
 00000122  1209      ASR         R1,R1,#0x8
 00000124  20FF      MOV         R0,#0xFF
 00000126  4001      AND         R1,R0
 00000128  2005      MOV         R0,#0x5
 0000012A  4468      ADD         R0,R13
 0000012C  7001      STRB        R1,[R0,#0x0] ; buffer+1
  216:     }
 0000012E          L_51:
  217:     I2C_SendByte(0xC0, 2, buffer);
 0000012E  AA01      ADD         R2,R13,#0x4
 00000130  20C0      MOV         R0,#0xC0
 00000132  2102      MOV         R1,#0x2
 00000134  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 00000136  FF64      BL          I2C_SendByte?T  ; T=0x0001  (2)
  218:     buffer[0] = 0xFF;
 00000138  21FF      MOV         R1,#0xFF
 0000013A  A801      ADD         R0,R13,#0x4
 0000013C  7001      STRB        R1,[R0,#0x0] ; buffer
  219:     I2C_SendByte(Sky[spaak].address, 1, buffer);
 0000013E  210C      MOV         R1,#0xC
 00000140  4361      MUL         R1,R4 ; spaak
 00000142  4800      LDR         R0,=Sky ; Sky
 00000144  5840      LDR         R0,[R0,R1]
 00000146  AA01      ADD         R2,R13,#0x4
 00000148  2101      MOV         R1,#0x1
 0000014A  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 0000014C  FF59      BL          I2C_SendByte?T  ; T=0x0001  (2)
 0000014E            ; SCOPE-END
  220: }
 0000014E  B005      ADD         R13,#0x14
 00000150  BCF0      POP         {R4-R7}
 00000152  BC08      POP         {R3}
 00000154  4718      BX          R3
 00000156          ENDP ; 'SkyOnOff?T'


*** CODE SEGMENT '?PR?main?Human':
  222: int main (void)
 00000000  B500      PUSH        {LR}
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 34  

 00000002  B085      SUB         R13,#0x14
 00000004  ---- Variable 'i' assigned to Register 'R5' ----
  223: {
 00000004            ; SCOPE-START
  231:     num      = 0;
 00000004  2000      MOV         R0,#0x0
 00000006  9000      STR         R0,[R13,#0x0] ; num
  232:     EOL      = 0;
 00000008  2700      MOV         R7,#0x0
 0000000A  ---- Variable 'EOL' assigned to Register 'R7' ----
  233:     abort    = 0;
 0000000A  2000      MOV         R0,#0x0
 0000000C  9001      STR         R0,[R13,#0x4] ; abort
  234:     if (InitAll()  != 0)
 0000000E  F7FF      BL          InitAll?T  ; T=0x0001  (1)
 00000010  FFF7      BL          InitAll?T  ; T=0x0001  (2)
 00000012  2800      CMP         R0,#0x0 ; InitAll?T
 00000014  D002      BEQ         L_56  ; T=0x0000001C
  235:         return -1;
 00000016  4800      LDR         R4,=0xFFFFFFFF
 00000018  1C20      MOV         R0,R4
 0000001A  E430      B           L_57  ; T=0xFFFFF87E
 0000001C          L_56:
  237:     nStatus = statInit;
 0000001C  2100      MOV         R1,#0x0
 0000001E  4800      LDR         R0,=nStatus ; nStatus
 00000020  6001      STR         R1,[R0,#0x0] ; nStatus
  238:     Clock_Reset();
 00000022  F7FF      BL          Clock_Reset?T  ; T=0x0001  (1)
 00000024  FFED      BL          Clock_Reset?T  ; T=0x0001  (2)
  239:     curTime = 0;
 00000026  2100      MOV         R1,#0x0
 00000028  4800      LDR         R0,=curTime ; curTime
 0000002A  6001      STR         R1,[R0,#0x0] ; curTime
  241:     done = 0;
 0000002C  2600      MOV         R6,#0x0
 0000002E  ---- Variable 'done' assigned to Register 'R6' ----
  242:     for (;;)
 0000002E          L_61:
  244:         if (UART0_RxNumber() > 0)
 0000002E  F7FF      BL          UART0_RxNumber?T  ; T=0x0001  (1)
 00000030  FFE7      BL          UART0_RxNumber?T  ; T=0x0001  (2)
 00000032  0400      LSL         R0,R0,#0x10 ; UART0_RxNumber?T
 00000034  0C00      LSR         R0,R0,#0x10
 00000036  2800      CMP         R0,#0x0
 00000038  D919      BLS         L_63  ; T=0x0000006E
  246:             inChar = UART0_Get();
 0000003A  F7FF      BL          UART0_Get?T  ; T=0x0001  (1)
 0000003C  FFE1      BL          UART0_Get?T  ; T=0x0001  (2)
 0000003E  9002      STR         R0,[R13,#0x8] ; inChar
  247:             if (inChar == ESCAPE) abort = 1;
 00000040  9802      LDR         R0,[R13,#0x8] ; inChar
 00000042  281B      CMP         R0,#0x1B
 00000044  D101      BNE         L_64  ; T=0x0000004A
 00000046  2101      MOV         R1,#0x1
 00000048  9101      STR         R1,[R13,#0x4] ; abort
 0000004A          L_64:
  248:              if (inChar == ENTER)  
 0000004A  280D      CMP         R0,#0xD
 0000004C  D106      BNE         L_65  ; T=0x0000005C
  250:                 EOL   = 1;          // new command
 0000004E  2701      MOV         R7,#0x1
  251:                 inBuf[num] = 0;
 00000050  2000      MOV         R0,#0x0
 00000052  9A00      LDR         R2,[R13,#0x0] ; num
 00000054  4800      LDR         R1,=inBuf ; inBuf
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 35  

 00000056  5488      STRB        R0,[R1,R2]
  252:                 splitInput();
 00000058  F7FF      BL          splitInput?T  ; T=0x0001  (1)
 0000005A  FFD2      BL          splitInput?T  ; T=0x0001  (2)
  253:             }
 0000005C          L_65:
  254:             if (EOL == 0) inBuf[num++] = (char) inChar;
 0000005C  2F00      CMP         R7,#0x0 ; EOL
 0000005E  D106      BNE         L_63  ; T=0x0000006E
 00000060  9802      LDR         R0,[R13,#0x8] ; inChar
 00000062  9A00      LDR         R2,[R13,#0x0] ; num
 00000064  1C11      MOV         R1,R2
 00000066  3101      ADD         R1,#0x1
 00000068  9100      STR         R1,[R13,#0x0] ; num
 0000006A  4800      LDR         R1,=inBuf ; inBuf
 0000006C  5488      STRB        R0,[R1,R2]
  255:         }
 0000006E          L_63:
  256:         curTime = Clock_GetTicks();
 0000006E  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000070  FFC7      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000072  4800      LDR         R1,=curTime ; curTime
 00000074  6008      STR         R0,[R1,#0x0] ; curTime
  258:         if (abort == 1)
 00000076  9801      LDR         R0,[R13,#0x4] ; abort
 00000078  2801      CMP         R0,#0x1
 0000007A  D10E      BNE         L_67  ; T=0x0000009A
  261:             InitAll();
 0000007C  F7FF      BL          InitAll?T  ; T=0x0001  (1)
 0000007E  FFC0      BL          InitAll?T  ; T=0x0001  (2)
  262:             nStatus = statInit;
 00000080  2100      MOV         R1,#0x0
 00000082  4800      LDR         R0,=nStatus ; nStatus
 00000084  6001      STR         R1,[R0,#0x0] ; nStatus
  263:             Clock_Reset();
 00000086  F7FF      BL          Clock_Reset?T  ; T=0x0001  (1)
 00000088  FFBB      BL          Clock_Reset?T  ; T=0x0001  (2)
  264:             curTime = 0;
 0000008A  2100      MOV         R1,#0x0
 0000008C  4800      LDR         R0,=curTime ; curTime
 0000008E  6001      STR         R1,[R0,#0x0] ; curTime
  265:             EOL = 0;
 00000090  2700      MOV         R7,#0x0
  266:             num = 0;
 00000092  2000      MOV         R0,#0x0
 00000094  9000      STR         R0,[R13,#0x0] ; num
  267:             abort = 0;
 00000096  2000      MOV         R0,#0x0
 00000098  9001      STR         R0,[R13,#0x4] ; abort
  268:         }
 0000009A          L_67:
  269:         if ((EOL == 1) && (nBuffer[1] == cmdTime)) GetTime();
 0000009A  2F01      CMP         R7,#0x1 ; EOL
 0000009C  D105      BNE         L_68  ; T=0x000000AA
 0000009E  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 000000A0  6800      LDR         R0,[R0,#0x0] ; nBuffer+4
 000000A2  2825      CMP         R0,#0x25
 000000A4  D101      BNE         L_68  ; T=0x000000AA
 000000A6  F7FF      BL          GetTime?T  ; T=0x0001  (1)
 000000A8  FFAB      BL          GetTime?T  ; T=0x0001  (2)
 000000AA          L_68:
  270:         if (nStatus == statInit)
 000000AA  4800      LDR         R0,=nStatus ; nStatus
 000000AC  6800      LDR         R0,[R0,#0x0] ; nStatus
 000000AE  2800      CMP         R0,#0x0
 000000B0  D140      BNE         L_69  ; T=0x00000134
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 36  

  272:             if (EOL == 1)
 000000B2  2F01      CMP         R7,#0x1 ; EOL
 000000B4  D13E      BNE         L_69  ; T=0x00000134
  274:                 if (nBuffer[1] == cmdSpeakersOff) SpeakersOff();
 000000B6  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 000000B8  6800      LDR         R0,[R0,#0x0] ; nBuffer+4
 000000BA  280E      CMP         R0,#0xE
 000000BC  D101      BNE         L_71  ; T=0x000000C2
 000000BE  F7FF      BL          SpeakersOff?T  ; T=0x0001  (1)
 000000C0  FF9F      BL          SpeakersOff?T  ; T=0x0001  (2)
 000000C2          L_71:
  275:                 if (nBuffer[1] == cmdInfo)   ReturnInfo();      
 000000C2  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 000000C4  6800      LDR         R0,[R0,#0x0] ; nBuffer+4
 000000C6  2808      CMP         R0,#0x8
 000000C8  D101      BNE         L_72  ; T=0x000000CE
 000000CA  F7FF      BL          ReturnInfo?T  ; T=0x0001  (1)
 000000CC  FF99      BL          ReturnInfo?T  ; T=0x0001  (2)
 000000CE          L_72:
  276:                 if (nBuffer[1] == cmdGetPIO) GetPIO();
 000000CE  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 000000D0  6800      LDR         R0,[R0,#0x0] ; nBuffer+4
 000000D2  280A      CMP         R0,#0xA
 000000D4  D101      BNE         L_73  ; T=0x000000DA
 000000D6  F7FF      BL          GetPIO?T  ; T=0x0001  (1)
 000000D8  FF93      BL          GetPIO?T  ; T=0x0001  (2)
 000000DA          L_73:
  278:                 if (nBuffer[1] == cmdNewTrial) 
 000000DA  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 000000DC  6800      LDR         R0,[R0,#0x0] ; nBuffer+4
 000000DE  2809      CMP         R0,#0x9
 000000E0  D125      BNE         L_74  ; T=0x0000012E
  280:                     startTime = nBuffer[2];     // ITI
 000000E2  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 000000E4  6801      LDR         R1,[R0,#0x0] ; nBuffer+8
 000000E6  4800      LDR         R0,=startTime ; startTime
 000000E8  6001      STR         R1,[R0,#0x0] ; startTime
  281:                     Clock_Reset();
 000000EA  F7FF      BL          Clock_Reset?T  ; T=0x0001  (1)
 000000EC  FF89      BL          Clock_Reset?T  ; T=0x0001  (2)
  282:                     curTime = 0;
 000000EE  2100      MOV         R1,#0x0
 000000F0  4800      LDR         R0,=curTime ; curTime
 000000F2  6001      STR         R1,[R0,#0x0] ; curTime
  283:                     nStatus = statTrial;
 000000F4  2102      MOV         R1,#0x2
 000000F6  4800      LDR         R0,=nStatus ; nStatus
 000000F8  6001      STR         R1,[R0,#0x0] ; nStatus
  284:                     nStim = 0;
 000000FA  2100      MOV         R1,#0x0
 000000FC  4800      LDR         R0,=nStim ; nStim
 000000FE  6001      STR         R1,[R0,#0x0] ; nStim
  285:                     newStim = nBuffer[3];       // komt van PC
 00000100  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 00000102  6801      LDR         R1,[R0,#0x0] ; nBuffer+12
 00000104  4800      LDR         R0,=newStim ; newStim
 00000106  6001      STR         R1,[R0,#0x0] ; newStim
  286:                     i = startTime;
 00000108  4800      LDR         R0,=startTime ; startTime
 0000010A  6805      LDR         R5,[R0,#0x0] ; startTime
  287:                     n = sprintf(outBuf,"%d\n",i); 
 0000010C  4800      LDR         R0,=outBuf ; outBuf
 0000010E  4800      LDR         R1,=??S_2 ; ??S_2
 00000110  1C2A      MOV         R2,R5
 00000112  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000114  FF75      BL          sprintf?T  ; T=0x0001  (2)
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 37  

 00000116  9003      STR         R0,[R13,#0xC] ; n
  288:                     i = UART0_Str(outBuf, n);
 00000118  4800      LDR         R0,=outBuf ; outBuf
 0000011A  9903      LDR         R1,[R13,#0xC] ; n
 0000011C  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 0000011E  FF70      BL          UART0_Str?T  ; T=0x0001  (2)
 00000120  1C05      MOV         R5,R0 ; i
  289:                     tmpSnd1[0] = 0;
 00000122  2100      MOV         R1,#0x0
 00000124  4800      LDR         R0,=tmpSnd1 ; tmpSnd1
 00000126  6001      STR         R1,[R0,#0x0] ; tmpSnd1
  290:                     tmpSnd2[0] = 0;
 00000128  2100      MOV         R1,#0x0
 0000012A  4800      LDR         R0,=tmpSnd2 ; tmpSnd2
 0000012C  6001      STR         R1,[R0,#0x0] ; tmpSnd2
  291:                 }
 0000012E          L_74:
  292:                 EOL = 0;
 0000012E  2700      MOV         R7,#0x0
  293:                 num = 0;
 00000130  2000      MOV         R0,#0x0
 00000132  9000      STR         R0,[R13,#0x0] ; num
  295:         }
 00000134          L_69:
  297:          if (nStatus == statTrial)
 00000134  4800      LDR         R0,=nStatus ; nStatus
 00000136  6800      LDR         R0,[R0,#0x0] ; nStatus
 00000138  2802      CMP         R0,#0x2
 0000013A  D000      BNE         $+4
 0000013C  E2C6      B           L_75  ; T=0x000006CC
  299:             if (EOL == 1)
 00000140  2F01      CMP         R7,#0x1 ; EOL
 00000142  D000      BNE         $+4
 00000144  E2C2      B           L_75  ; T=0x000006CC
  301:                 switch (nBuffer[1])
 00000148  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 0000014A  6800      LDR         R0,[R0,#0x0] ; nBuffer+4
 0000014C  2865      CMP         R0,#0x65
 0000014E  D100      BEQ         $+4
 00000150  E11A      B           L_79  ; T=0x00000388
 00000154  2866      CMP         R0,#0x66
 00000156  D100      BEQ         $+4
 00000158  E168      B           L_80  ; T=0x0000042C
 0000015C  2867      CMP         R0,#0x67
 0000015E  D100      BEQ         $+4
 00000160  E230      B           L_81  ; T=0x000005C4
 00000164  2868      CMP         R0,#0x68
 00000166  D100      BEQ         $+4
 00000168  E239      B           L_82  ; T=0x000005DE
 0000016C  2869      CMP         R0,#0x69
 0000016E  D100      BEQ         $+4
 00000170  E0ED      B           L_83  ; T=0x0000034E
 00000174  286A      CMP         R0,#0x6A
 00000176  D100      BEQ         $+4
 00000178  E1AA      B           L_84  ; T=0x000004D0
 0000017C  286C      CMP         R0,#0x6C
 0000017E  D100      BEQ         $+4
 00000180  E1DB      B           L_85  ; T=0x0000053A
 00000184  286D      CMP         R0,#0x6D
 00000186  D044      BEQ         L_86  ; T=0x00000212
 00000188  286E      CMP         R0,#0x6E
 0000018A  D100      BEQ         $+4
 0000018C  E092      B           L_87  ; T=0x000002B4
 00000190  286F      CMP         R0,#0x6F
 00000192  D100      BEQ         $+4
 00000194  E230      B           L_88  ; T=0x000005F8
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 38  

 00000198  2864      CMP         R0,#0x64
 0000019A  D000      BNE         $+4
 0000019C  E260      B           L_77  ; T=0x00000660
  303:                 case stimLed:   stim[nStim].status    = statInit;
 000001A0          L_78:
 000001A0  2000      MOV         R0,#0x0
 000001A2  4800      LDR         R1,=nStim ; nStim
 000001A4  680A      LDR         R2,[R1,#0x0] ; nStim
 000001A6  233C      MOV         R3,#0x3C
 000001A8  4353      MUL         R3,R2
 000001AA  4800      LDR         R1,=stim + 0x4 ; stim+4
 000001AC  50C8      STR         R0,[R1,R3]
  304:                             stim[nStim].kind      = stimLed;
 000001AE  2064      MOV         R0,#0x64
 000001B0  213C      MOV         R1,#0x3C
 000001B2  434A      MUL         R2,R1
 000001B4  4800      LDR         R1,=stim + 0x8 ; stim+8
 000001B6  5088      STR         R0,[R1,R2]
  305:                             stim[nStim].posX      = nBuffer[2];
 000001B8  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 000001BA  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 000001BC  4800      LDR         R1,=nStim ; nStim
 000001BE  680A      LDR         R2,[R1,#0x0] ; nStim
 000001C0  213C      MOV         R1,#0x3C
 000001C2  434A      MUL         R2,R1
 000001C4  4800      LDR         R1,=stim + 0x18 ; stim+24
 000001C6  5088      STR         R0,[R1,R2]
  306:                             stim[nStim].posY      = nBuffer[3];     
 000001C8  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 000001CA  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 000001CC  4800      LDR         R1,=nStim ; nStim
 000001CE  680A      LDR         R2,[R1,#0x0] ; nStim
 000001D0  213C      MOV         R1,#0x3C
 000001D2  434A      MUL         R2,R1
 000001D4  4800      LDR         R1,=stim + 0x1C ; stim+28
 000001D6  5088      STR         R0,[R1,R2]
  307:                             stim[nStim].level     = nBuffer[4];     
 000001D8  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 000001DA  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 000001DC  4800      LDR         R1,=nStim ; nStim
 000001DE  680A      LDR         R2,[R1,#0x0] ; nStim
 000001E0  213C      MOV         R1,#0x3C
 000001E2  434A      MUL         R2,R1
 000001E4  4800      LDR         R1,=stim + 0x20 ; stim+32
 000001E6  5088      STR         R0,[R1,R2]
  308:                             stim[nStim].startRef  = nBuffer[5];
 000001E8  4800      LDR         R0,=nBuffer + 0x14 ; nBuffer+20
 000001EA  6800      LDR         R0,[R0,#0x0] ; nBuffer+20
 000001EC  4800      LDR         R1,=nStim ; nStim
 000001EE  680A      LDR         R2,[R1,#0x0] ; nStim
 000001F0  213C      MOV         R1,#0x3C
 000001F2  434A      MUL         R2,R1
 000001F4  4800      LDR         R1,=stim + 0x24 ; stim+36
 000001F6  5088      STR         R0,[R1,R2]
  309:                             stim[nStim].startTime = nBuffer[6]; 
 000001F8  4800      LDR         R0,=nBuffer + 0x18 ; nBuffer+24
 000001FA  6800      LDR         R0,[R0,#0x0] ; nBuffer+24
 000001FC  4800      LDR         R1,=nStim ; nStim
 000001FE  680A      LDR         R2,[R1,#0x0] ; nStim
 00000200  213C      MOV         R1,#0x3C
 00000202  434A      MUL         R2,R1
 00000204  4800      LDR         R1,=stim + 0x28 ; stim+40
 00000206  5088      STR         R0,[R1,R2]
  310:                             stim[nStim].stopRef   = nBuffer[7]; 
 00000208  4800      LDR         R0,=nBuffer + 0x1C ; nBuffer+28
 0000020A  6800      LDR         R0,[R0,#0x0] ; nBuffer+28
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 39  

 0000020C  4800      LDR         R1,=nStim ; nStim
 0000020E  680A      LDR         R2,[R1,#0x0] ; nStim
 00000210  213C      MOV         R1,#0x3C
 00000212  434A      MUL         R2,R1
 00000214  4800      LDR         R1,=stim + 0x2C ; stim+44
 00000216  5088      STR         R0,[R1,R2]
  311:                             stim[nStim].stopTime  = nBuffer[8]; 
 00000218  4800      LDR         R0,=nBuffer + 0x20 ; nBuffer+32
 0000021A  6800      LDR         R0,[R0,#0x0] ; nBuffer+32
 0000021C  4800      LDR         R1,=nStim ; nStim
 0000021E  680A      LDR         R2,[R1,#0x0] ; nStim
 00000220  213C      MOV         R1,#0x3C
 00000222  434A      MUL         R2,R1
 00000224  4800      LDR         R1,=stim + 0x30 ; stim+48
 00000226  5088      STR         R0,[R1,R2]
  312:                             break;
 00000228  E21A      B           L_77  ; T=0x00000660
  313:                 case stimLeds:  stim[nStim].status    = statInit;
 0000022A          L_86:
 0000022A  2000      MOV         R0,#0x0
 0000022C  4800      LDR         R1,=nStim ; nStim
 0000022E  680A      LDR         R2,[R1,#0x0] ; nStim
 00000230  233C      MOV         R3,#0x3C
 00000232  4353      MUL         R3,R2
 00000234  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000236  50C8      STR         R0,[R1,R3]
  314:                             stim[nStim].kind      = stimLeds;
 00000238  206D      MOV         R0,#0x6D
 0000023A  213C      MOV         R1,#0x3C
 0000023C  434A      MUL         R2,R1
 0000023E  4800      LDR         R1,=stim + 0x8 ; stim+8
 00000240  5088      STR         R0,[R1,R2]
  315:                             stim[nStim].posX      = nBuffer[2];
 00000242  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 00000244  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 00000246  4800      LDR         R1,=nStim ; nStim
 00000248  680A      LDR         R2,[R1,#0x0] ; nStim
 0000024A  213C      MOV         R1,#0x3C
 0000024C  434A      MUL         R2,R1
 0000024E  4800      LDR         R1,=stim + 0x18 ; stim+24
 00000250  5088      STR         R0,[R1,R2]
  316:                             stim[nStim].posY      = nBuffer[3];     
 00000252  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 00000254  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 00000256  4800      LDR         R1,=nStim ; nStim
 00000258  680A      LDR         R2,[R1,#0x0] ; nStim
 0000025A  213C      MOV         R1,#0x3C
 0000025C  434A      MUL         R2,R1
 0000025E  4800      LDR         R1,=stim + 0x1C ; stim+28
 00000260  5088      STR         R0,[R1,R2]
  317:                             stim[nStim].level     = nBuffer[4];     
 00000262  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 00000264  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 00000266  4800      LDR         R1,=nStim ; nStim
 00000268  680A      LDR         R2,[R1,#0x0] ; nStim
 0000026A  213C      MOV         R1,#0x3C
 0000026C  434A      MUL         R2,R1
 0000026E  4800      LDR         R1,=stim + 0x20 ; stim+32
 00000270  5088      STR         R0,[R1,R2]
  318:                             stim[nStim].startRef  = nBuffer[5];
 00000272  4800      LDR         R0,=nBuffer + 0x14 ; nBuffer+20
 00000274  6800      LDR         R0,[R0,#0x0] ; nBuffer+20
 00000276  4800      LDR         R1,=nStim ; nStim
 00000278  680A      LDR         R2,[R1,#0x0] ; nStim
 0000027A  213C      MOV         R1,#0x3C
 0000027C  434A      MUL         R2,R1
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 40  

 0000027E  4800      LDR         R1,=stim + 0x24 ; stim+36
 00000280  5088      STR         R0,[R1,R2]
  319:                             stim[nStim].startTime = nBuffer[6]; 
 00000282  4800      LDR         R0,=nBuffer + 0x18 ; nBuffer+24
 00000284  6800      LDR         R0,[R0,#0x0] ; nBuffer+24
 00000286  4800      LDR         R1,=nStim ; nStim
 00000288  680A      LDR         R2,[R1,#0x0] ; nStim
 0000028A  213C      MOV         R1,#0x3C
 0000028C  434A      MUL         R2,R1
 0000028E  4800      LDR         R1,=stim + 0x28 ; stim+40
 00000290  5088      STR         R0,[R1,R2]
  320:                             stim[nStim].stopRef   = nBuffer[7]; 
 00000292  4800      LDR         R0,=nBuffer + 0x1C ; nBuffer+28
 00000294  6800      LDR         R0,[R0,#0x0] ; nBuffer+28
 00000296  4800      LDR         R1,=nStim ; nStim
 00000298  680A      LDR         R2,[R1,#0x0] ; nStim
 0000029A  213C      MOV         R1,#0x3C
 0000029C  434A      MUL         R2,R1
 0000029E  4800      LDR         R1,=stim + 0x2C ; stim+44
 000002A0  5088      STR         R0,[R1,R2]
  321:                             stim[nStim].stopTime  = nBuffer[8]; 
 000002A2  4800      LDR         R0,=nBuffer + 0x20 ; nBuffer+32
 000002A4  6800      LDR         R0,[R0,#0x0] ; nBuffer+32
 000002A6  4800      LDR         R1,=nStim ; nStim
 000002A8  680A      LDR         R2,[R1,#0x0] ; nStim
 000002AA  213C      MOV         R1,#0x3C
 000002AC  434A      MUL         R2,R1
 000002AE  4800      LDR         R1,=stim + 0x30 ; stim+48
 000002B0  5088      STR         R0,[R1,R2]
  322:                             stim[nStim].index     = nBuffer[9]; 
 000002B2  4800      LDR         R0,=nBuffer + 0x24 ; nBuffer+36
 000002B4  6800      LDR         R0,[R0,#0x0] ; nBuffer+36
 000002B6  4800      LDR         R1,=nStim ; nStim
 000002B8  680A      LDR         R2,[R1,#0x0] ; nStim
 000002BA  213C      MOV         R1,#0x3C
 000002BC  434A      MUL         R2,R1
 000002BE  4800      LDR         R1,=stim + 0xC ; stim+12
 000002C0  5088      STR         R0,[R1,R2]
  323:                             nStimLeds = nStim;
 000002C2  4800      LDR         R0,=nStim ; nStim
 000002C4  6801      LDR         R1,[R0,#0x0] ; nStim
 000002C6  4800      LDR         R0,=nStimLeds ; nStimLeds
 000002C8  6001      STR         R1,[R0,#0x0] ; nStimLeds
  324:                             break;
 000002CA  E1C9      B           L_77  ; T=0x00000660
  325:                 case stimBlink: stim[nStim].status    = statInit;
 000002CC          L_87:
 000002CC  2000      MOV         R0,#0x0
 000002CE  4800      LDR         R1,=nStim ; nStim
 000002D0  680A      LDR         R2,[R1,#0x0] ; nStim
 000002D2  233C      MOV         R3,#0x3C
 000002D4  4353      MUL         R3,R2
 000002D6  4800      LDR         R1,=stim + 0x4 ; stim+4
 000002D8  50C8      STR         R0,[R1,R3]
  326:                             stim[nStim].kind      = stimBlink;
 000002DA  206E      MOV         R0,#0x6E
 000002DC  213C      MOV         R1,#0x3C
 000002DE  434A      MUL         R2,R1
 000002E0  4800      LDR         R1,=stim + 0x8 ; stim+8
 000002E2  5088      STR         R0,[R1,R2]
  327:                             stim[nStim].posX      = nBuffer[2];
 000002E4  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 000002E6  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 000002E8  4800      LDR         R1,=nStim ; nStim
 000002EA  680A      LDR         R2,[R1,#0x0] ; nStim
 000002EC  213C      MOV         R1,#0x3C
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 41  

 000002EE  434A      MUL         R2,R1
 000002F0  4800      LDR         R1,=stim + 0x18 ; stim+24
 000002F2  5088      STR         R0,[R1,R2]
  328:                             stim[nStim].posY      = nBuffer[3];     
 000002F4  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 000002F6  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 000002F8  4800      LDR         R1,=nStim ; nStim
 000002FA  680A      LDR         R2,[R1,#0x0] ; nStim
 000002FC  213C      MOV         R1,#0x3C
 000002FE  434A      MUL         R2,R1
 00000300  4800      LDR         R1,=stim + 0x1C ; stim+28
 00000302  5088      STR         R0,[R1,R2]
  329:                             stim[nStim].level     = nBuffer[4];     
 00000304  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 00000306  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 00000308  4800      LDR         R1,=nStim ; nStim
 0000030A  680A      LDR         R2,[R1,#0x0] ; nStim
 0000030C  213C      MOV         R1,#0x3C
 0000030E  434A      MUL         R2,R1
 00000310  4800      LDR         R1,=stim + 0x20 ; stim+32
 00000312  5088      STR         R0,[R1,R2]
  330:                             stim[nStim].startRef  = nBuffer[5];
 00000314  4800      LDR         R0,=nBuffer + 0x14 ; nBuffer+20
 00000316  6800      LDR         R0,[R0,#0x0] ; nBuffer+20
 00000318  4800      LDR         R1,=nStim ; nStim
 0000031A  680A      LDR         R2,[R1,#0x0] ; nStim
 0000031C  213C      MOV         R1,#0x3C
 0000031E  434A      MUL         R2,R1
 00000320  4800      LDR         R1,=stim + 0x24 ; stim+36
 00000322  5088      STR         R0,[R1,R2]
  331:                             stim[nStim].startTime = nBuffer[6]; 
 00000324  4800      LDR         R0,=nBuffer + 0x18 ; nBuffer+24
 00000326  6800      LDR         R0,[R0,#0x0] ; nBuffer+24
 00000328  4800      LDR         R1,=nStim ; nStim
 0000032A  680A      LDR         R2,[R1,#0x0] ; nStim
 0000032C  213C      MOV         R1,#0x3C
 0000032E  434A      MUL         R2,R1
 00000330  4800      LDR         R1,=stim + 0x28 ; stim+40
 00000332  5088      STR         R0,[R1,R2]
  332:                             stim[nStim].stopRef   = nBuffer[7]; 
 00000334  4800      LDR         R0,=nBuffer + 0x1C ; nBuffer+28
 00000336  6800      LDR         R0,[R0,#0x0] ; nBuffer+28
 00000338  4800      LDR         R1,=nStim ; nStim
 0000033A  680A      LDR         R2,[R1,#0x0] ; nStim
 0000033C  213C      MOV         R1,#0x3C
 0000033E  434A      MUL         R2,R1
 00000340  4800      LDR         R1,=stim + 0x2C ; stim+44
 00000342  5088      STR         R0,[R1,R2]
  333:                             stim[nStim].stopTime  = nBuffer[8]; 
 00000344  4800      LDR         R0,=nBuffer + 0x20 ; nBuffer+32
 00000346  6800      LDR         R0,[R0,#0x0] ; nBuffer+32
 00000348  4800      LDR         R1,=nStim ; nStim
 0000034A  680A      LDR         R2,[R1,#0x0] ; nStim
 0000034C  213C      MOV         R1,#0x3C
 0000034E  434A      MUL         R2,R1
 00000350  4800      LDR         R1,=stim + 0x30 ; stim+48
 00000352  5088      STR         R0,[R1,R2]
  334:                             stim[nStim].index     = nBuffer[9]; 
 00000354  4800      LDR         R0,=nBuffer + 0x24 ; nBuffer+36
 00000356  6800      LDR         R0,[R0,#0x0] ; nBuffer+36
 00000358  4800      LDR         R1,=nStim ; nStim
 0000035A  680A      LDR         R2,[R1,#0x0] ; nStim
 0000035C  213C      MOV         R1,#0x3C
 0000035E  434A      MUL         R2,R1
 00000360  4800      LDR         R1,=stim + 0xC ; stim+12
 00000362  5088      STR         R0,[R1,R2]
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 42  

  335:                             break;
 00000364  E17C      B           L_77  ; T=0x00000660
  336:                 case stimAcq:   stim[nStim].status    = statInit;
 00000366          L_83:
 00000366  2000      MOV         R0,#0x0
 00000368  4800      LDR         R1,=nStim ; nStim
 0000036A  680A      LDR         R2,[R1,#0x0] ; nStim
 0000036C  233C      MOV         R3,#0x3C
 0000036E  4353      MUL         R3,R2
 00000370  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000372  50C8      STR         R0,[R1,R3]
  337:                             stim[nStim].kind      = stimAcq;
 00000374  2069      MOV         R0,#0x69
 00000376  213C      MOV         R1,#0x3C
 00000378  434A      MUL         R2,R1
 0000037A  4800      LDR         R1,=stim + 0x8 ; stim+8
 0000037C  5088      STR         R0,[R1,R2]
  338:                             stim[nStim].startRef  = nBuffer[2];
 0000037E  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 00000380  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 00000382  4800      LDR         R1,=nStim ; nStim
 00000384  680A      LDR         R2,[R1,#0x0] ; nStim
 00000386  213C      MOV         R1,#0x3C
 00000388  434A      MUL         R2,R1
 0000038A  4800      LDR         R1,=stim + 0x24 ; stim+36
 0000038C  5088      STR         R0,[R1,R2]
  339:                             stim[nStim].startTime = nBuffer[3]; 
 0000038E  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 00000390  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 00000392  4800      LDR         R1,=nStim ; nStim
 00000394  680A      LDR         R2,[R1,#0x0] ; nStim
 00000396  213C      MOV         R1,#0x3C
 00000398  434A      MUL         R2,R1
 0000039A  4800      LDR         R1,=stim + 0x28 ; stim+40
 0000039C  5088      STR         R0,[R1,R2]
  340:                             break;
 0000039E  E15F      B           L_77  ; T=0x00000660
  341:                 case stimSnd1:  stim[nStim].status    = statInit;
 000003A0          L_79:
 000003A0  2000      MOV         R0,#0x0
 000003A2  4800      LDR         R1,=nStim ; nStim
 000003A4  680A      LDR         R2,[R1,#0x0] ; nStim
 000003A6  233C      MOV         R3,#0x3C
 000003A8  4353      MUL         R3,R2
 000003AA  4800      LDR         R1,=stim + 0x4 ; stim+4
 000003AC  50C8      STR         R0,[R1,R3]
  342:                             stim[nStim].kind      = stimSnd1;
 000003AE  2065      MOV         R0,#0x65
 000003B0  213C      MOV         R1,#0x3C
 000003B2  434A      MUL         R2,R1
 000003B4  4800      LDR         R1,=stim + 0x8 ; stim+8
 000003B6  5088      STR         R0,[R1,R2]
  343:                             stim[nStim].posX      = nBuffer[2];
 000003B8  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 000003BA  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 000003BC  4800      LDR         R1,=nStim ; nStim
 000003BE  680A      LDR         R2,[R1,#0x0] ; nStim
 000003C0  213C      MOV         R1,#0x3C
 000003C2  434A      MUL         R2,R1
 000003C4  4800      LDR         R1,=stim + 0x18 ; stim+24
 000003C6  5088      STR         R0,[R1,R2]
  344:                             stim[nStim].posY      = nBuffer[3];     
 000003C8  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 000003CA  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 000003CC  4800      LDR         R1,=nStim ; nStim
 000003CE  680A      LDR         R2,[R1,#0x0] ; nStim
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 43  

 000003D0  213C      MOV         R1,#0x3C
 000003D2  434A      MUL         R2,R1
 000003D4  4800      LDR         R1,=stim + 0x1C ; stim+28
 000003D6  5088      STR         R0,[R1,R2]
  345:                             stim[nStim].index     = nBuffer[4]; 
 000003D8  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 000003DA  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 000003DC  4800      LDR         R1,=nStim ; nStim
 000003DE  680A      LDR         R2,[R1,#0x0] ; nStim
 000003E0  213C      MOV         R1,#0x3C
 000003E2  434A      MUL         R2,R1
 000003E4  4800      LDR         R1,=stim + 0xC ; stim+12
 000003E6  5088      STR         R0,[R1,R2]
  346:                             stim[nStim].level     = nBuffer[5];     
 000003E8  4800      LDR         R0,=nBuffer + 0x14 ; nBuffer+20
 000003EA  6800      LDR         R0,[R0,#0x0] ; nBuffer+20
 000003EC  4800      LDR         R1,=nStim ; nStim
 000003EE  680A      LDR         R2,[R1,#0x0] ; nStim
 000003F0  213C      MOV         R1,#0x3C
 000003F2  434A      MUL         R2,R1
 000003F4  4800      LDR         R1,=stim + 0x20 ; stim+32
 000003F6  5088      STR         R0,[R1,R2]
  347:                             stim[nStim].startRef  = nBuffer[6];
 000003F8  4800      LDR         R0,=nBuffer + 0x18 ; nBuffer+24
 000003FA  6801      LDR         R1,[R0,#0x0] ; nBuffer+24
 000003FC  4800      LDR         R0,=nStim ; nStim
 000003FE  6802      LDR         R2,[R0,#0x0] ; nStim
 00000400  203C      MOV         R0,#0x3C
 00000402  4342      MUL         R2,R0
 00000404  4800      LDR         R0,=stim + 0x24 ; stim+36
 00000406  5081      STR         R1,[R0,R2]
  348:                             stim[nStim].startTime = nBuffer[7];
 00000408  4800      LDR         R0,=nBuffer + 0x1C ; nBuffer+28
 0000040A  6800      LDR         R0,[R0,#0x0] ; nBuffer+28
 0000040C  4800      LDR         R2,=nStim ; nStim
 0000040E  6813      LDR         R3,[R2,#0x0] ; nStim
 00000410  223C      MOV         R2,#0x3C
 00000412  4353      MUL         R3,R2
 00000414  4800      LDR         R2,=stim + 0x28 ; stim+40
 00000416  50D0      STR         R0,[R2,R3]
  349:                             stim[nStim].width     = nBuffer[8];
 00000418  4800      LDR         R0,=nBuffer + 0x20 ; nBuffer+32
 0000041A  6800      LDR         R0,[R0,#0x0] ; nBuffer+32
 0000041C  4800      LDR         R2,=nStim ; nStim
 0000041E  6813      LDR         R3,[R2,#0x0] ; nStim
 00000420  223C      MOV         R2,#0x3C
 00000422  4353      MUL         R3,R2
 00000424  4800      LDR         R2,=stim + 0x34 ; stim+52
 00000426  50D0      STR         R0,[R2,R3]
  350:                             tmpSnd1[0] = 1;
 00000428  2201      MOV         R2,#0x1
 0000042A  4800      LDR         R0,=tmpSnd1 ; tmpSnd1
 0000042C  6002      STR         R2,[R0,#0x0] ; tmpSnd1
  351:                             tmpSnd1[1] = nBuffer[6];
 0000042E  4800      LDR         R0,=tmpSnd1 + 0x4 ; tmpSnd1+4
 00000430  6001      STR         R1,[R0,#0x0] ; tmpSnd1+4
  352:                             tmpSnd1[2] = nBuffer[7]; 
 00000432  4800      LDR         R0,=nBuffer + 0x1C ; nBuffer+28
 00000434  6801      LDR         R1,[R0,#0x0] ; nBuffer+28
 00000436  4800      LDR         R0,=tmpSnd1 + 0x8 ; tmpSnd1+8
 00000438  6001      STR         R1,[R0,#0x0] ; tmpSnd1+8
  353:                             tmpSnd1[3] = nStim;
 0000043A  4800      LDR         R0,=nStim ; nStim
 0000043C  6801      LDR         R1,[R0,#0x0] ; nStim
 0000043E  4800      LDR         R0,=tmpSnd1 + 0xC ; tmpSnd1+12
 00000440  6001      STR         R1,[R0,#0x0] ; tmpSnd1+12
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 44  

  354:                             break;
 00000442  E10D      B           L_77  ; T=0x00000660
  355:                 case stimSnd2:  stim[nStim].status    = statInit;
 00000444          L_80:
 00000444  2000      MOV         R0,#0x0
 00000446  4800      LDR         R1,=nStim ; nStim
 00000448  680A      LDR         R2,[R1,#0x0] ; nStim
 0000044A  233C      MOV         R3,#0x3C
 0000044C  4353      MUL         R3,R2
 0000044E  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000450  50C8      STR         R0,[R1,R3]
  356:                             stim[nStim].kind      = stimSnd2;
 00000452  2066      MOV         R0,#0x66
 00000454  213C      MOV         R1,#0x3C
 00000456  434A      MUL         R2,R1
 00000458  4800      LDR         R1,=stim + 0x8 ; stim+8
 0000045A  5088      STR         R0,[R1,R2]
  357:                             stim[nStim].posX      = nBuffer[2];
 0000045C  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 0000045E  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 00000460  4800      LDR         R1,=nStim ; nStim
 00000462  680A      LDR         R2,[R1,#0x0] ; nStim
 00000464  213C      MOV         R1,#0x3C
 00000466  434A      MUL         R2,R1
 00000468  4800      LDR         R1,=stim + 0x18 ; stim+24
 0000046A  5088      STR         R0,[R1,R2]
  358:                             stim[nStim].posY      = nBuffer[3];     
 0000046C  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 0000046E  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 00000470  4800      LDR         R1,=nStim ; nStim
 00000472  680A      LDR         R2,[R1,#0x0] ; nStim
 00000474  213C      MOV         R1,#0x3C
 00000476  434A      MUL         R2,R1
 00000478  4800      LDR         R1,=stim + 0x1C ; stim+28
 0000047A  5088      STR         R0,[R1,R2]
  359:                             stim[nStim].index     = nBuffer[4]; 
 0000047C  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 0000047E  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 00000480  4800      LDR         R1,=nStim ; nStim
 00000482  680A      LDR         R2,[R1,#0x0] ; nStim
 00000484  213C      MOV         R1,#0x3C
 00000486  434A      MUL         R2,R1
 00000488  4800      LDR         R1,=stim + 0xC ; stim+12
 0000048A  5088      STR         R0,[R1,R2]
  360:                             stim[nStim].level     = nBuffer[5];     
 0000048C  4800      LDR         R0,=nBuffer + 0x14 ; nBuffer+20
 0000048E  6800      LDR         R0,[R0,#0x0] ; nBuffer+20
 00000490  4800      LDR         R1,=nStim ; nStim
 00000492  680A      LDR         R2,[R1,#0x0] ; nStim
 00000494  213C      MOV         R1,#0x3C
 00000496  434A      MUL         R2,R1
 00000498  4800      LDR         R1,=stim + 0x20 ; stim+32
 0000049A  5088      STR         R0,[R1,R2]
  361:                             stim[nStim].startRef  = nBuffer[6];
 0000049C  4800      LDR         R0,=nBuffer + 0x18 ; nBuffer+24
 0000049E  6801      LDR         R1,[R0,#0x0] ; nBuffer+24
 000004A0  4800      LDR         R0,=nStim ; nStim
 000004A2  6802      LDR         R2,[R0,#0x0] ; nStim
 000004A4  203C      MOV         R0,#0x3C
 000004A6  4342      MUL         R2,R0
 000004A8  4800      LDR         R0,=stim + 0x24 ; stim+36
 000004AA  5081      STR         R1,[R0,R2]
  362:                             stim[nStim].startTime = nBuffer[7]; 
 000004AC  4800      LDR         R0,=nBuffer + 0x1C ; nBuffer+28
 000004AE  6800      LDR         R0,[R0,#0x0] ; nBuffer+28
 000004B0  4800      LDR         R2,=nStim ; nStim
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 45  

 000004B2  6813      LDR         R3,[R2,#0x0] ; nStim
 000004B4  223C      MOV         R2,#0x3C
 000004B6  4353      MUL         R3,R2
 000004B8  4800      LDR         R2,=stim + 0x28 ; stim+40
 000004BA  50D0      STR         R0,[R2,R3]
  363:                             stim[nStim].width     = nBuffer[8];
 000004BC  4800      LDR         R0,=nBuffer + 0x20 ; nBuffer+32
 000004BE  6800      LDR         R0,[R0,#0x0] ; nBuffer+32
 000004C0  4800      LDR         R2,=nStim ; nStim
 000004C2  6813      LDR         R3,[R2,#0x0] ; nStim
 000004C4  223C      MOV         R2,#0x3C
 000004C6  4353      MUL         R3,R2
 000004C8  4800      LDR         R2,=stim + 0x34 ; stim+52
 000004CA  50D0      STR         R0,[R2,R3]
  364:                             tmpSnd2[0] = 1;
 000004CC  2201      MOV         R2,#0x1
 000004CE  4800      LDR         R0,=tmpSnd2 ; tmpSnd2
 000004D0  6002      STR         R2,[R0,#0x0] ; tmpSnd2
  365:                             tmpSnd2[1] = nBuffer[6];
 000004D2  4800      LDR         R0,=tmpSnd2 + 0x4 ; tmpSnd2+4
 000004D4  6001      STR         R1,[R0,#0x0] ; tmpSnd2+4
  366:                             tmpSnd2[2] = nBuffer[7];
 000004D6  4800      LDR         R0,=nBuffer + 0x1C ; nBuffer+28
 000004D8  6801      LDR         R1,[R0,#0x0] ; nBuffer+28
 000004DA  4800      LDR         R0,=tmpSnd2 + 0x8 ; tmpSnd2+8
 000004DC  6001      STR         R1,[R0,#0x0] ; tmpSnd2+8
  367:                             tmpSnd2[3] = nStim;
 000004DE  4800      LDR         R0,=nStim ; nStim
 000004E0  6801      LDR         R1,[R0,#0x0] ; nStim
 000004E2  4800      LDR         R0,=tmpSnd2 + 0xC ; tmpSnd2+12
 000004E4  6001      STR         R1,[R0,#0x0] ; tmpSnd2+12
  368:                             break;
 000004E6  E0BB      B           L_77  ; T=0x00000660
  369:                 case stimTrg0:stim[nStim].status    = statInit;
 000004E8          L_84:
 000004E8  2000      MOV         R0,#0x0
 000004EA  4800      LDR         R1,=nStim ; nStim
 000004EC  680A      LDR         R2,[R1,#0x0] ; nStim
 000004EE  233C      MOV         R3,#0x3C
 000004F0  4353      MUL         R3,R2
 000004F2  4800      LDR         R1,=stim + 0x4 ; stim+4
 000004F4  50C8      STR         R0,[R1,R3]
  370:                             stim[nStim].kind      = stimTrg0;
 000004F6  206A      MOV         R0,#0x6A
 000004F8  213C      MOV         R1,#0x3C
 000004FA  434A      MUL         R2,R1
 000004FC  4800      LDR         R1,=stim + 0x8 ; stim+8
 000004FE  5088      STR         R0,[R1,R2]
  371:                             stim[nStim].edge      = nBuffer[2];
 00000500  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 00000502  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 00000504  4800      LDR         R1,=nStim ; nStim
 00000506  680A      LDR         R2,[R1,#0x0] ; nStim
 00000508  213C      MOV         R1,#0x3C
 0000050A  434A      MUL         R2,R1
 0000050C  4800      LDR         R1,=stim + 0x10 ; stim+16
 0000050E  5088      STR         R0,[R1,R2]
  372:                             stim[nStim].bitNo     = nBuffer[3];
 00000510  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 00000512  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 00000514  4800      LDR         R1,=nStim ; nStim
 00000516  680A      LDR         R2,[R1,#0x0] ; nStim
 00000518  213C      MOV         R1,#0x3C
 0000051A  434A      MUL         R2,R1
 0000051C  4800      LDR         R1,=stim + 0x14 ; stim+20
 0000051E  5088      STR         R0,[R1,R2]
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 46  

  373:                             stim[nStim].startRef  = nBuffer[4];
 00000520  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 00000522  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 00000524  4800      LDR         R1,=nStim ; nStim
 00000526  680A      LDR         R2,[R1,#0x0] ; nStim
 00000528  213C      MOV         R1,#0x3C
 0000052A  434A      MUL         R2,R1
 0000052C  4800      LDR         R1,=stim + 0x24 ; stim+36
 0000052E  5088      STR         R0,[R1,R2]
  374:                             stim[nStim].startTime = nBuffer[5]; 
 00000530  4800      LDR         R0,=nBuffer + 0x14 ; nBuffer+20
 00000532  6800      LDR         R0,[R0,#0x0] ; nBuffer+20
 00000534  4800      LDR         R1,=nStim ; nStim
 00000536  680A      LDR         R2,[R1,#0x0] ; nStim
 00000538  213C      MOV         R1,#0x3C
 0000053A  434A      MUL         R2,R1
 0000053C  4800      LDR         R1,=stim + 0x28 ; stim+40
 0000053E  5088      STR         R0,[R1,R2]
  375:                             stim[nStim].event     = nBuffer[6];
 00000540  4800      LDR         R0,=nBuffer + 0x18 ; nBuffer+24
 00000542  6800      LDR         R0,[R0,#0x0] ; nBuffer+24
 00000544  4800      LDR         R1,=nStim ; nStim
 00000546  680A      LDR         R2,[R1,#0x0] ; nStim
 00000548  213C      MOV         R1,#0x3C
 0000054A  434A      MUL         R2,R1
 0000054C  4800      LDR         R1,=stim + 0x38 ; stim+56
 0000054E  5088      STR         R0,[R1,R2]
  376:                             break;
 00000550  E086      B           L_77  ; T=0x00000660
  377:                 case stimSky:   stim[nStim].status    = statInit;
 00000552          L_85:
 00000552  2000      MOV         R0,#0x0
 00000554  4800      LDR         R1,=nStim ; nStim
 00000556  680A      LDR         R2,[R1,#0x0] ; nStim
 00000558  233C      MOV         R3,#0x3C
 0000055A  4353      MUL         R3,R2
 0000055C  4800      LDR         R1,=stim + 0x4 ; stim+4
 0000055E  50C8      STR         R0,[R1,R3]
  378:                             stim[nStim].kind      = stimSky;
 00000560  206C      MOV         R0,#0x6C
 00000562  213C      MOV         R1,#0x3C
 00000564  434A      MUL         R2,R1
 00000566  4800      LDR         R1,=stim + 0x8 ; stim+8
 00000568  5088      STR         R0,[R1,R2]
  379:                             stim[nStim].posX      = nBuffer[2];
 0000056A  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 0000056C  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 0000056E  4800      LDR         R1,=nStim ; nStim
 00000570  680A      LDR         R2,[R1,#0x0] ; nStim
 00000572  213C      MOV         R1,#0x3C
 00000574  434A      MUL         R2,R1
 00000576  4800      LDR         R1,=stim + 0x18 ; stim+24
 00000578  5088      STR         R0,[R1,R2]
  380:                             stim[nStim].posY      = nBuffer[3];     
 0000057A  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 0000057C  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 0000057E  4800      LDR         R1,=nStim ; nStim
 00000580  680A      LDR         R2,[R1,#0x0] ; nStim
 00000582  213C      MOV         R1,#0x3C
 00000584  434A      MUL         R2,R1
 00000586  4800      LDR         R1,=stim + 0x1C ; stim+28
 00000588  5088      STR         R0,[R1,R2]
  381:                             stim[nStim].level     = nBuffer[4];     
 0000058A  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 0000058C  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 0000058E  4800      LDR         R1,=nStim ; nStim
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 47  

 00000590  680A      LDR         R2,[R1,#0x0] ; nStim
 00000592  213C      MOV         R1,#0x3C
 00000594  434A      MUL         R2,R1
 00000596  4800      LDR         R1,=stim + 0x20 ; stim+32
 00000598  5088      STR         R0,[R1,R2]
  382:                             stim[nStim].startRef  = nBuffer[5];
 0000059A  4800      LDR         R0,=nBuffer + 0x14 ; nBuffer+20
 0000059C  6800      LDR         R0,[R0,#0x0] ; nBuffer+20
 0000059E  4800      LDR         R1,=nStim ; nStim
 000005A0  680A      LDR         R2,[R1,#0x0] ; nStim
 000005A2  213C      MOV         R1,#0x3C
 000005A4  434A      MUL         R2,R1
 000005A6  4800      LDR         R1,=stim + 0x24 ; stim+36
 000005A8  5088      STR         R0,[R1,R2]
  383:                             stim[nStim].startTime = nBuffer[6]; 
 000005AA  4800      LDR         R0,=nBuffer + 0x18 ; nBuffer+24
 000005AC  6800      LDR         R0,[R0,#0x0] ; nBuffer+24
 000005AE  4800      LDR         R1,=nStim ; nStim
 000005B0  680A      LDR         R2,[R1,#0x0] ; nStim
 000005B2  213C      MOV         R1,#0x3C
 000005B4  434A      MUL         R2,R1
 000005B6  4800      LDR         R1,=stim + 0x28 ; stim+40
 000005B8  5088      STR         R0,[R1,R2]
  384:                             stim[nStim].stopRef   = nBuffer[7]; 
 000005BA  4800      LDR         R0,=nBuffer + 0x1C ; nBuffer+28
 000005BC  6800      LDR         R0,[R0,#0x0] ; nBuffer+28
 000005BE  4800      LDR         R1,=nStim ; nStim
 000005C0  680A      LDR         R2,[R1,#0x0] ; nStim
 000005C2  213C      MOV         R1,#0x3C
 000005C4  434A      MUL         R2,R1
 000005C6  4800      LDR         R1,=stim + 0x2C ; stim+44
 000005C8  5088      STR         R0,[R1,R2]
  385:                             stim[nStim].stopTime  = nBuffer[8]; 
 000005CA  4800      LDR         R0,=nBuffer + 0x20 ; nBuffer+32
 000005CC  6800      LDR         R0,[R0,#0x0] ; nBuffer+32
 000005CE  4800      LDR         R1,=nStim ; nStim
 000005D0  680A      LDR         R2,[R1,#0x0] ; nStim
 000005D2  213C      MOV         R1,#0x3C
 000005D4  434A      MUL         R2,R1
 000005D6  4800      LDR         R1,=stim + 0x30 ; stim+48
 000005D8  5088      STR         R0,[R1,R2]
  386:                             break;
 000005DA  E041      B           L_77  ; T=0x00000660
  387:                 case stimInp1:  stim[nStim].status = statDone;    // start en duur wordt bepaald door SND1
 000005DC          L_81:
 000005DC  2005      MOV         R0,#0x5
 000005DE  4800      LDR         R1,=nStim ; nStim
 000005E0  680A      LDR         R2,[R1,#0x0] ; nStim
 000005E2  233C      MOV         R3,#0x3C
 000005E4  4353      MUL         R3,R2
 000005E6  4800      LDR         R1,=stim + 0x4 ; stim+4
 000005E8  50C8      STR         R0,[R1,R3]
  388:                             stim[nStim].kind      = stimInp1;
 000005EA  2067      MOV         R0,#0x67
 000005EC  213C      MOV         R1,#0x3C
 000005EE  434A      MUL         R2,R1
 000005F0  4800      LDR         R1,=stim + 0x8 ; stim+8
 000005F2  5088      STR         R0,[R1,R2]
  389:                             break;
 000005F4  E034      B           L_77  ; T=0x00000660
  390:                 case stimInp2:  stim[nStim].status = statDone;
 000005F6          L_82:
 000005F6  2005      MOV         R0,#0x5
 000005F8  4800      LDR         R1,=nStim ; nStim
 000005FA  680A      LDR         R2,[R1,#0x0] ; nStim
 000005FC  233C      MOV         R3,#0x3C
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 48  

 000005FE  4353      MUL         R3,R2
 00000600  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000602  50C8      STR         R0,[R1,R3]
  391:                             stim[nStim].kind      = stimInp2;
 00000604  2068      MOV         R0,#0x68
 00000606  213C      MOV         R1,#0x3C
 00000608  434A      MUL         R2,R1
 0000060A  4800      LDR         R1,=stim + 0x8 ; stim+8
 0000060C  5088      STR         R0,[R1,R2]
  392:                             break;
 0000060E  E027      B           L_77  ; T=0x00000660
  393:                 case stimLas:   stim[nStim].status = statInit;
 00000610          L_88:
 00000610  2000      MOV         R0,#0x0
 00000612  4800      LDR         R1,=nStim ; nStim
 00000614  680A      LDR         R2,[R1,#0x0] ; nStim
 00000616  233C      MOV         R3,#0x3C
 00000618  4353      MUL         R3,R2
 0000061A  4800      LDR         R1,=stim + 0x4 ; stim+4
 0000061C  50C8      STR         R0,[R1,R3]
  394:                             stim[nStim].kind       = stimLas;
 0000061E  206F      MOV         R0,#0x6F
 00000620  213C      MOV         R1,#0x3C
 00000622  434A      MUL         R2,R1
 00000624  4800      LDR         R1,=stim + 0x8 ; stim+8
 00000626  5088      STR         R0,[R1,R2]
  395:                             stim[nStim].bitNo      = nBuffer[2];
 00000628  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 0000062A  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 0000062C  4800      LDR         R1,=nStim ; nStim
 0000062E  680A      LDR         R2,[R1,#0x0] ; nStim
 00000630  213C      MOV         R1,#0x3C
 00000632  434A      MUL         R2,R1
 00000634  4800      LDR         R1,=stim + 0x14 ; stim+20
 00000636  5088      STR         R0,[R1,R2]
  396:                             stim[nStim].startRef   = nBuffer[3];
 00000638  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 0000063A  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 0000063C  4800      LDR         R1,=nStim ; nStim
 0000063E  680A      LDR         R2,[R1,#0x0] ; nStim
 00000640  213C      MOV         R1,#0x3C
 00000642  434A      MUL         R2,R1
 00000644  4800      LDR         R1,=stim + 0x24 ; stim+36
 00000646  5088      STR         R0,[R1,R2]
  397:                             stim[nStim].startTime  = nBuffer[4];    
 00000648  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 0000064A  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 0000064C  4800      LDR         R1,=nStim ; nStim
 0000064E  680A      LDR         R2,[R1,#0x0] ; nStim
 00000650  213C      MOV         R1,#0x3C
 00000652  434A      MUL         R2,R1
 00000654  4800      LDR         R1,=stim + 0x28 ; stim+40
 00000656  5088      STR         R0,[R1,R2]
  398:                             stim[nStim].stopRef    = nBuffer[5];    
 00000658  4800      LDR         R0,=nBuffer + 0x14 ; nBuffer+20
 0000065A  6800      LDR         R0,[R0,#0x0] ; nBuffer+20
 0000065C  4800      LDR         R1,=nStim ; nStim
 0000065E  680A      LDR         R2,[R1,#0x0] ; nStim
 00000660  213C      MOV         R1,#0x3C
 00000662  434A      MUL         R2,R1
 00000664  4800      LDR         R1,=stim + 0x2C ; stim+44
 00000666  5088      STR         R0,[R1,R2]
  399:                             stim[nStim].stopTime   = nBuffer[6];    
 00000668  4800      LDR         R0,=nBuffer + 0x18 ; nBuffer+24
 0000066A  6800      LDR         R0,[R0,#0x0] ; nBuffer+24
 0000066C  4800      LDR         R1,=nStim ; nStim
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 49  

 0000066E  680A      LDR         R2,[R1,#0x0] ; nStim
 00000670  213C      MOV         R1,#0x3C
 00000672  434A      MUL         R2,R1
 00000674  4800      LDR         R1,=stim + 0x30 ; stim+48
 00000676  5088      STR         R0,[R1,R2]
  401:                 }
 00000678          L_77:
  402:                 if (nStim < (newStim-1))
 00000678  4800      LDR         R0,=newStim ; newStim
 0000067A  6800      LDR         R0,[R0,#0x0] ; newStim
 0000067C  3801      SUB         R0,#0x1
 0000067E  4800      LDR         R1,=nStim ; nStim
 00000680  6809      LDR         R1,[R1,#0x0] ; nStim
 00000682  4281      CMP         R1,R0
 00000684  DAF7      BGE         L_89  ; T=0x00000676
  403:                     nStim++;
 00000686  4800      LDR         R0,=nStim ; nStim
 00000688  3101      ADD         R1,#0x1
 0000068A  6001      STR         R1,[R0,#0x0] ; nStim
 0000068C  E00E      B           L_90  ; T=0x000006AC
 0000068E          L_89:
  406:                     nStatus = statWait;
 0000068E  2106      MOV         R1,#0x6
 00000690  4800      LDR         R0,=nStatus ; nStatus
 00000692  6001      STR         R1,[R0,#0x0] ; nStatus
  407:                     tBuf[0] = curTime;
 00000694  4800      LDR         R0,=curTime ; curTime
 00000696  6801      LDR         R1,[R0,#0x0] ; curTime
 00000698  4800      LDR         R0,=tBuf ; tBuf
 0000069A  6001      STR         R1,[R0,#0x0] ; tBuf
  408:                     Clock_Reset();
 0000069C  F7FF      BL          Clock_Reset?T  ; T=0x0001  (1)
 0000069E  FCB0      BL          Clock_Reset?T  ; T=0x0001  (2)
  409:                     snd12Flag = 0;
 000006A0  2100      MOV         R1,#0x0
 000006A2  4800      LDR         R0,=snd12Flag ; snd12Flag
 000006A4  6001      STR         R1,[R0,#0x0] ; snd12Flag
  411:                     for (i = 0; i < 3; i++) 
 000006A6  2500      MOV         R5,#0x0
 000006A8          L_94:
  413:                         if (tmpSnd1[i] == tmpSnd2[i]) snd12Flag++;
 000006A8  00AA      LSL         R2,R5,#0x2 ; i
 000006AA  4800      LDR         R0,=tmpSnd2 ; tmpSnd2
 000006AC  5881      LDR         R1,[R0,R2]
 000006AE  4800      LDR         R0,=tmpSnd1 ; tmpSnd1
 000006B0  5880      LDR         R0,[R0,R2]
 000006B2  4288      CMP         R0,R1
 000006B4  D1F7      BNE         L_91  ; T=0x000006A6
 000006B6  4800      LDR         R0,=snd12Flag ; snd12Flag
 000006B8  6801      LDR         R1,[R0,#0x0] ; snd12Flag
 000006BA  3101      ADD         R1,#0x1
 000006BC  6001      STR         R1,[R0,#0x0] ; snd12Flag
  414:                     }
 000006BE          L_91:
 000006BE  3501      ADD         R5,#0x1
 000006C0  2D03      CMP         R5,#0x3 ; i
 000006C2  DBF1      BLT         L_94  ; T=0x000006A8
  415:                 }
 000006C4          L_90:
  416:                 i = curTime;
 000006C4  4800      LDR         R0,=curTime ; curTime
 000006C6  6805      LDR         R5,[R0,#0x0] ; curTime
  417:                 n = sprintf(outBuf,"%d\n",i);
 000006C8  4800      LDR         R0,=outBuf ; outBuf
 000006CA  4800      LDR         R1,=??S_2 ; ??S_2
 000006CC  1C2A      MOV         R2,R5
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 50  

 000006CE  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 000006D0  FC97      BL          sprintf?T  ; T=0x0001  (2)
 000006D2  9003      STR         R0,[R13,#0xC] ; n
  418:                 i = UART0_Str(outBuf, n);
 000006D4  4800      LDR         R0,=outBuf ; outBuf
 000006D6  9903      LDR         R1,[R13,#0xC] ; n
 000006D8  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 000006DA  FC92      BL          UART0_Str?T  ; T=0x0001  (2)
 000006DC  1C05      MOV         R5,R0 ; i
  419:                 EOL = 0;
 000006DE  2700      MOV         R7,#0x0
  420:                 num = 0;
 000006E0  2000      MOV         R0,#0x0
 000006E2  9000      STR         R0,[R13,#0x0] ; num
  422:          }
 000006E4          L_75:
  424:         if (nStatus == statWait)
 000006E4  4800      LDR         R0,=nStatus ; nStatus
 000006E6  6800      LDR         R0,[R0,#0x0] ; nStatus
 000006E8  2806      CMP         R0,#0x6
 000006EA  D108      BNE         L_97  ; T=0x000006FE
  426:             if (EOL == 1)
 000006EC  2F01      CMP         R7,#0x1 ; EOL
 000006EE  D106      BNE         L_97  ; T=0x000006FE
  428:                 if (nBuffer[1] == cmdStart)
 000006F0  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 000006F2  6800      LDR         R0,[R0,#0x0] ; nBuffer+4
 000006F4  2823      CMP         R0,#0x23
 000006F6  D102      BNE         L_97  ; T=0x000006FE
  430:                     tBuf[1] = curTime;
 000006F8  4800      LDR         R0,=curTime ; curTime
 000006FA  6801      LDR         R1,[R0,#0x0] ; curTime
 000006FC  4800      LDR         R0,=tBuf + 0x4 ; tBuf+4
 000006FE  6001      STR         R1,[R0,#0x0] ; tBuf+4
  431:                     Clock_Reset();
 00000700  F7FF      BL          Clock_Reset?T  ; T=0x0001  (1)
 00000702  FC7E      BL          Clock_Reset?T  ; T=0x0001  (2)
  432:                     curTime = 0;
 00000704  2100      MOV         R1,#0x0
 00000706  4800      LDR         R0,=curTime ; curTime
 00000708  6001      STR         R1,[R0,#0x0] ; curTime
  433:                     nStatus = statITI;
 0000070A  2101      MOV         R1,#0x1
 0000070C  4800      LDR         R0,=nStatus ; nStatus
 0000070E  6001      STR         R1,[R0,#0x0] ; nStatus
  434:                     EOL = 0;
 00000710  2700      MOV         R7,#0x0
  435:                     num = 0;
 00000712  2000      MOV         R0,#0x0
 00000714  9000      STR         R0,[R13,#0x0] ; num
  438:         }
 00000716          L_97:
  440:         if (nStatus == statITI)
 00000716  4800      LDR         R0,=nStatus ; nStatus
 00000718  6800      LDR         R0,[R0,#0x0] ; nStatus
 0000071A  2801      CMP         R0,#0x1
 0000071C  D105      BNE         L_100  ; T=0x0000072A
  442:             if (curTime >= startTime)
 0000071E  4800      LDR         R0,=startTime ; startTime
 00000720  6800      LDR         R0,[R0,#0x0] ; startTime
 00000722  4800      LDR         R1,=curTime ; curTime
 00000724  6809      LDR         R1,[R1,#0x0] ; curTime
 00000726  4281      CMP         R1,R0
 00000728  D3FF      BCC         L_100  ; T=0x0000072A
  444:                 nStatus   = statRun;
 0000072A  2203      MOV         R2,#0x3
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 51  

 0000072C  4800      LDR         R0,=nStatus ; nStatus
 0000072E  6002      STR         R2,[R0,#0x0] ; nStatus
  445:                 startTime = curTime;
 00000730  4800      LDR         R0,=startTime ; startTime
 00000732  6001      STR         R1,[R0,#0x0] ; startTime
  446:                 tBuf[2] = curTime;
 00000734  4800      LDR         R0,=tBuf + 0x8 ; tBuf+8
 00000736  6001      STR         R1,[R0,#0x0] ; tBuf+8
  447:                 Clock_Reset();
 00000738  F7FF      BL          Clock_Reset?T  ; T=0x0001  (1)
 0000073A  FC62      BL          Clock_Reset?T  ; T=0x0001  (2)
  448:                 curTime = 0;
 0000073C  2100      MOV         R1,#0x0
 0000073E  4800      LDR         R0,=curTime ; curTime
 00000740  6001      STR         R1,[R0,#0x0] ; curTime
  450:         }
 00000742          L_100:
  452:         if (nStatus == statRun)
 00000742  4800      LDR         R0,=nStatus ; nStatus
 00000744  6800      LDR         R0,[R0,#0x0] ; nStatus
 00000746  2803      CMP         R0,#0x3
 00000748  D14A      BNE         L_102  ; T=0x000007E0
  454:             done = 0;
 0000074A  2600      MOV         R6,#0x0
  455:             for (i = 0; i <= nStim; i++)
 0000074C  2500      MOV         R5,#0x0
 0000074E  E036      B           L_105  ; T=0x000007BE
 00000750          L_106:
  457:                 switch(stim[i].kind)
 00000750  213C      MOV         R1,#0x3C
 00000752  4369      MUL         R1,R5 ; i
 00000754  4800      LDR         R0,=stim + 0x8 ; stim+8
 00000756  5840      LDR         R0,[R0,R1]
 00000758  2865      CMP         R0,#0x65
 0000075A  D012      BEQ         L_110  ; T=0x00000782
 0000075C  2866      CMP         R0,#0x66
 0000075E  D015      BEQ         L_111  ; T=0x0000078C
 00000760  2869      CMP         R0,#0x69
 00000762  D01D      BEQ         L_112  ; T=0x000007A0
 00000764  286A      CMP         R0,#0x6A
 00000766  D016      BEQ         L_113  ; T=0x00000796
 00000768  286C      CMP         R0,#0x6C
 0000076A  D01E      BEQ         L_114  ; T=0x000007AA
 0000076C  286D      CMP         R0,#0x6D
 0000076E  D0FE      BEQ         L_115  ; T=0x0000076E
 00000770  286E      CMP         R0,#0x6E
 00000772  D001      BEQ         L_116  ; T=0x00000778
 00000774  286F      CMP         R0,#0x6F
 00000776  D01D      BEQ         L_117  ; T=0x000007B4
 00000778  2864      CMP         R0,#0x64
 0000077A  D11F      BNE         L_103  ; T=0x000007BC
  459:                 case stimLed:  done += ExecLed(i);  break;
 0000077C          L_109:
 0000077C  1C28      MOV         R0,R5
 0000077E  F7FF      BL          ExecLed?T  ; T=0x0001  (1)
 00000780  FC3F      BL          ExecLed?T  ; T=0x0001  (2)
 00000782  1836      ADD         R6,R0 ; done
 00000784  E01A      B           L_103  ; T=0x000007BC
  460:                 case stimLeds: done += ExecLeds(i); break;
 00000786          L_115:
 00000786  1C28      MOV         R0,R5
 00000788  F7FF      BL          ExecLeds?T  ; T=0x0001  (1)
 0000078A  FC3A      BL          ExecLeds?T  ; T=0x0001  (2)
 0000078C  1836      ADD         R6,R0 ; done
 0000078E  E015      B           L_103  ; T=0x000007BC
  461:                 case stimBlink:done += ExecBlink(i);break;
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 52  

 00000790          L_116:
 00000790  1C28      MOV         R0,R5
 00000792  F7FF      BL          ExecBlink?T  ; T=0x0001  (1)
 00000794  FC35      BL          ExecBlink?T  ; T=0x0001  (2)
 00000796  1836      ADD         R6,R0 ; done
 00000798  E010      B           L_103  ; T=0x000007BC
  462:                 case stimSnd1: done += ExecSnd(i);  break;
 0000079A          L_110:
 0000079A  1C28      MOV         R0,R5
 0000079C  F7FF      BL          ExecSnd?T  ; T=0x0001  (1)
 0000079E  FC30      BL          ExecSnd?T  ; T=0x0001  (2)
 000007A0  1836      ADD         R6,R0 ; done
 000007A2  E00B      B           L_103  ; T=0x000007BC
  463:                 case stimSnd2: done += ExecSnd(i);  break;
 000007A4          L_111:
 000007A4  1C28      MOV         R0,R5
 000007A6  F7FF      BL          ExecSnd?T  ; T=0x0001  (1)
 000007A8  FC2B      BL          ExecSnd?T  ; T=0x0001  (2)
 000007AA  1836      ADD         R6,R0 ; done
 000007AC  E006      B           L_103  ; T=0x000007BC
  464:                 case stimTrg0: done += ExecTrg0(i); break;
 000007AE          L_113:
 000007AE  1C28      MOV         R0,R5
 000007B0  F7FF      BL          ExecTrg0?T  ; T=0x0001  (1)
 000007B2  FC26      BL          ExecTrg0?T  ; T=0x0001  (2)
 000007B4  1836      ADD         R6,R0 ; done
 000007B6  E001      B           L_103  ; T=0x000007BC
  465:                 case stimAcq:  done += ExecAcq(i);  break;
 000007B8          L_112:
 000007B8  1C28      MOV         R0,R5
 000007BA  F7FF      BL          ExecAcq?T  ; T=0x0001  (1)
 000007BC  FC21      BL          ExecAcq?T  ; T=0x0001  (2)
 000007BE  1836      ADD         R6,R0 ; done
 000007C0  E7FC      B           L_103  ; T=0x000007BC
  466:                 case stimSky:  done += ExecSky(i);  break;
 000007C2          L_114:
 000007C2  1C28      MOV         R0,R5
 000007C4  F7FF      BL          ExecSky?T  ; T=0x0001  (1)
 000007C6  FC1C      BL          ExecSky?T  ; T=0x0001  (2)
 000007C8  1836      ADD         R6,R0 ; done
 000007CA  E7F7      B           L_103  ; T=0x000007BC
  467:                 case stimLas:  done += ExecLas(i);  break;
 000007CC          L_117:
 000007CC  1C28      MOV         R0,R5
 000007CE  F7FF      BL          ExecLas?T  ; T=0x0001  (1)
 000007D0  FC17      BL          ExecLas?T  ; T=0x0001  (2)
 000007D2  1836      ADD         R6,R0 ; done
  469:             }
 000007D4          L_103:
 000007D4  3501      ADD         R5,#0x1
 000007D6          L_105:
 000007D6  4800      LDR         R0,=nStim ; nStim
 000007D8  6800      LDR         R0,[R0,#0x0] ; nStim
 000007DA  4285      CMP         R5,R0 ; i
 000007DC  DDB8      BLE         L_106  ; T=0x00000750
  470:             curTime = Clock_GetTicks();
 000007DE  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 000007E0  FC0F      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 000007E2  4800      LDR         R1,=curTime ; curTime
 000007E4  6008      STR         R0,[R1,#0x0] ; curTime
  472:             if (done == 0)
 000007E6  2E00      CMP         R6,#0x0 ; done
 000007E8  D1FA      BNE         L_102  ; T=0x000007E0
  474:                 tBuf[3] = curTime;
 000007EA  4800      LDR         R0,=curTime ; curTime
 000007EC  6801      LDR         R1,[R0,#0x0] ; curTime
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 53  

 000007EE  4800      LDR         R0,=tBuf + 0xC ; tBuf+12
 000007F0  6001      STR         R1,[R0,#0x0] ; tBuf+12
  475:                 nStatus = statWaitPC;
 000007F2  2107      MOV         R1,#0x7
 000007F4  4800      LDR         R0,=nStatus ; nStatus
 000007F6  6001      STR         R1,[R0,#0x0] ; nStatus
  479:         }
 000007F8          L_102:
  481:         if (nStatus == statWaitPC)
 000007F8  4800      LDR         R0,=nStatus ; nStatus
 000007FA  6800      LDR         R0,[R0,#0x0] ; nStatus
 000007FC  2807      CMP         R0,#0x7
 000007FE  D10B      BNE         L_119  ; T=0x00000818
  483:             if (EOL == 1)
 00000800  2F01      CMP         R7,#0x1 ; EOL
 00000802  D109      BNE         L_119  ; T=0x00000818
  485:                 if (nBuffer[1] == cmdDataMicro)
 00000804  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 00000806  6800      LDR         R0,[R0,#0x0] ; nBuffer+4
 00000808  2826      CMP         R0,#0x26
 0000080A  D105      BNE         L_119  ; T=0x00000818
  487:                     Clock_Reset();
 0000080C  F7FF      BL          Clock_Reset?T  ; T=0x0001  (1)
 0000080E  FBF8      BL          Clock_Reset?T  ; T=0x0001  (2)
  488:                     curTime = 0;
 00000810  2100      MOV         R1,#0x0
 00000812  4800      LDR         R0,=curTime ; curTime
 00000814  6001      STR         R1,[R0,#0x0] ; curTime
  489:                     ReturnDataMicro();
 00000816  F7FF      BL          ReturnDataMicro?T  ; T=0x0001  (1)
 00000818  FBF3      BL          ReturnDataMicro?T  ; T=0x0001  (2)
  490:                     Clock_Reset();
 0000081A  F7FF      BL          Clock_Reset?T  ; T=0x0001  (1)
 0000081C  FBF1      BL          Clock_Reset?T  ; T=0x0001  (2)
  491:                     curTime = 0;
 0000081E  2100      MOV         R1,#0x0
 00000820  4800      LDR         R0,=curTime ; curTime
 00000822  6001      STR         R1,[R0,#0x0] ; curTime
  492:                     nStatus = statInit;
 00000824  2100      MOV         R1,#0x0
 00000826  4800      LDR         R0,=nStatus ; nStatus
 00000828  6001      STR         R1,[R0,#0x0] ; nStatus
  493:                     EOL = 0;
 0000082A  2700      MOV         R7,#0x0
  494:                     num = 0;
 0000082C  2000      MOV         R0,#0x0
 0000082E  9000      STR         R0,[R13,#0x0] ; num
  497:         }
 00000830          L_119:
  499:         curTime = Clock_GetTicks();
 00000830  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000832  FBE6      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000834  4800      LDR         R1,=curTime ; curTime
 00000836  6008      STR         R0,[R1,#0x0] ; curTime
  500:         Seconds = Clock_GetSeconds();
 00000838  F7FF      BL          Clock_GetSeconds?T  ; T=0x0001  (1)
 0000083A  FBE2      BL          Clock_GetSeconds?T  ; T=0x0001  (2)
 0000083C  9004      STR         R0,[R13,#0x10] ; Seconds
  501:         if ((Seconds & 0x01) > 0) ClrBitsPar(0x01); else SetBitsPar(0x01);
 0000083E  9804      LDR         R0,[R13,#0x10] ; Seconds
 00000840  2101      MOV         R1,#0x1
 00000842  4008      AND         R0,R1
 00000844  2800      CMP         R0,#0x0
 00000846  D9F7      BLS         L_122  ; T=0x00000838
 00000848  2001      MOV         R0,#0x1
 0000084A  F7FF      BL          ClrBitsPar?T  ; T=0x0001  (1)
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 54  

 0000084C  FBD9      BL          ClrBitsPar?T  ; T=0x0001  (2)
 0000084E  E7F6      B           L_123  ; T=0x0000083E
 00000850          L_122:
 00000850  2001      MOV         R0,#0x1
 00000852  F7FF      BL          SetBitsPar?T  ; T=0x0001  (1)
 00000854  FBD5      BL          SetBitsPar?T  ; T=0x0001  (2)
 00000856          L_123:
  502:         if (EOL == 1)
 00000856  2F01      CMP         R7,#0x1 ; EOL
 00000858  D001      BEQ         $ + 0x6  ; T=0x0000085E
 0000085A  F7FF      BL          L_61  ; T=0x002E  (1)
 0000085C  FBE8      BL          L_61  ; T=0x002E  (2)
  504:             if (nBuffer[1] == cmdReady)
 00000862  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 00000864  6800      LDR         R0,[R0,#0x0] ; nBuffer+4
 00000866  2801      CMP         R0,#0x1
 00000868  D105      BNE         L_125  ; T=0x00000876
  506:                 if ((nStatus == statWaitPC) || (nStatus == statRun))
 0000086A  4800      LDR         R0,=nStatus ; nStatus
 0000086C  6800      LDR         R0,[R0,#0x0] ; nStatus
 0000086E  2807      CMP         R0,#0x7
 00000870  D0F3      BEQ         L_127  ; T=0x0000085A
 00000872  2803      CMP         R0,#0x3
 00000874  D1F3      BNE         L_126  ; T=0x0000085E
 00000876          L_127:
  507:                     i = done;
 00000876  1C35      MOV         R5,R6 ; i
 00000878  E7F2      B           L_128  ; T=0x00000860
 0000087A          L_126:
  509:                      i = -1;
 0000087A  4800      LDR         R5,=0xFFFFFFFF
 0000087C          L_128:
  510:                 n = sprintf(outBuf,"%d\n",i); 
 0000087C  4800      LDR         R0,=outBuf ; outBuf
 0000087E  4800      LDR         R1,=??S_2 ; ??S_2
 00000880  1C2A      MOV         R2,R5
 00000882  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000884  FBBD      BL          sprintf?T  ; T=0x0001  (2)
 00000886  9003      STR         R0,[R13,#0xC] ; n
  511:                 i = UART0_Str(outBuf, n);
 00000888  4800      LDR         R0,=outBuf ; outBuf
 0000088A  9903      LDR         R1,[R13,#0xC] ; n
 0000088C  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 0000088E  FBB8      BL          UART0_Str?T  ; T=0x0001  (2)
 00000890  1C05      MOV         R5,R0 ; i
  512:             }
 00000892          L_125:
  513:             EOL = 0;
 00000892  2700      MOV         R7,#0x0
  514:             num = 0;
 00000894  2000      MOV         R0,#0x0
 00000896  9000      STR         R0,[R13,#0x0] ; num
  516:     }
 00000898  E3C9      B           L_61  ; T=0x0000102E
 0000089A            ; SCOPE-END
  519: }
 0000089A          L_57:
 0000089A  B005      ADD         R13,#0x14
 0000089C  BC08      POP         {R3}
 0000089E  4718      BX          R3
 000008A0          ENDP ; 'main'


*** CODE SEGMENT '?PR?InitAll?T?Human':
  521: int InitAll()
 00000000  B510      PUSH        {R4,LR}
 00000002  B081      SUB         R13,#0x4
  522: {
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 55  

 00000004            ; SCOPE-START
  526:     LPCinit();
 00000004  F7FF      BL          LPCinit?T  ; T=0x0001  (1)
 00000006  FFFC      BL          LPCinit?T  ; T=0x0001  (2)
  527:     IODIR0  = 0x00000FF0;   // P0.4-P0.11 as output bit 0..7
 00000008  4800      LDR         R1,=0xFF0
 0000000A  4800      LDR         R0,=0xE0028008
 0000000C  6001      STR         R1,[R0,#0x0]
  529:       IOSET0 |= 0x00000FF0; // LED off 
 0000000E  4800      LDR         R2,=0xFF0
 00000010  4800      LDR         R0,=0xE0028004
 00000012  6801      LDR         R1,[R0,#0x0]
 00000014  4311      ORR         R1,R2
 00000016  6001      STR         R1,[R0,#0x0]
  531:     Clock_Init();           // interrupt 0
 00000018  F7FF      BL          Clock_Init?T  ; T=0x0001  (1)
 0000001A  FFF2      BL          Clock_Init?T  ; T=0x0001  (2)
  532:     I2C_Init();             // interrupt 1
 0000001C  F7FF      BL          I2C_Init?T  ; T=0x0001  (1)
 0000001E  FFF0      BL          I2C_Init?T  ; T=0x0001  (2)
  533:     UART0_Init();           // interrupt 2
 00000020  F7FF      BL          UART0_Init?T  ; T=0x0001  (1)
 00000022  FFEE      BL          UART0_Init?T  ; T=0x0001  (2)
  534:        ADC_Init();              // interrupt 3, channel 0
 00000024  F7FF      BL          ADC_Init?T  ; T=0x0001  (1)
 00000026  FFEC      BL          ADC_Init?T  ; T=0x0001  (2)
  537:     for (n=0; n < 3; n++)
 00000028  2000      MOV         R0,#0x0
 0000002A  ---- Variable 'n' assigned to Register 'R0' ----
  539:         for (i=0; i < 4; i++)
 0000002A          L_138:
 0000002A  2400      MOV         R4,#0x0
 0000002C  ---- Variable 'i' assigned to Register 'R4' ----
 0000002C          L_137:
  541:             Leds[n][0][i].data    = 0; 
 0000002C  2100      MOV         R1,#0x0
 0000002E  220C      MOV         R2,#0xC
 00000030  4362      MUL         R2,R4 ; i
 00000032  2360      MOV         R3,#0x60
 00000034  4343      MUL         R3,R0 ; n
 00000036  189B      ADD         R3,R2 ; n
 00000038  4800      LDR         R2,=Leds + 0x4 ; Leds+4
 0000003A  50D1      STR         R1,[R2,R3]
  542:             Leds[n][0][i].level   = 0;
 0000003C  2100      MOV         R1,#0x0
 0000003E  4800      LDR         R2,=Leds + 0x8 ; Leds+8
 00000040  50D1      STR         R1,[R2,R3]
  543:             Leds[n][1][i].data    = 0; 
 00000042  2100      MOV         R1,#0x0
 00000044  220C      MOV         R2,#0xC
 00000046  4362      MUL         R2,R4 ; i
 00000048  2360      MOV         R3,#0x60
 0000004A  4343      MUL         R3,R0 ; n
 0000004C  189B      ADD         R3,R2 ; n
 0000004E  4800      LDR         R2,=Leds + 0x34 ; Leds+52
 00000050  50D1      STR         R1,[R2,R3]
  544:             Leds[n][1][i].level   = 0;
 00000052  2100      MOV         R1,#0x0
 00000054  220C      MOV         R2,#0xC
 00000056  4362      MUL         R2,R4 ; i
 00000058  2360      MOV         R3,#0x60
 0000005A  4343      MUL         R3,R0 ; n
 0000005C  189B      ADD         R3,R2 ; n
 0000005E  4800      LDR         R2,=Leds + 0x38 ; Leds+56
 00000060  50D1      STR         R1,[R2,R3]
  545:         }
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 56  

 00000062  3401      ADD         R4,#0x1
 00000064  2C04      CMP         R4,#0x4 ; i
 00000066  DBE1      BLT         L_137  ; T=0x0000002C
  546:     }
 00000068  3001      ADD         R0,#0x1
 0000006A  2803      CMP         R0,#0x3 ; n
 0000006C  DBDD      BLT         L_138  ; T=0x0000002A
  547:     for (i=0; i < 4; i++)
 0000006E  2400      MOV         R4,#0x0
 00000070          L_142:
  549:         Leds[0][0][i].address = 0xF7; // Voor 1-15
 00000070  20F7      MOV         R0,#0xF7
 00000072  220C      MOV         R2,#0xC
 00000074  4362      MUL         R2,R4 ; i
 00000076  4800      LDR         R1,=Leds ; Leds
 00000078  5088      STR         R0,[R1,R2]
  550:         Leds[0][1][i].address = 0xFB; // Voor 16-31
 0000007A  20FB      MOV         R0,#0xFB
 0000007C  4800      LDR         R1,=Leds + 0x30 ; Leds+48
 0000007E  5088      STR         R0,[R1,R2]
  551:         Leds[1][0][i].address = 0xFD; // Achter 101-115
 00000080  20FD      MOV         R0,#0xFD
 00000082  4800      LDR         R1,=Leds + 0x60 ; Leds+96
 00000084  5088      STR         R0,[R1,R2]
  552:         Leds[1][1][i].address = 0xFE; // Achter 116-129
 00000086  20FE      MOV         R0,#0xFE
 00000088  4800      LDR         R1,=Leds + 0x90 ; Leds+144
 0000008A  5088      STR         R0,[R1,R2]
  553:         Leds[2][0][i].address = 0x7F; // Voor 1-15 parallel voor blinken
 0000008C  207F      MOV         R0,#0x7F
 0000008E  4800      LDR         R1,=Leds + 0xC0 ; Leds+192
 00000090  5088      STR         R0,[R1,R2]
  554:         Leds[2][1][i].address = 0xBF; // Voor 16-31  parallel
 00000092  20BF      MOV         R0,#0xBF
 00000094  4800      LDR         R1,=Leds + 0xF0 ; Leds+240
 00000096  5088      STR         R0,[R1,R2]
  555:     }
 00000098  3401      ADD         R4,#0x1
 0000009A  2C04      CMP         R4,#0x4 ; i
 0000009C  DBE8      BLT         L_142  ; T=0x00000070
  558:     Sky[ 0].address  = 0x76;  Sky[ 0].data   = 0; Sky[ 0].level   = 0x00;
 0000009E  2176      MOV         R1,#0x76
 000000A0  4800      LDR         R0,=Sky ; Sky
 000000A2  6001      STR         R1,[R0,#0x0] ; Sky
 000000A4  2100      MOV         R1,#0x0
 000000A6  4800      LDR         R0,=Sky + 0x4 ; Sky+4
 000000A8  6001      STR         R1,[R0,#0x0] ; Sky+4
 000000AA  2100      MOV         R1,#0x0
 000000AC  4800      LDR         R0,=Sky + 0x8 ; Sky+8
 000000AE  6001      STR         R1,[R0,#0x0] ; Sky+8
  559:     Sky[ 1].address  = 0x74;  Sky[ 1].data   = 0; Sky[ 1].level   = 0x00;
 000000B0  2174      MOV         R1,#0x74
 000000B2  4800      LDR         R0,=Sky + 0xC ; Sky+12
 000000B4  6001      STR         R1,[R0,#0x0] ; Sky+12
 000000B6  2100      MOV         R1,#0x0
 000000B8  4800      LDR         R0,=Sky + 0x10 ; Sky+16
 000000BA  6001      STR         R1,[R0,#0x0] ; Sky+16
 000000BC  2100      MOV         R1,#0x0
 000000BE  4800      LDR         R0,=Sky + 0x14 ; Sky+20
 000000C0  6001      STR         R1,[R0,#0x0] ; Sky+20
  560:     Sky[ 2].address  = 0x74;  Sky[ 2].data   = 0; Sky[ 2].level   = 0x00;
 000000C2  2174      MOV         R1,#0x74
 000000C4  4800      LDR         R0,=Sky + 0x18 ; Sky+24
 000000C6  6001      STR         R1,[R0,#0x0] ; Sky+24
 000000C8  2100      MOV         R1,#0x0
 000000CA  4800      LDR         R0,=Sky + 0x1C ; Sky+28
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 57  

 000000CC  6001      STR         R1,[R0,#0x0] ; Sky+28
 000000CE  2100      MOV         R1,#0x0
 000000D0  4800      LDR         R0,=Sky + 0x20 ; Sky+32
 000000D2  6001      STR         R1,[R0,#0x0] ; Sky+32
  561:     Sky[ 3].address  = 0x74;  Sky[ 3].data   = 0; Sky[ 3].level   = 0x00;
 000000D4  2174      MOV         R1,#0x74
 000000D6  4800      LDR         R0,=Sky + 0x24 ; Sky+36
 000000D8  6001      STR         R1,[R0,#0x0] ; Sky+36
 000000DA  2100      MOV         R1,#0x0
 000000DC  4800      LDR         R0,=Sky + 0x28 ; Sky+40
 000000DE  6001      STR         R1,[R0,#0x0] ; Sky+40
 000000E0  2100      MOV         R1,#0x0
 000000E2  4800      LDR         R0,=Sky + 0x2C ; Sky+44
 000000E4  6001      STR         R1,[R0,#0x0] ; Sky+44
  562:     Sky[ 4].address  = 0x74;  Sky[ 4].data   = 0; Sky[ 4].level   = 0x00;
 000000E6  2174      MOV         R1,#0x74
 000000E8  4800      LDR         R0,=Sky + 0x30 ; Sky+48
 000000EA  6001      STR         R1,[R0,#0x0] ; Sky+48
 000000EC  2100      MOV         R1,#0x0
 000000EE  4800      LDR         R0,=Sky + 0x34 ; Sky+52
 000000F0  6001      STR         R1,[R0,#0x0] ; Sky+52
 000000F2  2100      MOV         R1,#0x0
 000000F4  4800      LDR         R0,=Sky + 0x38 ; Sky+56
 000000F6  6001      STR         R1,[R0,#0x0] ; Sky+56
  563:     Sky[ 5].address  = 0x74;  Sky[ 5].data   = 0; Sky[ 5].level   = 0x00;
 000000F8  2174      MOV         R1,#0x74
 000000FA  4800      LDR         R0,=Sky + 0x3C ; Sky+60
 000000FC  6001      STR         R1,[R0,#0x0] ; Sky+60
 000000FE  2100      MOV         R1,#0x0
 00000100  4800      LDR         R0,=Sky + 0x40 ; Sky+64
 00000102  6001      STR         R1,[R0,#0x0] ; Sky+64
 00000104  2100      MOV         R1,#0x0
 00000106  4800      LDR         R0,=Sky + 0x44 ; Sky+68
 00000108  6001      STR         R1,[R0,#0x0] ; Sky+68
  564:     Sky[ 6].address  = 0x74;  Sky[ 6].data   = 0; Sky[ 6].level   = 0x00;
 0000010A  2174      MOV         R1,#0x74
 0000010C  4800      LDR         R0,=Sky + 0x48 ; Sky+72
 0000010E  6001      STR         R1,[R0,#0x0] ; Sky+72
 00000110  2100      MOV         R1,#0x0
 00000112  4800      LDR         R0,=Sky + 0x4C ; Sky+76
 00000114  6001      STR         R1,[R0,#0x0] ; Sky+76
 00000116  2100      MOV         R1,#0x0
 00000118  4800      LDR         R0,=Sky + 0x50 ; Sky+80
 0000011A  6001      STR         R1,[R0,#0x0] ; Sky+80
  565:     Sky[ 7].address  = 0x74;  Sky[ 7].data   = 0; Sky[ 7].level   = 0x00;
 0000011C  2174      MOV         R1,#0x74
 0000011E  4800      LDR         R0,=Sky + 0x54 ; Sky+84
 00000120  6001      STR         R1,[R0,#0x0] ; Sky+84
 00000122  2100      MOV         R1,#0x0
 00000124  4800      LDR         R0,=Sky + 0x58 ; Sky+88
 00000126  6001      STR         R1,[R0,#0x0] ; Sky+88
 00000128  2100      MOV         R1,#0x0
 0000012A  4800      LDR         R0,=Sky + 0x5C ; Sky+92
 0000012C  6001      STR         R1,[R0,#0x0] ; Sky+92
  566:     Sky[ 8].address  = 0x74;  Sky[ 8].data   = 0; Sky[ 8].level   = 0x00;
 0000012E  2174      MOV         R1,#0x74
 00000130  4800      LDR         R0,=Sky + 0x60 ; Sky+96
 00000132  6001      STR         R1,[R0,#0x0] ; Sky+96
 00000134  2100      MOV         R1,#0x0
 00000136  4800      LDR         R0,=Sky + 0x64 ; Sky+100
 00000138  6001      STR         R1,[R0,#0x0] ; Sky+100
 0000013A  2100      MOV         R1,#0x0
 0000013C  4800      LDR         R0,=Sky + 0x68 ; Sky+104
 0000013E  6001      STR         R1,[R0,#0x0] ; Sky+104
  567:     Sky[ 9].address  = 0x76;  Sky[ 9].data   = 0; Sky[ 9].level   = 0x00;
 00000140  2176      MOV         R1,#0x76
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 58  

 00000142  4800      LDR         R0,=Sky + 0x6C ; Sky+108
 00000144  6001      STR         R1,[R0,#0x0] ; Sky+108
 00000146  2100      MOV         R1,#0x0
 00000148  4800      LDR         R0,=Sky + 0x70 ; Sky+112
 0000014A  6001      STR         R1,[R0,#0x0] ; Sky+112
 0000014C  2100      MOV         R1,#0x0
 0000014E  4800      LDR         R0,=Sky + 0x74 ; Sky+116
 00000150  6001      STR         R1,[R0,#0x0] ; Sky+116
  568:     Sky[10].address  = 0x76;  Sky[10].data   = 0; Sky[10].level   = 0x00;
 00000152  2176      MOV         R1,#0x76
 00000154  4800      LDR         R0,=Sky + 0x78 ; Sky+120
 00000156  6001      STR         R1,[R0,#0x0] ; Sky+120
 00000158  2100      MOV         R1,#0x0
 0000015A  4800      LDR         R0,=Sky + 0x7C ; Sky+124
 0000015C  6001      STR         R1,[R0,#0x0] ; Sky+124
 0000015E  2100      MOV         R1,#0x0
 00000160  4800      LDR         R0,=Sky + 0x80 ; Sky+128
 00000162  6001      STR         R1,[R0,#0x0] ; Sky+128
  569:     Sky[11].address  = 0x76;  Sky[11].data   = 0; Sky[11].level   = 0x00;
 00000164  2176      MOV         R1,#0x76
 00000166  4800      LDR         R0,=Sky + 0x84 ; Sky+132
 00000168  6001      STR         R1,[R0,#0x0] ; Sky+132
 0000016A  2100      MOV         R1,#0x0
 0000016C  4800      LDR         R0,=Sky + 0x88 ; Sky+136
 0000016E  6001      STR         R1,[R0,#0x0] ; Sky+136
 00000170  2100      MOV         R1,#0x0
 00000172  4800      LDR         R0,=Sky + 0x8C ; Sky+140
 00000174  6001      STR         R1,[R0,#0x0] ; Sky+140
  570:     Sky[12].address  = 0x76;  Sky[12].data   = 0; Sky[12].level   = 0x00;
 00000176  2176      MOV         R1,#0x76
 00000178  4800      LDR         R0,=Sky + 0x90 ; Sky+144
 0000017A  6001      STR         R1,[R0,#0x0] ; Sky+144
 0000017C  2100      MOV         R1,#0x0
 0000017E  4800      LDR         R0,=Sky + 0x94 ; Sky+148
 00000180  6001      STR         R1,[R0,#0x0] ; Sky+148
 00000182  2100      MOV         R1,#0x0
 00000184  4800      LDR         R0,=Sky + 0x98 ; Sky+152
 00000186  6001      STR         R1,[R0,#0x0] ; Sky+152
  571:     ClearSky();
 00000188  F7FF      BL          ClearSky?T  ; T=0x0001  (1)
 0000018A  FF3A      BL          ClearSky?T  ; T=0x0001  (2)
  572:     ClearArc();
 0000018C  F7FF      BL          ClearArc?T  ; T=0x0001  (1)
 0000018E  FF38      BL          ClearArc?T  ; T=0x0001  (2)
  574:     buffer[0] = 0x00;
 00000190  2100      MOV         R1,#0x0
 00000192  A800      ADD         R0,R13,#0x0
 00000194  7001      STRB        R1,[R0,#0x0] ; buffer
  575:     buffer[1] = 0x76;
 00000196  2176      MOV         R1,#0x76
 00000198  2001      MOV         R0,#0x1
 0000019A  4468      ADD         R0,R13
 0000019C  7001      STRB        R1,[R0,#0x0] ; buffer+1
  576:     buffer[2] = 0x00;                                                          
 0000019E  2100      MOV         R1,#0x0
 000001A0  2002      MOV         R0,#0x2
 000001A2  4468      ADD         R0,R13
 000001A4  7001      STRB        R1,[R0,#0x0] ; buffer+2
  577:     buffer[3] = 0x00;
 000001A6  2100      MOV         R1,#0x0
 000001A8  2003      MOV         R0,#0x3
 000001AA  4468      ADD         R0,R13
 000001AC  7001      STRB        R1,[R0,#0x0] ; buffer+3
  578:     I2C_SendByte(0x70, 4, buffer);
 000001AE  AA00      ADD         R2,R13,#0x0
 000001B0  2070      MOV         R0,#0x70
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 59  

 000001B2  2104      MOV         R1,#0x4
 000001B4  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 000001B6  FF24      BL          I2C_SendByte?T  ; T=0x0001  (2)
  580:     for (i=0; i < 8; i++)
 000001B8  2400      MOV         R4,#0x0
 000001BA          L_147:
  582:         buffer[0] = boards[i];
 000001BA  00A1      LSL         R1,R4,#0x2 ; i
 000001BC  4800      LDR         R0,=boards ; boards
 000001BE  5841      LDR         R1,[R0,R1]
 000001C0  A800      ADD         R0,R13,#0x0
 000001C2  7001      STRB        R1,[R0,#0x0] ; buffer
  583:         I2C_SendByte(0x4E, 1, buffer);
 000001C4  AA00      ADD         R2,R13,#0x0
 000001C6  204E      MOV         R0,#0x4E
 000001C8  2101      MOV         R1,#0x1
 000001CA  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 000001CC  FF19      BL          I2C_SendByte?T  ; T=0x0001  (2)
  584:         buffer[0] = 0xFF;
 000001CE  21FF      MOV         R1,#0xFF
 000001D0  A800      ADD         R0,R13,#0x0
 000001D2  7001      STRB        R1,[R0,#0x0] ; buffer
  585:         I2C_SendByte(0x42, 1, buffer);
 000001D4  AA00      ADD         R2,R13,#0x0
 000001D6  2042      MOV         R0,#0x42
 000001D8  2101      MOV         R1,#0x1
 000001DA  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 000001DC  FF11      BL          I2C_SendByte?T  ; T=0x0001  (2)
  586:         I2C_SendByte(0x44, 1, buffer);
 000001DE  AA00      ADD         R2,R13,#0x0
 000001E0  2044      MOV         R0,#0x44
 000001E2  2101      MOV         R1,#0x1
 000001E4  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 000001E6  FF0C      BL          I2C_SendByte?T  ; T=0x0001  (2)
  587:         statusBoards[i][0] = 0xFF;  
 000001E8  20FF      MOV         R0,#0xFF
 000001EA  220C      MOV         R2,#0xC
 000001EC  4362      MUL         R2,R4 ; i
 000001EE  4800      LDR         R1,=statusBoards ; statusBoards
 000001F0  5088      STR         R0,[R1,R2]
  588:         statusBoards[i][1] = 0xFF;  
 000001F2  20FF      MOV         R0,#0xFF
 000001F4  4800      LDR         R1,=statusBoards + 0x4 ; statusBoards+4
 000001F6  5088      STR         R0,[R1,R2]
  589:         statusBoards[i][2] = 0xFF;  
 000001F8  20FF      MOV         R0,#0xFF
 000001FA  4800      LDR         R1,=statusBoards + 0x8 ; statusBoards+8
 000001FC  5088      STR         R0,[R1,R2]
  590:     }
 000001FE  3401      ADD         R4,#0x1
 00000200  2C08      CMP         R4,#0x8 ; i
 00000202  DBDA      BLT         L_147  ; T=0x000001BA
  591:     ClrBitsPar(outRP2_1);  // sound trigger
 00000204  2002      MOV         R0,#0x2
 00000206  F7FF      BL          ClrBitsPar?T  ; T=0x0001  (1)
 00000208  FEFB      BL          ClrBitsPar?T  ; T=0x0001  (2)
  592:     ClrBitsPar(outRP2_2);  // sound trigger
 0000020A  2004      MOV         R0,#0x4
 0000020C  F7FF      BL          ClrBitsPar?T  ; T=0x0001  (1)
 0000020E  FEF8      BL          ClrBitsPar?T  ; T=0x0001  (2)
  593:     ClrBitsPar(outRA16);   // acq   trigger
 00000210  2008      MOV         R0,#0x8
 00000212  F7FF      BL          ClrBitsPar?T  ; T=0x0001  (1)
 00000214  FEF5      BL          ClrBitsPar?T  ; T=0x0001  (2)
  595:     return(0);
 00000216  2000      MOV         R0,#0x0
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 60  

 00000218            ; SCOPE-END
  596: }
 00000218  B001      ADD         R13,#0x4
 0000021A  BC10      POP         {R4}
 0000021C  BC08      POP         {R3}
 0000021E  4718      BX          R3
 00000220          ENDP ; 'InitAll?T'


*** CODE SEGMENT '?PR?getWord?T?Human':
  597: void getWord(void) 
 00000000  B410      PUSH        {R4}
  598: {
 00000002            ; SCOPE-START
  599:     int pnt = 0;
 00000002  2400      MOV         R4,#0x0
 00000004  ---- Variable 'pnt' assigned to Register 'R4' ----
  600:     while ((inBuf[inpPnt] != ';') && (inBuf[inpPnt] != '\0'))
 00000004  E00A      B           L_150  ; T=0x0000001C
 00000006          L_152:
  602:         wrd[pnt++] = inBuf[inpPnt++];
 00000006  4800      LDR         R0,=inpPnt ; inpPnt
 00000008  6801      LDR         R1,[R0,#0x0] ; inpPnt
 0000000A  1C0A      MOV         R2,R1
 0000000C  3201      ADD         R2,#0x1
 0000000E  6002      STR         R2,[R0,#0x0] ; inpPnt
 00000010  4800      LDR         R0,=inBuf ; inBuf
 00000012  5C40      LDRB        R0,[R0,R1]
 00000014  1C22      MOV         R2,R4 ; pnt
 00000016  3401      ADD         R4,#0x1
 00000018  4800      LDR         R1,=wrd ; wrd
 0000001A  5488      STRB        R0,[R1,R2]
  603:     }
 0000001C          L_150:
 0000001C  4800      LDR         R0,=inpPnt ; inpPnt
 0000001E  6801      LDR         R1,[R0,#0x0] ; inpPnt
 00000020  4800      LDR         R0,=inBuf ; inBuf
 00000022  5C40      LDRB        R0,[R0,R1]
 00000024  283B      CMP         R0,#0x3B
 00000026  D001      BEQ         L_151  ; T=0x0000002C
 00000028  2800      CMP         R0,#0x0
 0000002A  D1EC      BNE         L_152  ; T=0x00000006
 0000002C          L_151:
  604:     wrd[pnt] = '\0';
 0000002C  2200      MOV         R2,#0x0
 0000002E  4800      LDR         R3,=wrd ; wrd
 00000030  551A      STRB        R2,[R3,R4]
  605:     if (inBuf[inpPnt] == '\0') inpPnt = -1; else inpPnt++;
 00000032  2800      CMP         R0,#0x0
 00000034  D103      BNE         L_155  ; T=0x0000003E
 00000036  4800      LDR         R2,=0xFFFFFFFF
 00000038  4800      LDR         R0,=inpPnt ; inpPnt
 0000003A  6002      STR         R2,[R0,#0x0] ; inpPnt
 0000003C  E002      B           L_156  ; T=0x00000044
 0000003E          L_155:
 0000003E  4800      LDR         R0,=inpPnt ; inpPnt
 00000040  3101      ADD         R1,#0x1
 00000042  6001      STR         R1,[R0,#0x0] ; inpPnt
 00000044          L_156:
 00000044            ; SCOPE-END
  606: }
 00000044  BC10      POP         {R4}
 00000046  4770      BX          R14
 00000048          ENDP ; 'getWord?T'


*** CODE SEGMENT '?PR?getVal?T?Human':
  608: int getVal(void) 
 00000000  B410      PUSH        {R4}
  609: {
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 61  

 00000002            ; SCOPE-START
  610:     int val = 0;
 00000002  2000      MOV         R0,#0x0
 00000004  ---- Variable 'val' assigned to Register 'R0' ----
  611:     int pnt = 0;
 00000004  2100      MOV         R1,#0x0
 00000006  ---- Variable 'pnt' assigned to Register 'R1' ----
  612:     if (wrd[0] == '-')
 00000006  4800      LDR         R2,=wrd ; wrd
 00000008  7812      LDRB        R2,[R2,#0x0] ; wrd
 0000000A  2A2D      CMP         R2,#0x2D
 0000000C  D113      BNE         L_157  ; T=0x00000036
  614:         val = -1*(wrd[1] - '0');
 0000000E  4800      LDR         R0,=wrd + 0x1 ; wrd+1
 00000010  7800      LDRB        R0,[R0,#0x0] ; wrd+1
 00000012  3830      SUB         R0,#0x30
 00000014  4800      LDR         R1,=0xFFFFFFFF
 00000016  4348      MUL         R0,R1
  615:         pnt = 2;
 00000018  2102      MOV         R1,#0x2
  616:         while (wrd[pnt] != '\0')
 0000001A  E007      B           L_158  ; T=0x0000002C
 0000001C          L_160:
  618:             val *= 10;
 0000001C  230A      MOV         R3,#0xA
 0000001E  4358      MUL         R0,R3
  619:             val -= wrd[pnt++] - '0';
 00000020  1C0C      MOV         R4,R1 ; pnt
 00000022  3101      ADD         R1,#0x1
 00000024  4800      LDR         R3,=wrd ; wrd
 00000026  5D1B      LDRB        R3,[R3,R4]
 00000028  3B30      SUB         R3,#0x30
 0000002A  1AC0      SUB         R0,R3 ; val
  620:         }
 0000002C          L_158:
 0000002C  4800      LDR         R3,=wrd ; wrd
 0000002E  5C5B      LDRB        R3,[R3,R1]
 00000030  2B00      CMP         R3,#0x0
 00000032  D1F3      BNE         L_160  ; T=0x0000001C
  621:     }
 00000034  E00F      B           L_162  ; T=0x00000056
 00000036          L_157:
  624:         val = (wrd[0]- '0');
 00000036  1C10      MOV         R0,R2
 00000038  3830      SUB         R0,#0x30
  625:         pnt = 1;
 0000003A  2101      MOV         R1,#0x1
  626:         while (wrd[pnt] != '\0')
 0000003C  E007      B           L_163  ; T=0x0000004E
 0000003E          L_165:
  628:             val *= 10;
 0000003E  220A      MOV         R2,#0xA
 00000040  4350      MUL         R0,R2
  629:             val += wrd[pnt++] - '0';
 00000042  1C0B      MOV         R3,R1 ; pnt
 00000044  3101      ADD         R1,#0x1
 00000046  4800      LDR         R2,=wrd ; wrd
 00000048  5CD2      LDRB        R2,[R2,R3]
 0000004A  3A30      SUB         R2,#0x30
 0000004C  1880      ADD         R0,R2 ; val
  630:         }
 0000004E          L_163:
 0000004E  4800      LDR         R2,=wrd ; wrd
 00000050  5C52      LDRB        R2,[R2,R1]
 00000052  2A00      CMP         R2,#0x0
 00000054  D1F3      BNE         L_165  ; T=0x0000003E
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 62  

  631:     }
 00000056          L_162:
  632:     return val;
 00000056            ; SCOPE-END
  633: }
 00000056  BC10      POP         {R4}
 00000058  4770      BX          R14
 0000005A          ENDP ; 'getVal?T'


*** CODE SEGMENT '?PR?splitInput?T?Human':
  635: void splitInput(void)                   
 00000000  B500      PUSH        {LR}
  637:     outPnt = 0;
 00000002  2100      MOV         R1,#0x0
 00000004  4800      LDR         R0,=outPnt ; outPnt
 00000006  6001      STR         R1,[R0,#0x0] ; outPnt
  638:     if (inBuf[0] == '$')
 00000008  4800      LDR         R0,=inBuf ; inBuf
 0000000A  7800      LDRB        R0,[R0,#0x0] ; inBuf
 0000000C  2824      CMP         R0,#0x24
 0000000E  D117      BNE         L_168  ; T=0x00000040
  640:         inpPnt = 1;
 00000010  2101      MOV         R1,#0x1
 00000012  4800      LDR         R0,=inpPnt ; inpPnt
 00000014  6001      STR         R1,[R0,#0x0] ; inpPnt
  641:         outPnt = 1;
 00000016  2101      MOV         R1,#0x1
 00000018  4800      LDR         R0,=outPnt ; outPnt
 0000001A  6001      STR         R1,[R0,#0x0] ; outPnt
  642:         while (inpPnt != -1)
 0000001C  E00B      B           L_169  ; T=0x00000036
 0000001E          L_171:
  644:             getWord();
 0000001E  F7FF      BL          getWord?T  ; T=0x0001  (1)
 00000020  FFEF      BL          getWord?T  ; T=0x0001  (2)
  645:             nBuffer[outPnt++] = getVal();
 00000022  F7FF      BL          getVal?T  ; T=0x0001  (1)
 00000024  FFED      BL          getVal?T  ; T=0x0001  (2)
 00000026  4800      LDR         R1,=outPnt ; outPnt
 00000028  680A      LDR         R2,[R1,#0x0] ; outPnt
 0000002A  1C13      MOV         R3,R2
 0000002C  3301      ADD         R3,#0x1
 0000002E  600B      STR         R3,[R1,#0x0] ; outPnt
 00000030  0092      LSL         R2,R2,#0x2
 00000032  4800      LDR         R1,=nBuffer ; nBuffer
 00000034  5088      STR         R0,[R1,R2]
  646:         }
 00000036          L_169:
 00000036  4800      LDR         R0,=inpPnt ; inpPnt
 00000038  6800      LDR         R0,[R0,#0x0] ; inpPnt
 0000003A  2101      MOV         R1,#0x1
 0000003C  42C8      CMN         R0,R1
 0000003E  D1EE      BNE         L_171  ; T=0x0000001E
  647:     }
 00000040          L_168:
  648:     nBuffer[0] = outPnt-1;
 00000040  4800      LDR         R0,=outPnt ; outPnt
 00000042  6801      LDR         R1,[R0,#0x0] ; outPnt
 00000044  3901      SUB         R1,#0x1
 00000046  4800      LDR         R0,=nBuffer ; nBuffer
 00000048  6001      STR         R1,[R0,#0x0] ; nBuffer
  649: }
 0000004A  BC08      POP         {R3}
 0000004C  4718      BX          R3
 0000004E          ENDP ; 'splitInput?T'


*** CODE SEGMENT '?PR?ReturnInfo?T?Human':
  651: void ReturnInfo(void)
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 63  

 00000000  B500      PUSH        {LR}
  652: {
 00000002            ; SCOPE-START
  655:     n = 0;
 00000002  2100      MOV         R1,#0x0
 00000004  ---- Variable 'n' assigned to Register 'R1' ----
  656:     while ((n < 80) && (version[n] > 0)) n++;
 00000004  E000      B           L_173  ; T=0x00000008
 00000006          L_175:
 00000006  3101      ADD         R1,#0x1
 00000008          L_173:
 00000008  2950      CMP         R1,#0x50 ; n
 0000000A  DA03      BGE         L_174  ; T=0x00000014
 0000000C  4800      LDR         R0,=version ; version
 0000000E  5C40      LDRB        R0,[R0,R1]
 00000010  2800      CMP         R0,#0x0
 00000012  DCF8      BGT         L_175  ; T=0x00000006
 00000014          L_174:
  657:     i = UART0_Str(version, n);
 00000014  4800      LDR         R0,=version ; version
 00000016  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000018  FFF3      BL          UART0_Str?T  ; T=0x0001  (2)
  658:     nBuffer[1] = 0;
 0000001A  2100      MOV         R1,#0x0
 0000001C  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 0000001E  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 00000020            ; SCOPE-END
  659: }
 00000020  BC08      POP         {R3}
 00000022  4718      BX          R3
 00000024          ENDP ; 'ReturnInfo?T'


*** CODE SEGMENT '?PR?GetSamples?T?Human':
  661:  void GetSamples(void)                 
 00000000  B510      PUSH        {R4,LR}
 00000002  B088      SUB         R13,#0x20
  662: {
 00000004            ; SCOPE-START
  665:     start = Clock_GetTicks();
 00000004  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000006  FFFC      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000008  1C04      MOV         R4,R0 ; start
 0000000A  ---- Variable 'start' assigned to Register 'R4' ----
  666:      buffer  = ADC_GetSamples();
 0000000A  A800      ADD         R0,R13,#0x0
 0000000C  F7FF      BL          ADC_GetSamples?T  ; T=0x0001  (1)
 0000000E  FFF8      BL          ADC_GetSamples?T  ; T=0x0001  (2)
  667:     n = sprintf(outBuf,"%d;%d;%d;%d;%d\n",start, 
 00000010  9803      LDR         R0,[R13,#0xC] ; buffer
 00000012  B401      PUSH        {R0}
 00000014  9803      LDR         R0,[R13,#0xC] ; buffer
 00000016  B401      PUSH        {R0}
 00000018  9803      LDR         R0,[R13,#0xC] ; buffer
 0000001A  B401      PUSH        {R0}
 0000001C  4800      LDR         R0,=outBuf ; outBuf
 0000001E  4800      LDR         R1,=??S_3 ; ??S_3
 00000020  1C22      MOV         R2,R4
 00000022  9B03      LDR         R3,[R13,#0xC] ; buffer
 00000024  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000026  FFEC      BL          sprintf?T  ; T=0x0001  (2)
 00000028  B003      ADD         R13,#0xC
 0000002A  1C01      MOV         R1,R0 ; n
 0000002C  ---- Variable 'n' assigned to Register 'R1' ----
  669:     i = UART0_Str(outBuf, n);
 0000002C  4800      LDR         R0,=outBuf ; outBuf
 0000002E  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000030  FFE7      BL          UART0_Str?T  ; T=0x0001  (2)
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 64  

 00000032            ; SCOPE-END
  670: }
 00000032  B008      ADD         R13,#0x20
 00000034  BC10      POP         {R4}
 00000036  BC08      POP         {R3}
 00000038  4718      BX          R3
 0000003A          ENDP ; 'GetSamples?T'


*** CODE SEGMENT '?PR?ChannelOn?T?Human':
  672: void ChannelOn(void)
 00000000  B500      PUSH        {LR}
  674:     ADC_Select(nBuffer[2]);
 00000002  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 00000004  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 00000006  F7FF      BL          ADC_Select?T  ; T=0x0001  (1)
 00000008  FFFB      BL          ADC_Select?T  ; T=0x0001  (2)
  675: }
 0000000A  BC08      POP         {R3}
 0000000C  4718      BX          R3
 0000000E          ENDP ; 'ChannelOn?T'


*** CODE SEGMENT '?PR?ChannelOff?T?Human':
  677: void ChannelOff(void)
 00000000  B500      PUSH        {LR}
  679:     ADC_Select(-1*nBuffer[2]);
 00000002  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 00000004  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 00000006  4800      LDR         R1,=0xFFFFFFFF
 00000008  4348      MUL         R0,R1
 0000000A  F7FF      BL          ADC_Select?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          ADC_Select?T  ; T=0x0001  (2)
  680: }
 0000000E  BC08      POP         {R3}
 00000010  4718      BX          R3
 00000012          ENDP ; 'ChannelOff?T'


*** CODE SEGMENT '?PR?GetPIO?T?Human':
  681: void GetPIO(void)
 00000000  B500      PUSH        {LR}
  682: {
 00000002            ; SCOPE-START
  685:     val = GetBitsPar();
 00000002  F7FF      BL          GetBitsPar?T  ; T=0x0001  (1)
 00000004  FFFD      BL          GetBitsPar?T  ; T=0x0001  (2)
 00000006  1C02      MOV         R2,R0 ; val
 00000008  ---- Variable 'val' assigned to Register 'R2' ----
  686:     n = sprintf(outBuf,"%d\n",val);
 00000008  4800      LDR         R0,=outBuf ; outBuf
 0000000A  4800      LDR         R1,=??S_2 ; ??S_2
 0000000C  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 0000000E  FFF8      BL          sprintf?T  ; T=0x0001  (2)
 00000010  1C01      MOV         R1,R0 ; n
 00000012  ---- Variable 'n' assigned to Register 'R1' ----
  687:     i = UART0_Str(outBuf, n);
 00000012  4800      LDR         R0,=outBuf ; outBuf
 00000014  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000016  FFF4      BL          UART0_Str?T  ; T=0x0001  (2)
 00000018            ; SCOPE-END
  688: }
 00000018  BC08      POP         {R3}
 0000001A  4718      BX          R3
 0000001C          ENDP ; 'GetPIO?T'


*** CODE SEGMENT '?PR?Trigger?T?Human':
  690: void Trigger(int bit, int Up)
 00000000  B510      PUSH        {R4,LR}
 00000002  ---- Variable 'Up' assigned to Register 'R1' ----
 00000002  1C04      MOV         R4,R0 ; bit
 00000004  ---- Variable 'bit' assigned to Register 'R4' ----
  692:     if (Up == true)
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 65  

 00000004  2901      CMP         R1,#0x1 ; Up
 00000006  D109      BNE         L_178  ; T=0x0000001C
  694:         SetBitsPar(bit);
 00000008  1C20      MOV         R0,R4
 0000000A  F7FF      BL          SetBitsPar?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          SetBitsPar?T  ; T=0x0001  (2)
  695:         Delay(10000);            // 10000 ca 1.5 mSec
 0000000E  4800      LDR         R0,=0x2710
 00000010  F7FF      BL          Delay?T  ; T=0x0001  (1)
 00000012  FFF6      BL          Delay?T  ; T=0x0001  (2)
  696:         ClrBitsPar(bit);
 00000014  1C20      MOV         R0,R4
 00000016  F7FF      BL          ClrBitsPar?T  ; T=0x0001  (1)
 00000018  FFF3      BL          ClrBitsPar?T  ; T=0x0001  (2)
  697:     }
 0000001A  E008      B           L_179  ; T=0x0000002E
 0000001C          L_178:
  700:         ClrBitsPar(bit);
 0000001C  1C20      MOV         R0,R4
 0000001E  F7FF      BL          ClrBitsPar?T  ; T=0x0001  (1)
 00000020  FFEF      BL          ClrBitsPar?T  ; T=0x0001  (2)
  701:         Delay(10000);            
 00000022  4800      LDR         R0,=0x2710
 00000024  F7FF      BL          Delay?T  ; T=0x0001  (1)
 00000026  FFEC      BL          Delay?T  ; T=0x0001  (2)
  702:         SetBitsPar(bit);
 00000028  1C20      MOV         R0,R4
 0000002A  F7FF      BL          SetBitsPar?T  ; T=0x0001  (1)
 0000002C  FFE9      BL          SetBitsPar?T  ; T=0x0001  (2)
  703:     }
 0000002E          L_179:
  704: }
 0000002E  BC10      POP         {R4}
 00000030  BC08      POP         {R3}
 00000032  4718      BX          R3
 00000034          ENDP ; 'Trigger?T'


*** CODE SEGMENT '?PR?SetBitsPar?T?Human':
  706: void SetBitsPar(int i)
 00000000  ---- Variable 'i' assigned to Register 'R0' ----
  708:     IOSET0 = (i & 0xFF) << 4;          
 00000000  21FF      MOV         R1,#0xFF
 00000002  4001      AND         R1,R0 ; i
 00000004  0109      LSL         R1,R1,#0x4
 00000006  4800      LDR         R0,=0xE0028004
 00000008  6001      STR         R1,[R0,#0x0]
  709: }
 0000000A  4770      BX          R14
 0000000C          ENDP ; 'SetBitsPar?T'


*** CODE SEGMENT '?PR?ClrBitsPar?T?Human':
  712: void ClrBitsPar(int i)
 00000000  ---- Variable 'i' assigned to Register 'R0' ----
  714:     IOCLR0 = (i & 0xFF) << 4;
 00000000  21FF      MOV         R1,#0xFF
 00000002  4001      AND         R1,R0 ; i
 00000004  0109      LSL         R1,R1,#0x4
 00000006  4800      LDR         R0,=0xE002800C
 00000008  6001      STR         R1,[R0,#0x0]
  715: }
 0000000A  4770      BX          R14
 0000000C          ENDP ; 'ClrBitsPar?T'


*** CODE SEGMENT '?PR?GetBitsPar?T?Human':
  718: {
 00000000            ; SCOPE-START
  720:     i = (IOPIN0 >> 17) & 0x00FF;
 00000000  4800      LDR         R0,=0xE0028000
 00000002  6800      LDR         R0,[R0,#0x0]
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 66  

 00000004  0C40      LSR         R0,R0,#0x11
 00000006  21FF      MOV         R1,#0xFF
 00000008  4008      AND         R0,R1
 0000000A  ---- Variable 'i' assigned to Register 'R0' ----
  721:     return i;
 0000000A            ; SCOPE-END
  722: }
 0000000A  4770      BX          R14
 0000000C          ENDP ; 'GetBitsPar?T'


*** CODE SEGMENT '?PR?TstBitPar?T?Human':
  724: int TstBitPar(int bit)
 00000000  B510      PUSH        {R4,LR}
 00000002  1C04      MOV         R4,R0 ; bit
 00000004  ---- Variable 'bit' assigned to Register 'R4' ----
  725: {
 00000004            ; SCOPE-START
  727:     i = GetBitsPar();
 00000004  F7FF      BL          GetBitsPar?T  ; T=0x0001  (1)
 00000006  FFFC      BL          GetBitsPar?T  ; T=0x0001  (2)
 00000008  1C01      MOV         R1,R0 ; i
 0000000A  ---- Variable 'i' assigned to Register 'R1' ----
  728:     i = (i & bit);
 0000000A  4021      AND         R1,R4 ; bit
  730:     return i;
 0000000C  1C08      MOV         R0,R1 ; i
 0000000E            ; SCOPE-END
  731: }
 0000000E  BC10      POP         {R4}
 00000010  BC08      POP         {R3}
 00000012  4718      BX          R3
 00000014          ENDP ; 'TstBitPar?T'


*** CODE SEGMENT '?PR?WaitForEnter?T?Human':
  732: void WaitForEnter(void)
 00000000  B510      PUSH        {R4,LR}
  733: {
 00000002            ; SCOPE-START
  735:     inChar = 0;
 00000002  2400      MOV         R4,#0x0
 00000004  ---- Variable 'inChar' assigned to Register 'R4' ----
  737:     while (inChar == 0)
 00000004          L_184:
  739:         if (UART0_RxNumber() > 0)
 00000004  F7FF      BL          UART0_RxNumber?T  ; T=0x0001  (1)
 00000006  FFFC      BL          UART0_RxNumber?T  ; T=0x0001  (2)
 00000008  0400      LSL         R0,R0,#0x10 ; UART0_RxNumber?T
 0000000A  0C00      LSR         R0,R0,#0x10
 0000000C  2800      CMP         R0,#0x0
 0000000E  D902      BLS         L_182  ; T=0x00000016
  741:             inChar = UART0_Get();
 00000010  F7FF      BL          UART0_Get?T  ; T=0x0001  (1)
 00000012  FFF6      BL          UART0_Get?T  ; T=0x0001  (2)
 00000014  1C04      MOV         R4,R0 ; inChar
  743:     }
 00000016          L_182:
 00000016  2C00      CMP         R4,#0x0 ; inChar
 00000018  D0F4      BEQ         L_184  ; T=0x00000004
 0000001A            ; SCOPE-END
  744: }
 0000001A  BC10      POP         {R4}
 0000001C  BC08      POP         {R3}
 0000001E  4718      BX          R3
 00000020          ENDP ; 'WaitForEnter?T'


*** CODE SEGMENT '?PR?ReturnDataMicro?T?Human':
  746: void ReturnDataMicro(void)
 00000000  B5F0      PUSH        {R4-R7,LR}
  747: {
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 67  

 00000002            ; SCOPE-START
  750:     n = sprintf(outBuf,"%d;%d;%d\n",startTime,curTime,nStim);
 00000002  4800      LDR         R0,=nStim ; nStim
 00000004  6800      LDR         R0,[R0,#0x0] ; nStim
 00000006  B401      PUSH        {R0}
 00000008  4800      LDR         R0,=outBuf ; outBuf
 0000000A  4800      LDR         R1,=??S_4 ; ??S_4
 0000000C  4800      LDR         R2,=startTime ; startTime
 0000000E  6812      LDR         R2,[R2,#0x0] ; startTime
 00000010  4800      LDR         R3,=curTime ; curTime
 00000012  681B      LDR         R3,[R3,#0x0] ; curTime
 00000014  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000016  FFF4      BL          sprintf?T  ; T=0x0001  (2)
 00000018  B001      ADD         R13,#0x4
 0000001A  1C05      MOV         R5,R0 ; n
 0000001C  ---- Variable 'n' assigned to Register 'R5' ----
  751:      i = UART0_Str(outBuf, n);
 0000001C  4800      LDR         R0,=outBuf ; outBuf
 0000001E  1C29      MOV         R1,R5
 00000020  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000022  FFEE      BL          UART0_Str?T  ; T=0x0001  (2)
 00000024  1C04      MOV         R4,R0 ; i
 00000026  ---- Variable 'i' assigned to Register 'R4' ----
  752:     WaitForEnter();
 00000026  F7FF      BL          WaitForEnter?T  ; T=0x0001  (1)
 00000028  FFEB      BL          WaitForEnter?T  ; T=0x0001  (2)
  755:     t0 = 0; // incase of missing acq
 0000002A  2700      MOV         R7,#0x0
 0000002C  ---- Variable 't0' assigned to Register 'R7' ----
  756:     for (lp=0; lp <=nStim; lp++)
 0000002C  2600      MOV         R6,#0x0
 0000002E  ---- Variable 'lp' assigned to Register 'R6' ----
 0000002E  E008      B           L_189  ; T=0x00000042
 00000030          L_190:
  758:         if (stim[lp].kind == stimAcq)
 00000030  213C      MOV         R1,#0x3C
 00000032  4371      MUL         R1,R6 ; lp
 00000034  4800      LDR         R0,=stim + 0x8 ; stim+8
 00000036  5840      LDR         R0,[R0,R1]
 00000038  2869      CMP         R0,#0x69
 0000003A  D101      BNE         L_187  ; T=0x00000040
  760:             t0 = stim[lp].startTime;
 0000003C  4800      LDR         R0,=stim + 0x28 ; stim+40
 0000003E  5847      LDR         R7,[R0,R1]
  762:     }
 00000040          L_187:
 00000040  3601      ADD         R6,#0x1
 00000042          L_189:
 00000042  4800      LDR         R0,=nStim ; nStim
 00000044  6800      LDR         R0,[R0,#0x0] ; nStim
 00000046  4286      CMP         R6,R0 ; lp
 00000048  DDF2      BLE         L_190  ; T=0x00000030
  764:      for (lp=0; lp <= nStim; lp++)
 0000004A  2600      MOV         R6,#0x0
 0000004C  E157      B           L_195  ; T=0x000002FE
 0000004E          L_196:
  766:         switch (stim[lp].kind)
 0000004E  213C      MOV         R1,#0x3C
 00000050  4371      MUL         R1,R6 ; lp
 00000052  4800      LDR         R0,=stim + 0x8 ; stim+8
 00000054  5840      LDR         R0,[R0,R1]
 00000056  2865      CMP         R0,#0x65
 00000058  D081      BEQ         L_200  ; T=0xFFFFFF5E
 0000005A  2866      CMP         R0,#0x66
 0000005C  D100      BEQ         $+4
 0000005E  E0AA      B           L_201  ; T=0x000001B6
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 68  

 00000062  2867      CMP         R0,#0x67
 00000064  D100      BEQ         $+4
 00000066  E135      B           L_202  ; T=0x000002D4
 0000006A  2868      CMP         R0,#0x68
 0000006C  D100      BEQ         $+4
 0000006E  E138      B           L_203  ; T=0x000002E2
 00000072  2869      CMP         R0,#0x69
 00000074  D100      BEQ         $+4
 00000076  E0CA      B           L_204  ; T=0x0000020E
 0000007A  286A      CMP         R0,#0x6A
 0000007C  D100      BEQ         $+4
 0000007E  E0D2      B           L_205  ; T=0x00000226
 00000082  286C      CMP         R0,#0x6C
 00000084  D100      BEQ         $+4
 00000086  E0EB      B           L_206  ; T=0x00000260
 0000008A  286D      CMP         R0,#0x6D
 0000008C  D019      BEQ         L_207  ; T=0x000000C2
 0000008E  286E      CMP         R0,#0x6E
 00000090  D03E      BEQ         L_208  ; T=0x00000110
 00000092  286F      CMP         R0,#0x6F
 00000094  D100      BEQ         $+4
 00000096  E105      B           L_209  ; T=0x000002A4
 0000009A  2864      CMP         R0,#0x64
 0000009C  D000      BNE         $+4
 0000009E  E126      B           L_198  ; T=0x000002EE
  768:         case stimLed:   n = sprintf(outBuf,"%4d;%4d;%4d;%5d;%5d;%4d;   1; NaN; NaN\n",
 000000A2          L_199:
 000000A2  4800      LDR         R0,=stim + 0x20 ; stim+32
 000000A4  5840      LDR         R0,[R0,R1]
 000000A6  B401      PUSH        {R0}
 000000A8  4800      LDR         R0,=stim + 0x30 ; stim+48
 000000AA  5840      LDR         R0,[R0,R1]
 000000AC  1BC0      SUB         R0,R7 ; t0
 000000AE  B401      PUSH        {R0}
 000000B0  4800      LDR         R0,=stim + 0x28 ; stim+40
 000000B2  5840      LDR         R0,[R0,R1]
 000000B4  1BC0      SUB         R0,R7 ; t0
 000000B6  B401      PUSH        {R0}
 000000B8  4800      LDR         R0,=stim + 0x1C ; stim+28
 000000BA  5840      LDR         R0,[R0,R1]
 000000BC  B401      PUSH        {R0}
 000000BE  4800      LDR         R0,=stim + 0x18 ; stim+24
 000000C0  5843      LDR         R3,[R0,R1]
 000000C2  4800      LDR         R0,=outBuf ; outBuf
 000000C4  4800      LDR         R1,=??S_5 ; ??S_5
 000000C6  2264      MOV         R2,#0x64
 000000C8  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 000000CA  FF9A      BL          sprintf?T  ; T=0x0001  (2)
 000000CC  B004      ADD         R13,#0x10
 000000CE  1C05      MOV         R5,R0 ; n
  771:                         break;                                                   
 000000D0  E10D      B           L_198  ; T=0x000002EE
  772:         case stimLeds:  n = sprintf(outBuf,"%4d;%4d;%4d;%5d;%5d;%4d;   %d; NaN; NaN\n",
 000000D2          L_207:
 000000D2  213C      MOV         R1,#0x3C
 000000D4  4371      MUL         R1,R6 ; lp
 000000D6  4800      LDR         R0,=stim + 0xC ; stim+12
 000000D8  5840      LDR         R0,[R0,R1]
 000000DA  B401      PUSH        {R0}
 000000DC  213C      MOV         R1,#0x3C
 000000DE  4371      MUL         R1,R6 ; lp
 000000E0  4800      LDR         R0,=stim + 0x20 ; stim+32
 000000E2  5840      LDR         R0,[R0,R1]
 000000E4  B401      PUSH        {R0}
 000000E6  213C      MOV         R1,#0x3C
 000000E8  4371      MUL         R1,R6 ; lp
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 69  

 000000EA  4800      LDR         R0,=stim + 0x30 ; stim+48
 000000EC  5840      LDR         R0,[R0,R1]
 000000EE  1BC0      SUB         R0,R7 ; t0
 000000F0  B401      PUSH        {R0}
 000000F2  213C      MOV         R1,#0x3C
 000000F4  4371      MUL         R1,R6 ; lp
 000000F6  4800      LDR         R0,=stim + 0x28 ; stim+40
 000000F8  5840      LDR         R0,[R0,R1]
 000000FA  1BC0      SUB         R0,R7 ; t0
 000000FC  B401      PUSH        {R0}
 000000FE  213C      MOV         R1,#0x3C
 00000100  4371      MUL         R1,R6 ; lp
 00000102  4800      LDR         R0,=stim + 0x1C ; stim+28
 00000104  5840      LDR         R0,[R0,R1]
 00000106  B401      PUSH        {R0}
 00000108  213C      MOV         R1,#0x3C
 0000010A  4371      MUL         R1,R6 ; lp
 0000010C  4800      LDR         R0,=stim + 0x18 ; stim+24
 0000010E  5843      LDR         R3,[R0,R1]
 00000110  4800      LDR         R0,=outBuf ; outBuf
 00000112  4800      LDR         R1,=??S_6 ; ??S_6
 00000114  226D      MOV         R2,#0x6D
 00000116  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000118  FF73      BL          sprintf?T  ; T=0x0001  (2)
 0000011A  B005      ADD         R13,#0x14
 0000011C  1C05      MOV         R5,R0 ; n
  775:                         break;                                                   
 0000011E  E0E6      B           L_198  ; T=0x000002EE
  776:         case stimBlink: n = sprintf(outBuf,"%4d;%4d;%4d;%5d;%5d;%4d;   %d; NaN; NaN\n",
 00000120          L_208:
 00000120  213C      MOV         R1,#0x3C
 00000122  4371      MUL         R1,R6 ; lp
 00000124  4800      LDR         R0,=stim + 0xC ; stim+12
 00000126  5840      LDR         R0,[R0,R1]
 00000128  B401      PUSH        {R0}
 0000012A  213C      MOV         R1,#0x3C
 0000012C  4371      MUL         R1,R6 ; lp
 0000012E  4800      LDR         R0,=stim + 0x20 ; stim+32
 00000130  5840      LDR         R0,[R0,R1]
 00000132  B401      PUSH        {R0}
 00000134  213C      MOV         R1,#0x3C
 00000136  4371      MUL         R1,R6 ; lp
 00000138  4800      LDR         R0,=stim + 0x30 ; stim+48
 0000013A  5840      LDR         R0,[R0,R1]
 0000013C  1BC0      SUB         R0,R7 ; t0
 0000013E  B401      PUSH        {R0}
 00000140  213C      MOV         R1,#0x3C
 00000142  4371      MUL         R1,R6 ; lp
 00000144  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000146  5840      LDR         R0,[R0,R1]
 00000148  1BC0      SUB         R0,R7 ; t0
 0000014A  B401      PUSH        {R0}
 0000014C  213C      MOV         R1,#0x3C
 0000014E  4371      MUL         R1,R6 ; lp
 00000150  4800      LDR         R0,=stim + 0x1C ; stim+28
 00000152  5840      LDR         R0,[R0,R1]
 00000154  B401      PUSH        {R0}
 00000156  213C      MOV         R1,#0x3C
 00000158  4371      MUL         R1,R6 ; lp
 0000015A  4800      LDR         R0,=stim + 0x18 ; stim+24
 0000015C  5843      LDR         R3,[R0,R1]
 0000015E  4800      LDR         R0,=outBuf ; outBuf
 00000160  4800      LDR         R1,=??S_6 ; ??S_6
 00000162  226E      MOV         R2,#0x6E
 00000164  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000166  FF4C      BL          sprintf?T  ; T=0x0001  (2)
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 70  

 00000168  B005      ADD         R13,#0x14
 0000016A  1C05      MOV         R5,R0 ; n
  779:                         break;                                                   
 0000016C  E0BF      B           L_198  ; T=0x000002EE
  780:         case stimSnd1:  n = sprintf(outBuf,"%4d;%4d;%4d;%5d;%5d;%4d;%4d;%4d; NaN\n",
 0000016E          L_200:
 0000016E  213C      MOV         R1,#0x3C
 00000170  4371      MUL         R1,R6 ; lp
 00000172  4800      LDR         R0,=stim + 0x34 ; stim+52
 00000174  5840      LDR         R0,[R0,R1]
 00000176  B401      PUSH        {R0}
 00000178  213C      MOV         R1,#0x3C
 0000017A  4371      MUL         R1,R6 ; lp
 0000017C  4800      LDR         R0,=stim + 0xC ; stim+12
 0000017E  5840      LDR         R0,[R0,R1]
 00000180  B401      PUSH        {R0}
 00000182  213C      MOV         R1,#0x3C
 00000184  4371      MUL         R1,R6 ; lp
 00000186  4800      LDR         R0,=stim + 0x20 ; stim+32
 00000188  5840      LDR         R0,[R0,R1]
 0000018A  B401      PUSH        {R0}
 0000018C  213C      MOV         R1,#0x3C
 0000018E  4371      MUL         R1,R6 ; lp
 00000190  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000192  5840      LDR         R0,[R0,R1]
 00000194  1BC0      SUB         R0,R7 ; t0
 00000196  B401      PUSH        {R0}
 00000198  213C      MOV         R1,#0x3C
 0000019A  4371      MUL         R1,R6 ; lp
 0000019C  4800      LDR         R0,=stim + 0x28 ; stim+40
 0000019E  5840      LDR         R0,[R0,R1]
 000001A0  1BC0      SUB         R0,R7 ; t0
 000001A2  B401      PUSH        {R0}
 000001A4  213C      MOV         R1,#0x3C
 000001A6  4371      MUL         R1,R6 ; lp
 000001A8  4800      LDR         R0,=stim + 0x1C ; stim+28
 000001AA  5840      LDR         R0,[R0,R1]
 000001AC  B401      PUSH        {R0}
 000001AE  213C      MOV         R1,#0x3C
 000001B0  4371      MUL         R1,R6 ; lp
 000001B2  4800      LDR         R0,=stim + 0x18 ; stim+24
 000001B4  5843      LDR         R3,[R0,R1]
 000001B6  4800      LDR         R0,=outBuf ; outBuf
 000001B8  4800      LDR         R1,=??S_7 ; ??S_7
 000001BA  2265      MOV         R2,#0x65
 000001BC  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 000001BE  FF20      BL          sprintf?T  ; T=0x0001  (2)
 000001C0  B006      ADD         R13,#0x18
 000001C2  1C05      MOV         R5,R0 ; n
  784:                         break;
 000001C4  E093      B           L_198  ; T=0x000002EE
  785:         case stimSnd2:  n = sprintf(outBuf,"%4d;%4d;%4d;%5d;%5d;%4d;%4d;%4d; NaN\n",
 000001C6          L_201:
 000001C6  213C      MOV         R1,#0x3C
 000001C8  4371      MUL         R1,R6 ; lp
 000001CA  4800      LDR         R0,=stim + 0x34 ; stim+52
 000001CC  5840      LDR         R0,[R0,R1]
 000001CE  B401      PUSH        {R0}
 000001D0  213C      MOV         R1,#0x3C
 000001D2  4371      MUL         R1,R6 ; lp
 000001D4  4800      LDR         R0,=stim + 0xC ; stim+12
 000001D6  5840      LDR         R0,[R0,R1]
 000001D8  B401      PUSH        {R0}
 000001DA  213C      MOV         R1,#0x3C
 000001DC  4371      MUL         R1,R6 ; lp
 000001DE  4800      LDR         R0,=stim + 0x20 ; stim+32
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 71  

 000001E0  5840      LDR         R0,[R0,R1]
 000001E2  B401      PUSH        {R0}
 000001E4  213C      MOV         R1,#0x3C
 000001E6  4371      MUL         R1,R6 ; lp
 000001E8  4800      LDR         R0,=stim + 0x30 ; stim+48
 000001EA  5840      LDR         R0,[R0,R1]
 000001EC  1BC0      SUB         R0,R7 ; t0
 000001EE  B401      PUSH        {R0}
 000001F0  213C      MOV         R1,#0x3C
 000001F2  4371      MUL         R1,R6 ; lp
 000001F4  4800      LDR         R0,=stim + 0x28 ; stim+40
 000001F6  5840      LDR         R0,[R0,R1]
 000001F8  1BC0      SUB         R0,R7 ; t0
 000001FA  B401      PUSH        {R0}
 000001FC  213C      MOV         R1,#0x3C
 000001FE  4371      MUL         R1,R6 ; lp
 00000200  4800      LDR         R0,=stim + 0x1C ; stim+28
 00000202  5840      LDR         R0,[R0,R1]
 00000204  B401      PUSH        {R0}
 00000206  213C      MOV         R1,#0x3C
 00000208  4371      MUL         R1,R6 ; lp
 0000020A  4800      LDR         R0,=stim + 0x18 ; stim+24
 0000020C  5843      LDR         R3,[R0,R1]
 0000020E  4800      LDR         R0,=outBuf ; outBuf
 00000210  4800      LDR         R1,=??S_7 ; ??S_7
 00000212  2266      MOV         R2,#0x66
 00000214  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000216  FEF4      BL          sprintf?T  ; T=0x0001  (2)
 00000218  B006      ADD         R13,#0x18
 0000021A  1C05      MOV         R5,R0 ; n
  789:                         break;
 0000021C  E067      B           L_198  ; T=0x000002EE
  790:         case stimAcq:   n = sprintf(outBuf,"%4d; NaN; NaN;%5d;  NaN; NaN; NaN; NaN; NaN\n",
 0000021E          L_204:
 0000021E  213C      MOV         R1,#0x3C
 00000220  4371      MUL         R1,R6 ; lp
 00000222  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000224  5843      LDR         R3,[R0,R1]
 00000226  1BDB      SUB         R3,R7 ; t0
 00000228  4800      LDR         R0,=outBuf ; outBuf
 0000022A  4800      LDR         R1,=??S_8 ; ??S_8
 0000022C  2269      MOV         R2,#0x69
 0000022E  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000230  FEE7      BL          sprintf?T  ; T=0x0001  (2)
 00000232  1C05      MOV         R5,R0 ; n
  792:                         break;
 00000234  E05B      B           L_198  ; T=0x000002EE
  793:         case stimTrg0:  n = sprintf(outBuf,"%4d; NaN; NaN;%5d;%5d; NaN; NaN;%4d;%4d\n",
 00000236          L_205:
 00000236  213C      MOV         R1,#0x3C
 00000238  4371      MUL         R1,R6 ; lp
 0000023A  4800      LDR         R0,=stim + 0x10 ; stim+16
 0000023C  5840      LDR         R0,[R0,R1]
 0000023E  B401      PUSH        {R0}
 00000240  213C      MOV         R1,#0x3C
 00000242  4371      MUL         R1,R6 ; lp
 00000244  4800      LDR         R0,=stim + 0x14 ; stim+20
 00000246  5840      LDR         R0,[R0,R1]
 00000248  B401      PUSH        {R0}
 0000024A  213C      MOV         R1,#0x3C
 0000024C  4371      MUL         R1,R6 ; lp
 0000024E  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000250  5840      LDR         R0,[R0,R1]
 00000252  1BC0      SUB         R0,R7 ; t0
 00000254  B401      PUSH        {R0}
 00000256  213C      MOV         R1,#0x3C
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 72  

 00000258  4371      MUL         R1,R6 ; lp
 0000025A  4800      LDR         R0,=stim + 0x28 ; stim+40
 0000025C  5843      LDR         R3,[R0,R1]
 0000025E  1BDB      SUB         R3,R7 ; t0
 00000260  4800      LDR         R0,=outBuf ; outBuf
 00000262  4800      LDR         R1,=??S_9 ; ??S_9
 00000264  226A      MOV         R2,#0x6A
 00000266  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000268  FECB      BL          sprintf?T  ; T=0x0001  (2)
 0000026A  B003      ADD         R13,#0xC
 0000026C  1C05      MOV         R5,R0 ; n
  796:                         break;
 0000026E  E03E      B           L_198  ; T=0x000002EE
  797:         case stimSky:   n = sprintf(outBuf,"%4d;%4d;%4d;%5d;%5d;%4d;   1; NaN; NaN\n",
 00000270          L_206:
 00000270  213C      MOV         R1,#0x3C
 00000272  4371      MUL         R1,R6 ; lp
 00000274  4800      LDR         R0,=stim + 0x20 ; stim+32
 00000276  5840      LDR         R0,[R0,R1]
 00000278  B401      PUSH        {R0}
 0000027A  213C      MOV         R1,#0x3C
 0000027C  4371      MUL         R1,R6 ; lp
 0000027E  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000280  5840      LDR         R0,[R0,R1]
 00000282  1BC0      SUB         R0,R7 ; t0
 00000284  B401      PUSH        {R0}
 00000286  213C      MOV         R1,#0x3C
 00000288  4371      MUL         R1,R6 ; lp
 0000028A  4800      LDR         R0,=stim + 0x28 ; stim+40
 0000028C  5840      LDR         R0,[R0,R1]
 0000028E  1BC0      SUB         R0,R7 ; t0
 00000290  B401      PUSH        {R0}
 00000292  213C      MOV         R1,#0x3C
 00000294  4371      MUL         R1,R6 ; lp
 00000296  4800      LDR         R0,=stim + 0x1C ; stim+28
 00000298  5840      LDR         R0,[R0,R1]
 0000029A  B401      PUSH        {R0}
 0000029C  213C      MOV         R1,#0x3C
 0000029E  4371      MUL         R1,R6 ; lp
 000002A0  4800      LDR         R0,=stim + 0x18 ; stim+24
 000002A2  5843      LDR         R3,[R0,R1]
 000002A4  4800      LDR         R0,=outBuf ; outBuf
 000002A6  4800      LDR         R1,=??S_5 ; ??S_5
 000002A8  226C      MOV         R2,#0x6C
 000002AA  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 000002AC  FEA9      BL          sprintf?T  ; T=0x0001  (2)
 000002AE  B004      ADD         R13,#0x10
 000002B0  1C05      MOV         R5,R0 ; n
  800:                         break;                                                   
 000002B2  E01C      B           L_198  ; T=0x000002EE
  801:         case stimLas:   n = sprintf(outBuf,"%4d; NaN; NaN;%5d;%5d; NaN; NaN;%4d; NaN\n",
 000002B4          L_209:
 000002B4  213C      MOV         R1,#0x3C
 000002B6  4371      MUL         R1,R6 ; lp
 000002B8  4800      LDR         R0,=stim + 0x14 ; stim+20
 000002BA  5840      LDR         R0,[R0,R1]
 000002BC  B401      PUSH        {R0}
 000002BE  213C      MOV         R1,#0x3C
 000002C0  4371      MUL         R1,R6 ; lp
 000002C2  4800      LDR         R0,=stim + 0x30 ; stim+48
 000002C4  5840      LDR         R0,[R0,R1]
 000002C6  1BC0      SUB         R0,R7 ; t0
 000002C8  B401      PUSH        {R0}
 000002CA  213C      MOV         R1,#0x3C
 000002CC  4371      MUL         R1,R6 ; lp
 000002CE  4800      LDR         R0,=stim + 0x28 ; stim+40
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 73  

 000002D0  5843      LDR         R3,[R0,R1]
 000002D2  1BDB      SUB         R3,R7 ; t0
 000002D4  4800      LDR         R0,=outBuf ; outBuf
 000002D6  4800      LDR         R1,=??S_10 ; ??S_10
 000002D8  226F      MOV         R2,#0x6F
 000002DA  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 000002DC  FE91      BL          sprintf?T  ; T=0x0001  (2)
 000002DE  B002      ADD         R13,#0x8
 000002E0  1C05      MOV         R5,R0 ; n
  804:                         break;
 000002E2  E004      B           L_198  ; T=0x000002EE
  805:         case stimInp1:  n = sprintf(outBuf,"%4d; NaN; NaN; NaN;  NaN; NaN; NaN; NaN; NaN\n", stimInp1);
 000002E4          L_202:
 000002E4  4800      LDR         R0,=outBuf ; outBuf
 000002E6  4800      LDR         R1,=??S_11 ; ??S_11
 000002E8  2267      MOV         R2,#0x67
 000002EA  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 000002EC  FE89      BL          sprintf?T  ; T=0x0001  (2)
 000002EE  1C05      MOV         R5,R0 ; n
  806:                         break;
 000002F0  E7FD      B           L_198  ; T=0x000002EE
  807:         case stimInp2:  n = sprintf(outBuf,"%4d; NaN; NaN; NaN;  NaN; NaN; NaN; NaN; NaN\n", stimInp2);
 000002F2          L_203:
 000002F2  4800      LDR         R0,=outBuf ; outBuf
 000002F4  4800      LDR         R1,=??S_11 ; ??S_11
 000002F6  2268      MOV         R2,#0x68
 000002F8  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 000002FA  FE82      BL          sprintf?T  ; T=0x0001  (2)
 000002FC  1C05      MOV         R5,R0 ; n
  809:         }
 000002FE          L_198:
  810:         i = UART0_Str(outBuf, n);
 000002FE  4800      LDR         R0,=outBuf ; outBuf
 00000300  1C29      MOV         R1,R5
 00000302  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000304  FE7D      BL          UART0_Str?T  ; T=0x0001  (2)
 00000306  1C04      MOV         R4,R0 ; i
  811:         WaitForEnter();
 00000308  F7FF      BL          WaitForEnter?T  ; T=0x0001  (1)
 0000030A  FE7A      BL          WaitForEnter?T  ; T=0x0001  (2)
  812:     }
 0000030C  3601      ADD         R6,#0x1
 0000030E          L_195:
 0000030E  4800      LDR         R0,=nStim ; nStim
 00000310  6800      LDR         R0,[R0,#0x0] ; nStim
 00000312  4286      CMP         R6,R0 ; lp
 00000314  DC00      BLE         $+4
 00000316  E69A      B           L_196  ; T=0x0000004E
  814:     tBuf[4] = Clock_GetTicks();
 0000031A  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 0000031C  FE71      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 0000031E  4800      LDR         R1,=tBuf + 0x10 ; tBuf+16
 00000320  6008      STR         R0,[R1,#0x0] ; tBuf+16
  815:     n = sprintf(outBuf,"%d;%d;%d;%d;%d\n",
 00000322  4800      LDR         R0,=tBuf + 0x10 ; tBuf+16
 00000324  6800      LDR         R0,[R0,#0x0] ; tBuf+16
 00000326  B401      PUSH        {R0}
 00000328  4800      LDR         R0,=tBuf + 0xC ; tBuf+12
 0000032A  6800      LDR         R0,[R0,#0x0] ; tBuf+12
 0000032C  B401      PUSH        {R0}
 0000032E  4800      LDR         R0,=tBuf + 0x8 ; tBuf+8
 00000330  6800      LDR         R0,[R0,#0x0] ; tBuf+8
 00000332  B401      PUSH        {R0}
 00000334  4800      LDR         R0,=outBuf ; outBuf
 00000336  4800      LDR         R1,=??S_3 ; ??S_3
 00000338  4800      LDR         R2,=tBuf ; tBuf
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 74  

 0000033A  6812      LDR         R2,[R2,#0x0] ; tBuf
 0000033C  4800      LDR         R3,=tBuf + 0x4 ; tBuf+4
 0000033E  681B      LDR         R3,[R3,#0x0] ; tBuf+4
 00000340  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000342  FE5E      BL          sprintf?T  ; T=0x0001  (2)
 00000344  B003      ADD         R13,#0xC
 00000346  1C05      MOV         R5,R0 ; n
  817:     i = UART0_Str(outBuf, n);
 00000348  4800      LDR         R0,=outBuf ; outBuf
 0000034A  1C29      MOV         R1,R5
 0000034C  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 0000034E  FE58      BL          UART0_Str?T  ; T=0x0001  (2)
 00000350  1C04      MOV         R4,R0 ; i
  818:     WaitForEnter();
 00000352  F7FF      BL          WaitForEnter?T  ; T=0x0001  (1)
 00000354  FE55      BL          WaitForEnter?T  ; T=0x0001  (2)
 00000356            ; SCOPE-END
  819: }
 00000356  BCF0      POP         {R4-R7}
 00000358  BC08      POP         {R3}
 0000035A  4718      BX          R3
 0000035C          ENDP ; 'ReturnDataMicro?T'


*** CODE SEGMENT '?PR?ExecLed?T?Human':
  821: int ExecLed(int i)
 00000000  B570      PUSH        {R4-R6,LR}
 00000002  1C04      MOV         R4,R0 ; i
 00000004  ---- Variable 'i' assigned to Register 'R4' ----
  823:     curTime = Clock_GetTicks();
 00000004  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000006  FFFC      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000008  4800      LDR         R1,=curTime ; curTime
 0000000A  6008      STR         R0,[R1,#0x0] ; curTime
  824:     if (stim[i].status == statInit)
 0000000C  253C      MOV         R5,#0x3C
 0000000E  4365      MUL         R5,R4 ; i
 00000010  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000012  5946      LDR         R6,[R0,R5]
 00000014  2E00      CMP         R6,#0x0
 00000016  D120      BNE         L_210  ; T=0x0000005A
  826:         if ((stim[i].startRef == 0) && (curTime >= stim[i].startTime))
 00000018  4800      LDR         R0,=stim + 0x24 ; stim+36
 0000001A  5940      LDR         R0,[R0,R5]
 0000001C  2800      CMP         R0,#0x0
 0000001E  D11A      BNE         L_211  ; T=0x00000056
 00000020  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000022  5941      LDR         R1,[R0,R5]
 00000024  4800      LDR         R0,=curTime ; curTime
 00000026  6800      LDR         R0,[R0,#0x0] ; curTime
 00000028  4288      CMP         R0,R1
 0000002A  D314      BCC         L_211  ; T=0x00000056
  828:             LedOnOff(stim[i].posY, stim[i].level, ON, false);
 0000002C  4800      LDR         R0,=stim + 0x1C ; stim+28
 0000002E  5940      LDR         R0,[R0,R5]
 00000030  4800      LDR         R1,=stim + 0x20 ; stim+32
 00000032  5949      LDR         R1,[R1,R5]
 00000034  2201      MOV         R2,#0x1
 00000036  2300      MOV         R3,#0x0
 00000038  F7FF      BL          LedOnOff?T  ; T=0x0001  (1)
 0000003A  FFE2      BL          LedOnOff?T  ; T=0x0001  (2)
  829:             curTime = Clock_GetTicks();
 0000003C  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 0000003E  FFE0      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000040  4800      LDR         R1,=curTime ; curTime
 00000042  6008      STR         R0,[R1,#0x0] ; curTime
  830:             stim[i].startTime = curTime;
 00000044  4800      LDR         R0,=curTime ; curTime
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 75  

 00000046  6801      LDR         R1,[R0,#0x0] ; curTime
 00000048  223C      MOV         R2,#0x3C
 0000004A  4362      MUL         R2,R4 ; i
 0000004C  4800      LDR         R0,=stim + 0x28 ; stim+40
 0000004E  5081      STR         R1,[R0,R2]
  831:             stim[i].status = statRun;
 00000050  2003      MOV         R0,#0x3
 00000052  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000054  5088      STR         R0,[R1,R2]
  832:         }
 00000056          L_211:
  833:         return 1;
 00000056  2001      MOV         R0,#0x1
 00000058  E025      B           L_212  ; T=0x000000A6
  834:     }
 0000005A          L_210:
  836:     if (stim[i].status == statRun)
 0000005A  2E03      CMP         R6,#0x3
 0000005C  D122      BNE         L_213  ; T=0x000000A4
  838:         if ((stim[i].stopRef == 0) && (curTime >= stim[i].stopTime))
 0000005E  4800      LDR         R0,=stim + 0x2C ; stim+44
 00000060  5940      LDR         R0,[R0,R5]
 00000062  2800      CMP         R0,#0x0
 00000064  D11C      BNE         L_214  ; T=0x000000A0
 00000066  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000068  5941      LDR         R1,[R0,R5]
 0000006A  4800      LDR         R0,=curTime ; curTime
 0000006C  6800      LDR         R0,[R0,#0x0] ; curTime
 0000006E  4288      CMP         R0,R1
 00000070  D316      BCC         L_214  ; T=0x000000A0
  840:             LedOnOff(stim[i].posY, stim[i].level, OFF, false);
 00000072  4800      LDR         R0,=stim + 0x1C ; stim+28
 00000074  5940      LDR         R0,[R0,R5]
 00000076  4800      LDR         R1,=stim + 0x20 ; stim+32
 00000078  5949      LDR         R1,[R1,R5]
 0000007A  2200      MOV         R2,#0x0
 0000007C  2300      MOV         R3,#0x0
 0000007E  F7FF      BL          LedOnOff?T  ; T=0x0001  (1)
 00000080  FFBF      BL          LedOnOff?T  ; T=0x0001  (2)
  841:             curTime = Clock_GetTicks();
 00000082  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000084  FFBD      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000086  4800      LDR         R1,=curTime ; curTime
 00000088  6008      STR         R0,[R1,#0x0] ; curTime
  842:             stim[i].stopTime = curTime;
 0000008A  4800      LDR         R0,=curTime ; curTime
 0000008C  6801      LDR         R1,[R0,#0x0] ; curTime
 0000008E  223C      MOV         R2,#0x3C
 00000090  4362      MUL         R2,R4 ; i
 00000092  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000094  5081      STR         R1,[R0,R2]
  843:             stim[i].status = statDone;
 00000096  2005      MOV         R0,#0x5
 00000098  4800      LDR         R1,=stim + 0x4 ; stim+4
 0000009A  5088      STR         R0,[R1,R2]
  844:             return 0;
 0000009C  2000      MOV         R0,#0x0
 0000009E  E002      B           L_212  ; T=0x000000A6
  845:         }
 000000A0          L_214:
  846:         return 1;
 000000A0  2001      MOV         R0,#0x1
 000000A2  E000      B           L_212  ; T=0x000000A6
  847:     }
 000000A4          L_213:
  849:     return 0;
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 76  

 000000A4  2000      MOV         R0,#0x0
  850: }
 000000A6          L_212:
 000000A6  BC70      POP         {R4-R6}
 000000A8  BC08      POP         {R3}
 000000AA  4718      BX          R3
 000000AC          ENDP ; 'ExecLed?T'


*** CODE SEGMENT '?PR?ExecLeds?T?Human':
  852: int ExecLeds(int i)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C05      MOV         R5,R0 ; i
 00000004  ---- Variable 'i' assigned to Register 'R5' ----
 00000004  ---- Variable 'n' assigned to Register 'R4' ----
  853: {     
 00000004            ; SCOPE-START
  855:     curTime = Clock_GetTicks();
 00000004  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000006  FFFC      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000008  4800      LDR         R1,=curTime ; curTime
 0000000A  6008      STR         R0,[R1,#0x0] ; curTime
  856:     if (stim[i].status == statInit)
 0000000C  273C      MOV         R7,#0x3C
 0000000E  436F      MUL         R7,R5 ; i
 00000010  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000012  59C6      LDR         R6,[R0,R7]
 00000014  2E00      CMP         R6,#0x0
 00000016  D125      BNE         L_215  ; T=0x00000064
  858:         if ((stim[i].startRef == 0) && (curTime >= stim[i].startTime))
 00000018  4800      LDR         R0,=stim + 0x24 ; stim+36
 0000001A  59C0      LDR         R0,[R0,R7]
 0000001C  2800      CMP         R0,#0x0
 0000001E  D11F      BNE         L_216  ; T=0x00000060
 00000020  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000022  59C1      LDR         R1,[R0,R7]
 00000024  4800      LDR         R0,=curTime ; curTime
 00000026  6800      LDR         R0,[R0,#0x0] ; curTime
 00000028  4288      CMP         R0,R1
 0000002A  D319      BCC         L_216  ; T=0x00000060
  860:             for (n = 1;n < 30; n++)
 0000002C  2401      MOV         R4,#0x1
 0000002E          L_220:
  861:                 LedOnOff(n, stim[i].level, ON, false);
 0000002E  213C      MOV         R1,#0x3C
 00000030  4369      MUL         R1,R5 ; i
 00000032  4800      LDR         R0,=stim + 0x20 ; stim+32
 00000034  5841      LDR         R1,[R0,R1]
 00000036  1C20      MOV         R0,R4
 00000038  2201      MOV         R2,#0x1
 0000003A  2300      MOV         R3,#0x0
 0000003C  F7FF      BL          LedOnOff?T  ; T=0x0001  (1)
 0000003E  FFE0      BL          LedOnOff?T  ; T=0x0001  (2)
 00000040  3401      ADD         R4,#0x1
 00000042  2C1E      CMP         R4,#0x1E ; n
 00000044  DBF3      BLT         L_220  ; T=0x0000002E
  862:             curTime = Clock_GetTicks();
 00000046  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000048  FFDB      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 0000004A  4800      LDR         R1,=curTime ; curTime
 0000004C  6008      STR         R0,[R1,#0x0] ; curTime
  863:             stim[i].startTime = curTime;
 0000004E  4800      LDR         R0,=curTime ; curTime
 00000050  6801      LDR         R1,[R0,#0x0] ; curTime
 00000052  223C      MOV         R2,#0x3C
 00000054  436A      MUL         R2,R5 ; i
 00000056  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000058  5081      STR         R1,[R0,R2]
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 77  

  864:             stim[i].status = statRun;
 0000005A  2003      MOV         R0,#0x3
 0000005C  4800      LDR         R1,=stim + 0x4 ; stim+4
 0000005E  5088      STR         R0,[R1,R2]
  865:         }
 00000060          L_216:
  866:         return 1;
 00000060  2001      MOV         R0,#0x1
 00000062  E02E      B           L_222  ; T=0x000000C2
  867:     }
 00000064          L_215:
  869:     if (stim[i].status == statRun)
 00000064  2E03      CMP         R6,#0x3
 00000066  D12B      BNE         L_223  ; T=0x000000C0
  871:         if ((stim[i].stopRef == 0) && (curTime >= stim[i].stopTime))
 00000068  213C      MOV         R1,#0x3C
 0000006A  4369      MUL         R1,R5 ; i
 0000006C  4800      LDR         R0,=stim + 0x2C ; stim+44
 0000006E  5840      LDR         R0,[R0,R1]
 00000070  2800      CMP         R0,#0x0
 00000072  D123      BNE         L_224  ; T=0x000000BC
 00000074  213C      MOV         R1,#0x3C
 00000076  4369      MUL         R1,R5 ; i
 00000078  4800      LDR         R0,=stim + 0x30 ; stim+48
 0000007A  5841      LDR         R1,[R0,R1]
 0000007C  4800      LDR         R0,=curTime ; curTime
 0000007E  6800      LDR         R0,[R0,#0x0] ; curTime
 00000080  4288      CMP         R0,R1
 00000082  D31B      BCC         L_224  ; T=0x000000BC
  873:             for (n = 1;n < 30; n++)
 00000084  2401      MOV         R4,#0x1
 00000086          L_228:
  874:                 LedOnOff(n, stim[i].level, OFF, false);
 00000086  213C      MOV         R1,#0x3C
 00000088  4369      MUL         R1,R5 ; i
 0000008A  4800      LDR         R0,=stim + 0x20 ; stim+32
 0000008C  5841      LDR         R1,[R0,R1]
 0000008E  1C20      MOV         R0,R4
 00000090  2200      MOV         R2,#0x0
 00000092  2300      MOV         R3,#0x0
 00000094  F7FF      BL          LedOnOff?T  ; T=0x0001  (1)
 00000096  FFB4      BL          LedOnOff?T  ; T=0x0001  (2)
 00000098  3401      ADD         R4,#0x1
 0000009A  2C1E      CMP         R4,#0x1E ; n
 0000009C  DBF3      BLT         L_228  ; T=0x00000086
  875:             curTime = Clock_GetTicks();
 0000009E  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 000000A0  FFAF      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 000000A2  4800      LDR         R1,=curTime ; curTime
 000000A4  6008      STR         R0,[R1,#0x0] ; curTime
  876:             stim[i].stopTime = curTime;
 000000A6  4800      LDR         R0,=curTime ; curTime
 000000A8  6801      LDR         R1,[R0,#0x0] ; curTime
 000000AA  223C      MOV         R2,#0x3C
 000000AC  436A      MUL         R2,R5 ; i
 000000AE  4800      LDR         R0,=stim + 0x30 ; stim+48
 000000B0  5081      STR         R1,[R0,R2]
  877:             stim[i].status = statDone;
 000000B2  2005      MOV         R0,#0x5
 000000B4  4800      LDR         R1,=stim + 0x4 ; stim+4
 000000B6  5088      STR         R0,[R1,R2]
  878:             return 0;
 000000B8  2000      MOV         R0,#0x0
 000000BA  E002      B           L_222  ; T=0x000000C2
  879:         }
 000000BC          L_224:
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 78  

  880:         return 1;
 000000BC  2001      MOV         R0,#0x1
 000000BE  E000      B           L_222  ; T=0x000000C2
  881:     }
 000000C0          L_223:
  883:     return 0;
 000000C0  2000      MOV         R0,#0x0
 000000C2            ; SCOPE-END
  884: }
 000000C2          L_222:
 000000C2  BCF0      POP         {R4-R7}
 000000C4  BC08      POP         {R3}
 000000C6  4718      BX          R3
 000000C8          ENDP ; 'ExecLeds?T'


*** CODE SEGMENT '?PR?ExecBlink?T?Human':
  886: int ExecBlink(int i)
 00000000  B570      PUSH        {R4-R6,LR}
 00000002  1C04      MOV         R4,R0 ; i
 00000004  ---- Variable 'i' assigned to Register 'R4' ----
  888:     curTime = Clock_GetTicks();
 00000004  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000006  FFFC      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000008  4800      LDR         R1,=curTime ; curTime
 0000000A  6008      STR         R0,[R1,#0x0] ; curTime
  889:     if (stim[i].status == statInit)
 0000000C  253C      MOV         R5,#0x3C
 0000000E  4365      MUL         R5,R4 ; i
 00000010  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000012  5946      LDR         R6,[R0,R5]
 00000014  2E00      CMP         R6,#0x0
 00000016  D12E      BNE         L_230  ; T=0x00000076
  891:         if ((stim[i].startRef == 0) && (curTime >= stim[i].startTime))
 00000018  4800      LDR         R0,=stim + 0x24 ; stim+36
 0000001A  5940      LDR         R0,[R0,R5]
 0000001C  2800      CMP         R0,#0x0
 0000001E  D128      BNE         L_231  ; T=0x00000072
 00000020  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000022  5941      LDR         R1,[R0,R5]
 00000024  4800      LDR         R0,=curTime ; curTime
 00000026  6800      LDR         R0,[R0,#0x0] ; curTime
 00000028  4288      CMP         R0,R1
 0000002A  D322      BCC         L_231  ; T=0x00000072
  893:             LedOnOff(stim[i].posY, stim[nStimLeds].level, OFF, false);
 0000002C  4800      LDR         R0,=stim + 0x1C ; stim+28
 0000002E  5940      LDR         R0,[R0,R5]
 00000030  4800      LDR         R1,=nStimLeds ; nStimLeds
 00000032  680A      LDR         R2,[R1,#0x0] ; nStimLeds
 00000034  213C      MOV         R1,#0x3C
 00000036  434A      MUL         R2,R1
 00000038  4800      LDR         R1,=stim + 0x20 ; stim+32
 0000003A  5889      LDR         R1,[R1,R2]
 0000003C  2200      MOV         R2,#0x0
 0000003E  2300      MOV         R3,#0x0
 00000040  F7FF      BL          LedOnOff?T  ; T=0x0001  (1)
 00000042  FFDE      BL          LedOnOff?T  ; T=0x0001  (2)
  894:             LedOnOff(stim[i].posY, stim[i].level, ON, true);
 00000044  223C      MOV         R2,#0x3C
 00000046  4362      MUL         R2,R4 ; i
 00000048  4800      LDR         R0,=stim + 0x1C ; stim+28
 0000004A  5880      LDR         R0,[R0,R2]
 0000004C  4800      LDR         R1,=stim + 0x20 ; stim+32
 0000004E  5889      LDR         R1,[R1,R2]
 00000050  2201      MOV         R2,#0x1
 00000052  2301      MOV         R3,#0x1
 00000054  F7FF      BL          LedOnOff?T  ; T=0x0001  (1)
 00000056  FFD4      BL          LedOnOff?T  ; T=0x0001  (2)
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 79  

  895:             curTime = Clock_GetTicks();
 00000058  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 0000005A  FFD2      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 0000005C  4800      LDR         R1,=curTime ; curTime
 0000005E  6008      STR         R0,[R1,#0x0] ; curTime
  896:             stim[i].startTime = curTime;
 00000060  4800      LDR         R0,=curTime ; curTime
 00000062  6801      LDR         R1,[R0,#0x0] ; curTime
 00000064  223C      MOV         R2,#0x3C
 00000066  4362      MUL         R2,R4 ; i
 00000068  4800      LDR         R0,=stim + 0x28 ; stim+40
 0000006A  5081      STR         R1,[R0,R2]
  897:             stim[i].status = statRun;
 0000006C  2003      MOV         R0,#0x3
 0000006E  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000070  5088      STR         R0,[R1,R2]
  898:         }
 00000072          L_231:
  899:         return 1;
 00000072  2001      MOV         R0,#0x1
 00000074  E033      B           L_232  ; T=0x000000DE
  900:     }
 00000076          L_230:
  902:     if (stim[i].status == statRun)                     
 00000076  2E03      CMP         R6,#0x3
 00000078  D130      BNE         L_233  ; T=0x000000DC
  904:         if ((stim[i].stopRef == 0) && (curTime >= stim[i].stopTime))
 0000007A  4800      LDR         R0,=stim + 0x2C ; stim+44
 0000007C  5940      LDR         R0,[R0,R5]
 0000007E  2800      CMP         R0,#0x0
 00000080  D12A      BNE         L_234  ; T=0x000000D8
 00000082  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000084  5941      LDR         R1,[R0,R5]
 00000086  4800      LDR         R0,=curTime ; curTime
 00000088  6800      LDR         R0,[R0,#0x0] ; curTime
 0000008A  4288      CMP         R0,R1
 0000008C  D324      BCC         L_234  ; T=0x000000D8
  906:             LedOnOff(stim[i].posY, stim[0].level, OFF, true);
 0000008E  4800      LDR         R0,=stim + 0x1C ; stim+28
 00000090  5940      LDR         R0,[R0,R5]
 00000092  4800      LDR         R1,=stim + 0x20 ; stim+32
 00000094  6809      LDR         R1,[R1,#0x0] ; stim+32
 00000096  2200      MOV         R2,#0x0
 00000098  2301      MOV         R3,#0x1
 0000009A  F7FF      BL          LedOnOff?T  ; T=0x0001  (1)
 0000009C  FFB1      BL          LedOnOff?T  ; T=0x0001  (2)
  907:             LedOnOff(stim[i].posY, stim[nStimLeds].level, ON, false);
 0000009E  213C      MOV         R1,#0x3C
 000000A0  4361      MUL         R1,R4 ; i
 000000A2  4800      LDR         R0,=stim + 0x1C ; stim+28
 000000A4  5840      LDR         R0,[R0,R1]
 000000A6  4800      LDR         R1,=nStimLeds ; nStimLeds
 000000A8  680A      LDR         R2,[R1,#0x0] ; nStimLeds
 000000AA  213C      MOV         R1,#0x3C
 000000AC  434A      MUL         R2,R1
 000000AE  4800      LDR         R1,=stim + 0x20 ; stim+32
 000000B0  5889      LDR         R1,[R1,R2]
 000000B2  2201      MOV         R2,#0x1
 000000B4  2300      MOV         R3,#0x0
 000000B6  F7FF      BL          LedOnOff?T  ; T=0x0001  (1)
 000000B8  FFA3      BL          LedOnOff?T  ; T=0x0001  (2)
  908:             curTime = Clock_GetTicks();
 000000BA  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 000000BC  FFA1      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 000000BE  4800      LDR         R1,=curTime ; curTime
 000000C0  6008      STR         R0,[R1,#0x0] ; curTime
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 80  

  909:             stim[i].stopTime = curTime;
 000000C2  4800      LDR         R0,=curTime ; curTime
 000000C4  6801      LDR         R1,[R0,#0x0] ; curTime
 000000C6  223C      MOV         R2,#0x3C
 000000C8  4362      MUL         R2,R4 ; i
 000000CA  4800      LDR         R0,=stim + 0x30 ; stim+48
 000000CC  5081      STR         R1,[R0,R2]
  910:             stim[i].status = statDone;
 000000CE  2005      MOV         R0,#0x5
 000000D0  4800      LDR         R1,=stim + 0x4 ; stim+4
 000000D2  5088      STR         R0,[R1,R2]
  911:             return 0;
 000000D4  2000      MOV         R0,#0x0
 000000D6  E002      B           L_232  ; T=0x000000DE
  912:         }
 000000D8          L_234:
  913:         return 1;
 000000D8  2001      MOV         R0,#0x1
 000000DA  E000      B           L_232  ; T=0x000000DE
  914:     }
 000000DC          L_233:
  916:     return 0;
 000000DC  2000      MOV         R0,#0x0
  917: }
 000000DE          L_232:
 000000DE  BC70      POP         {R4-R6}
 000000E0  BC08      POP         {R3}
 000000E2  4718      BX          R3
 000000E4          ENDP ; 'ExecBlink?T'


*** CODE SEGMENT '?PR?ExecSky?T?Human':
  919: int ExecSky(int i)
 00000000  B570      PUSH        {R4-R6,LR}
 00000002  1C04      MOV         R4,R0 ; i
 00000004  ---- Variable 'i' assigned to Register 'R4' ----
  921:     curTime = Clock_GetTicks();
 00000004  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000006  FFFC      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000008  4800      LDR         R1,=curTime ; curTime
 0000000A  6008      STR         R0,[R1,#0x0] ; curTime
  922:     if (stim[i].status == statInit)
 0000000C  253C      MOV         R5,#0x3C
 0000000E  4365      MUL         R5,R4 ; i
 00000010  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000012  5946      LDR         R6,[R0,R5]
 00000014  2E00      CMP         R6,#0x0
 00000016  D121      BNE         L_235  ; T=0x0000005C
  924:         if ((stim[i].startRef == 0) && (curTime >= stim[i].startTime))
 00000018  4800      LDR         R0,=stim + 0x24 ; stim+36
 0000001A  5940      LDR         R0,[R0,R5]
 0000001C  2800      CMP         R0,#0x0
 0000001E  D11B      BNE         L_236  ; T=0x00000058
 00000020  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000022  5941      LDR         R1,[R0,R5]
 00000024  4800      LDR         R0,=curTime ; curTime
 00000026  6800      LDR         R0,[R0,#0x0] ; curTime
 00000028  4288      CMP         R0,R1
 0000002A  D315      BCC         L_236  ; T=0x00000058
  926:             SkyOnOff(stim[i].posX, stim[i].posY, stim[i].level, ON);
 0000002C  4800      LDR         R0,=stim + 0x18 ; stim+24
 0000002E  5940      LDR         R0,[R0,R5]
 00000030  4800      LDR         R1,=stim + 0x1C ; stim+28
 00000032  5949      LDR         R1,[R1,R5]
 00000034  4800      LDR         R2,=stim + 0x20 ; stim+32
 00000036  5952      LDR         R2,[R2,R5]
 00000038  2301      MOV         R3,#0x1
 0000003A  F7FF      BL          SkyOnOff?T  ; T=0x0001  (1)
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 81  

 0000003C  FFE1      BL          SkyOnOff?T  ; T=0x0001  (2)
  927:             curTime = Clock_GetTicks();
 0000003E  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000040  FFDF      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000042  4800      LDR         R1,=curTime ; curTime
 00000044  6008      STR         R0,[R1,#0x0] ; curTime
  928:             stim[i].startTime = curTime;
 00000046  4800      LDR         R0,=curTime ; curTime
 00000048  6801      LDR         R1,[R0,#0x0] ; curTime
 0000004A  223C      MOV         R2,#0x3C
 0000004C  4362      MUL         R2,R4 ; i
 0000004E  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000050  5081      STR         R1,[R0,R2]
  929:             stim[i].status = statRun;
 00000052  2003      MOV         R0,#0x3
 00000054  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000056  5088      STR         R0,[R1,R2]
  930:         }
 00000058          L_236:
  931:         return 1;
 00000058  2001      MOV         R0,#0x1
 0000005A  E026      B           L_237  ; T=0x000000AA
  932:     }
 0000005C          L_235:
  934:     if (stim[i].status == statRun)
 0000005C  2E03      CMP         R6,#0x3
 0000005E  D123      BNE         L_238  ; T=0x000000A8
  936:         if ((stim[i].stopRef == 0) && (curTime >= stim[i].stopTime))
 00000060  4800      LDR         R0,=stim + 0x2C ; stim+44
 00000062  5940      LDR         R0,[R0,R5]
 00000064  2800      CMP         R0,#0x0
 00000066  D11D      BNE         L_239  ; T=0x000000A4
 00000068  4800      LDR         R0,=stim + 0x30 ; stim+48
 0000006A  5941      LDR         R1,[R0,R5]
 0000006C  4800      LDR         R0,=curTime ; curTime
 0000006E  6800      LDR         R0,[R0,#0x0] ; curTime
 00000070  4288      CMP         R0,R1
 00000072  D317      BCC         L_239  ; T=0x000000A4
  938:             SkyOnOff(stim[i].posX, stim[i].posY, stim[i].level, OFF);
 00000074  4800      LDR         R0,=stim + 0x18 ; stim+24
 00000076  5940      LDR         R0,[R0,R5]
 00000078  4800      LDR         R1,=stim + 0x1C ; stim+28
 0000007A  5949      LDR         R1,[R1,R5]
 0000007C  4800      LDR         R2,=stim + 0x20 ; stim+32
 0000007E  5952      LDR         R2,[R2,R5]
 00000080  2300      MOV         R3,#0x0
 00000082  F7FF      BL          SkyOnOff?T  ; T=0x0001  (1)
 00000084  FFBD      BL          SkyOnOff?T  ; T=0x0001  (2)
  939:             curTime = Clock_GetTicks();
 00000086  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000088  FFBB      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 0000008A  4800      LDR         R1,=curTime ; curTime
 0000008C  6008      STR         R0,[R1,#0x0] ; curTime
  940:             stim[i].stopTime = curTime;
 0000008E  4800      LDR         R0,=curTime ; curTime
 00000090  6801      LDR         R1,[R0,#0x0] ; curTime
 00000092  223C      MOV         R2,#0x3C
 00000094  4362      MUL         R2,R4 ; i
 00000096  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000098  5081      STR         R1,[R0,R2]
  941:             stim[i].status = statDone;
 0000009A  2005      MOV         R0,#0x5
 0000009C  4800      LDR         R1,=stim + 0x4 ; stim+4
 0000009E  5088      STR         R0,[R1,R2]
  942:             return 0;
 000000A0  2000      MOV         R0,#0x0
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 82  

 000000A2  E002      B           L_237  ; T=0x000000AA
  943:         }
 000000A4          L_239:
  944:         return 1;
 000000A4  2001      MOV         R0,#0x1
 000000A6  E000      B           L_237  ; T=0x000000AA
  945:     }
 000000A8          L_238:
  947:     return 0;
 000000A8  2000      MOV         R0,#0x0
  949: }      
 000000AA          L_237:
 000000AA  BC70      POP         {R4-R6}
 000000AC  BC08      POP         {R3}
 000000AE  4718      BX          R3
 000000B0          ENDP ; 'ExecSky?T'


*** CODE SEGMENT '?PR?ExecSnd?T?Human':
  951: int ExecSnd(int i)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C07      MOV         R7,R0 ; i
 00000004  ---- Variable 'i' assigned to Register 'R7' ----
 00000004  B084      SUB         R13,#0x10
 00000006  ---- Variable 'tmp' assigned to Register 'R6' ----
 00000006  ---- Variable 'n' assigned to Register 'R5' ----
 00000006  ---- Variable 'board' assigned to Register 'R4' ----
  952: {
 00000006            ; SCOPE-START
  955:     curTime = Clock_GetTicks();
 00000006  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000008  FFFB      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 0000000A  4800      LDR         R1,=curTime ; curTime
 0000000C  6008      STR         R0,[R1,#0x0] ; curTime
  956:     if (stim[i].status == statInit)
 0000000E  213C      MOV         R1,#0x3C
 00000010  4379      MUL         R1,R7 ; i
 00000012  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000014  5840      LDR         R0,[R0,R1]
 00000016  2800      CMP         R0,#0x0
 00000018  D000      BNE         $+4
 0000001A  E0EA      B           L_240  ; T=0x000001F2
  958:         if ((stim[i].startRef == 0) && (curTime >= stim[i].startTime))
 0000001E  4800      LDR         R0,=stim + 0x24 ; stim+36
 00000020  5840      LDR         R0,[R0,R1]
 00000022  2800      CMP         R0,#0x0
 00000024  D000      BNE         $+4
 00000026  E0E2      B           L_241  ; T=0x000001EE
 0000002A  4800      LDR         R0,=stim + 0x28 ; stim+40
 0000002C  5842      LDR         R2,[R0,R1]
 0000002E  4800      LDR         R0,=curTime ; curTime
 00000030  6800      LDR         R0,[R0,#0x0] ; curTime
 00000032  4290      CMP         R0,R2
 00000034  D200      BCC         $+4
 00000036  E0DA      B           L_241  ; T=0x000001EE
  961:             n = stim[i].posY + 2;
 0000003A  4800      LDR         R0,=stim + 0x1C ; stim+28
 0000003C  5845      LDR         R5,[R0,R1]
 0000003E  3502      ADD         R5,#0x2
  963:             if (n == 32) n = 1;
 00000040  2D20      CMP         R5,#0x20 ; n
 00000042  D1FD      BNE         L_242  ; T=0x00000040
 00000044  2501      MOV         R5,#0x1
 00000046          L_242:
  964:             if (n == 33) n = 2;
 00000046  2D21      CMP         R5,#0x21 ; n
 00000048  D1FD      BNE         L_243  ; T=0x00000046
 0000004A  2502      MOV         R5,#0x2
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 83  

 0000004C          L_243:
  966:             if (n < 100) board = n / 8; else board = ((n - 100) / 8) + 4;
 0000004C  2D64      CMP         R5,#0x64 ; n
 0000004E  DA03      BGE         L_244  ; T=0x00000058
 00000050  2108      MOV         R1,#0x8
 00000052  1C28      MOV         R0,R5 ; n
 00000054  F7FF      BL          ?C?SDIV?T  ; T=0x0001  (1) ; ?C?SDIV?T
 00000056  FFD4      BL          ?C?SDIV?T  ; T=0x0001  (2) ; ?C?SDIV?T
 00000058  1C08      MOV         R0,R1
 0000005A  1C04      MOV         R4,R0 ; board
 0000005C  E004      B           L_245  ; T=0x00000068
 0000005E          L_244:
 0000005E  1C28      MOV         R0,R5 ; n
 00000060  3864      SUB         R0,#0x64
 00000062  2108      MOV         R1,#0x8
 00000064  F7FF      BL          ?C?SDIV?T  ; T=0x0001  (1) ; ?C?SDIV?T
 00000066  FFCC      BL          ?C?SDIV?T  ; T=0x0001  (2) ; ?C?SDIV?T
 00000068  1C08      MOV         R0,R1
 0000006A  1C04      MOV         R4,R0
 0000006C  3404      ADD         R4,#0x4
 0000006E          L_245:
  967:             if (n > 100) n = n - 100 + 32;  // correctie voor/achter en board 4=board 0
 0000006E  2D64      CMP         R5,#0x64 ; n
 00000070  DDFD      BLE         L_246  ; T=0x0000006E
 00000072  3D44      SUB         R5,#0x44
 00000074          L_246:
  968:             speaker = n - 8*board;
 00000074  00E1      LSL         R1,R4,#0x3 ; board
 00000076  1A68      SUB         R0,R5,R1 ; n
 00000078  9002      STR         R0,[R13,#0x8] ; speaker
  970:             address   = 0x4E;
 0000007A  204E      MOV         R0,#0x4E
 0000007C  9000      STR         R0,[R13,#0x0] ; address
  971:             buffer[0] = boards[board]; 
 0000007E  00A1      LSL         R1,R4,#0x2 ; board
 00000080  4800      LDR         R0,=boards ; boards
 00000082  5841      LDR         R1,[R0,R1]
 00000084  A803      ADD         R0,R13,#0xC
 00000086  7001      STRB        R1,[R0,#0x0] ; buffer
  972:             I2C_SendByte(address, 1, buffer);
 00000088  9800      LDR         R0,[R13,#0x0] ; address
 0000008A  AA03      ADD         R2,R13,#0xC
 0000008C  2101      MOV         R1,#0x1
 0000008E  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 00000090  FFB7      BL          I2C_SendByte?T  ; T=0x0001  (2)
  975:             tmp = statusBoards[board][0];
 00000092  210C      MOV         R1,#0xC
 00000094  4361      MUL         R1,R4 ; board
 00000096  4800      LDR         R0,=statusBoards ; statusBoards
 00000098  5846      LDR         R6,[R0,R1]
  977:             if (stim[i].kind == stimSnd1) 
 0000009A  223C      MOV         R2,#0x3C
 0000009C  437A      MUL         R2,R7 ; i
 0000009E  4800      LDR         R0,=stim + 0x8 ; stim+8
 000000A0  5880      LDR         R0,[R0,R2]
 000000A2  2865      CMP         R0,#0x65
 000000A4  D102      BNE         L_247  ; T=0x000000AC
  978:                 tmp |= speakers[speaker];       // set speakerbit
 000000A6  9A02      LDR         R2,[R13,#0x8] ; speaker
 000000A8  0092      LSL         R2,R2,#0x2
 000000AA  4800      LDR         R0,=speakers ; speakers
 000000AC  5880      LDR         R0,[R0,R2]
 000000AE  4306      ORR         R6,R0
 000000B0  E001      B           L_248  ; T=0x000000B6
 000000B2          L_247:
  980:                 tmp &= ~speakers[speaker];      // clr speakerbit 
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 84  

 000000B2  9A02      LDR         R2,[R13,#0x8] ; speaker
 000000B4  0092      LSL         R2,R2,#0x2
 000000B6  4800      LDR         R0,=speakers ; speakers
 000000B8  5880      LDR         R0,[R0,R2]
 000000BA  4386      BIC         R6,R0
 000000BC          L_248:
  982:             statusBoards[board][0] = tmp;
 000000BC  4800      LDR         R0,=statusBoards ; statusBoards
 000000BE  5046      STR         R6,[R0,R1] ; tmp
  983:             buffer[0] = tmp;
 000000C0  1C31      MOV         R1,R6 ; tmp
 000000C2  A803      ADD         R0,R13,#0xC
 000000C4  7001      STRB        R1,[R0,#0x0] ; buffer
  984:             address   = 0x40;
 000000C6  2040      MOV         R0,#0x40
 000000C8  9000      STR         R0,[R13,#0x0] ; address
  985:             I2C_SendByte(address, 1, buffer);
 000000CA  9800      LDR         R0,[R13,#0x0] ; address
 000000CC  AA03      ADD         R2,R13,#0xC
 000000CE  2101      MOV         R1,#0x1
 000000D0  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 000000D2  FF96      BL          I2C_SendByte?T  ; T=0x0001  (2)
  987:             if (speaker < 4)
 000000D4  9A02      LDR         R2,[R13,#0x8] ; speaker
 000000D6  2A04      CMP         R2,#0x4
 000000D8  DA14      BGE         L_249  ; T=0x00000104
  989:                 address  = 0x44;
 000000DA  2044      MOV         R0,#0x44
 000000DC  9000      STR         R0,[R13,#0x0] ; address
  990:                 tmp = statusBoards[board][1];
 000000DE  210C      MOV         R1,#0xC
 000000E0  4361      MUL         R1,R4 ; board
 000000E2  4800      LDR         R0,=statusBoards + 0x4 ; statusBoards+4
 000000E4  5846      LDR         R6,[R0,R1]
  991:                 if (stim[i].kind == stimSnd1)
 000000E6  233C      MOV         R3,#0x3C
 000000E8  437B      MUL         R3,R7 ; i
 000000EA  4800      LDR         R0,=stim + 0x8 ; stim+8
 000000EC  58C0      LDR         R0,[R0,R3]
 000000EE  2865      CMP         R0,#0x65
 000000F0  D101      BNE         L_250  ; T=0x000000F6
  992:                     tmp &= gain1[speaker];
 000000F2  0093      LSL         R3,R2,#0x2
 000000F4  4800      LDR         R0,=gain1 ; gain1
 000000F6  58C0      LDR         R0,[R0,R3]
 000000F8  4006      AND         R6,R0
 000000FA  E000      B           L_251  ; T=0x000000FE
 000000FC          L_250:
  994:                     tmp &= gain2[speaker];
 000000FC  0092      LSL         R2,R2,#0x2
 000000FE  4800      LDR         R0,=gain2 ; gain2
 00000100  5880      LDR         R0,[R0,R2]
 00000102  4006      AND         R6,R0
 00000104          L_251:
  995:                 statusBoards[board][1] = tmp;
 00000104  4800      LDR         R0,=statusBoards + 0x4 ; statusBoards+4
 00000106  5046      STR         R6,[R0,R1] ; tmp
  996:             }
 00000108  E015      B           L_252  ; T=0x00000136
 0000010A          L_249:
  999:                 address  = 0x42;
 0000010A  2042      MOV         R0,#0x42
 0000010C  9000      STR         R0,[R13,#0x0] ; address
 1000:                 tmp = statusBoards[board][2];
 0000010E  210C      MOV         R1,#0xC
 00000110  4361      MUL         R1,R4 ; board
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 85  

 00000112  4800      LDR         R0,=statusBoards + 0x8 ; statusBoards+8
 00000114  5846      LDR         R6,[R0,R1]
 1001:                 if (stim[i].kind == stimSnd1)
 00000116  223C      MOV         R2,#0x3C
 00000118  437A      MUL         R2,R7 ; i
 0000011A  4800      LDR         R0,=stim + 0x8 ; stim+8
 0000011C  5880      LDR         R0,[R0,R2]
 0000011E  2865      CMP         R0,#0x65
 00000120  D102      BNE         L_253  ; T=0x00000128
 1002:                     tmp &= gain1[speaker];
 00000122  9A02      LDR         R2,[R13,#0x8] ; speaker
 00000124  0092      LSL         R2,R2,#0x2
 00000126  4800      LDR         R0,=gain1 ; gain1
 00000128  5880      LDR         R0,[R0,R2]
 0000012A  4006      AND         R6,R0
 0000012C  E001      B           L_254  ; T=0x00000132
 0000012E          L_253:
 1004:                     tmp &= gain2[speaker];
 0000012E  9A02      LDR         R2,[R13,#0x8] ; speaker
 00000130  0092      LSL         R2,R2,#0x2
 00000132  4800      LDR         R0,=gain2 ; gain2
 00000134  5880      LDR         R0,[R0,R2]
 00000136  4006      AND         R6,R0
 00000138          L_254:
 1005:                 statusBoards[board][2] = tmp;
 00000138  4800      LDR         R0,=statusBoards + 0x8 ; statusBoards+8
 0000013A  5046      STR         R6,[R0,R1] ; tmp
 1006:             }
 0000013C          L_252:
 1008:             buffer[0] = tmp;
 0000013C  1C31      MOV         R1,R6 ; tmp
 0000013E  A803      ADD         R0,R13,#0xC
 00000140  7001      STRB        R1,[R0,#0x0] ; buffer
 1009:             I2C_SendByte(address, 1, buffer);
 00000142  9800      LDR         R0,[R13,#0x0] ; address
 00000144  AA03      ADD         R2,R13,#0xC
 00000146  2101      MOV         R1,#0x1
 00000148  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 0000014A  FF5A      BL          I2C_SendByte?T  ; T=0x0001  (2)
 1012:             curTime = Clock_GetTicks();
 0000014C  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 0000014E  FF58      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000150  4800      LDR         R1,=curTime ; curTime
 00000152  6008      STR         R0,[R1,#0x0] ; curTime
 1014:             if (snd12Flag == 3) // beide triggeren
 00000154  4800      LDR         R0,=snd12Flag ; snd12Flag
 00000156  6800      LDR         R0,[R0,#0x0] ; snd12Flag
 00000158  2803      CMP         R0,#0x3
 0000015A  D130      BNE         L_255  ; T=0x000001BE
 1016:                 if (stim[i].kind == stimSnd1) tmpSnd1[0] = 0; else tmpSnd2[0] = 0; 
 0000015C  213C      MOV         R1,#0x3C
 0000015E  4379      MUL         R1,R7 ; i
 00000160  4800      LDR         R0,=stim + 0x8 ; stim+8
 00000162  5840      LDR         R0,[R0,R1]
 00000164  2865      CMP         R0,#0x65
 00000166  D100      BNE         L_256  ; T=0x0000016A
 00000168  2100      MOV         R1,#0x0
 0000016A  4800      LDR         R0,=tmpSnd1 ; tmpSnd1
 0000016C  6001      STR         R1,[R0,#0x0] ; tmpSnd1
 0000016E  E7FF      B           L_257  ; T=0x00000170
 00000170          L_256:
 00000170  2100      MOV         R1,#0x0
 00000172  4800      LDR         R0,=tmpSnd2 ; tmpSnd2
 00000174  6001      STR         R1,[R0,#0x0] ; tmpSnd2
 00000176          L_257:
 1017:                 if ((tmpSnd1[0] == 0) && (tmpSnd2[0] == 0)) // beide geladen
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 86  

 00000176  4800      LDR         R0,=tmpSnd1 ; tmpSnd1
 00000178  6800      LDR         R0,[R0,#0x0] ; tmpSnd1
 0000017A  2800      CMP         R0,#0x0
 0000017C  D137      BNE         L_241  ; T=0x000001EE
 0000017E  4800      LDR         R0,=tmpSnd2 ; tmpSnd2
 00000180  6800      LDR         R0,[R0,#0x0] ; tmpSnd2
 00000182  2800      CMP         R0,#0x0
 00000184  D133      BNE         L_241  ; T=0x000001EE
 1019:                     Trigger(outRP2_1 | outRP2_2,true);
 00000186  2006      MOV         R0,#0x6
 00000188  2101      MOV         R1,#0x1
 0000018A  F7FF      BL          Trigger?T  ; T=0x0001  (1)
 0000018C  FF39      BL          Trigger?T  ; T=0x0001  (2)
 1020:                     stim[tmpSnd1[3]].startTime = curTime;
 0000018E  4800      LDR         R0,=curTime ; curTime
 00000190  6800      LDR         R0,[R0,#0x0] ; curTime
 00000192  4800      LDR         R1,=tmpSnd1 + 0xC ; tmpSnd1+12
 00000194  680A      LDR         R2,[R1,#0x0] ; tmpSnd1+12
 00000196  233C      MOV         R3,#0x3C
 00000198  4353      MUL         R3,R2
 0000019A  4800      LDR         R1,=stim + 0x28 ; stim+40
 0000019C  50C8      STR         R0,[R1,R3]
 1021:                     stim[tmpSnd1[3]].status    = statRun;
 0000019E  2003      MOV         R0,#0x3
 000001A0  213C      MOV         R1,#0x3C
 000001A2  434A      MUL         R2,R1
 000001A4  4800      LDR         R1,=stim + 0x4 ; stim+4
 000001A6  5088      STR         R0,[R1,R2]
 1022:                     stim[tmpSnd2[3]].startTime = curTime;
 000001A8  4800      LDR         R0,=curTime ; curTime
 000001AA  6800      LDR         R0,[R0,#0x0] ; curTime
 000001AC  4800      LDR         R1,=tmpSnd2 + 0xC ; tmpSnd2+12
 000001AE  680A      LDR         R2,[R1,#0x0] ; tmpSnd2+12
 000001B0  233C      MOV         R3,#0x3C
 000001B2  4353      MUL         R3,R2
 000001B4  4800      LDR         R1,=stim + 0x28 ; stim+40
 000001B6  50C8      STR         R0,[R1,R3]
 1023:                     stim[tmpSnd2[3]].status    = statRun;
 000001B8  2003      MOV         R0,#0x3
 000001BA  213C      MOV         R1,#0x3C
 000001BC  434A      MUL         R2,R1
 000001BE  4800      LDR         R1,=stim + 0x4 ; stim+4
 000001C0  5088      STR         R0,[R1,R2]
 1025:             }
 000001C2  E014      B           L_241  ; T=0x000001EE
 000001C4          L_255:
 1028:                 if (stim[i].kind == stimSnd1) 
 000001C4  213C      MOV         R1,#0x3C
 000001C6  4379      MUL         R1,R7 ; i
 000001C8  4800      LDR         R0,=stim + 0x8 ; stim+8
 000001CA  5840      LDR         R0,[R0,R1]
 000001CC  2865      CMP         R0,#0x65
 000001CE  D101      BNE         L_260  ; T=0x000001D4
 1029:                     Trigger(outRP2_1,true); // Start
 000001D0  2002      MOV         R0,#0x2
 000001D2  2101      MOV         R1,#0x1
 000001D4  F7FF      BL          Trigger?T  ; T=0x0001  (1)
 000001D6  FF14      BL          Trigger?T  ; T=0x0001  (2)
 000001D8  E000      B           L_261  ; T=0x000001DC
 000001DA          L_260:
 1031:                     Trigger(outRP2_2,true);
 000001DA  2004      MOV         R0,#0x4
 000001DC  2101      MOV         R1,#0x1
 000001DE  F7FF      BL          Trigger?T  ; T=0x0001  (1)
 000001E0  FF0F      BL          Trigger?T  ; T=0x0001  (2)
 000001E2          L_261:
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 87  

 1033:                 stim[i].startTime = curTime;
 000001E2  4800      LDR         R0,=curTime ; curTime
 000001E4  6801      LDR         R1,[R0,#0x0] ; curTime
 000001E6  223C      MOV         R2,#0x3C
 000001E8  437A      MUL         R2,R7 ; i
 000001EA  4800      LDR         R0,=stim + 0x28 ; stim+40
 000001EC  5081      STR         R1,[R0,R2]
 1034:                 stim[i].status    = statRun;
 000001EE  2003      MOV         R0,#0x3
 000001F0  4800      LDR         R1,=stim + 0x4 ; stim+4
 000001F2  5088      STR         R0,[R1,R2]
 1037:         }
 000001F4          L_241:
 1038:         return 1;
 000001F4  2001      MOV         R0,#0x1
 000001F6  E09A      B           L_262  ; T=0x0000032E
 1039:     }
 000001F8          L_240:
 1040:     if (stim[i].status == statRun)
 000001F8  213C      MOV         R1,#0x3C
 000001FA  4379      MUL         R1,R7 ; i
 000001FC  4800      LDR         R0,=stim + 0x4 ; stim+4
 000001FE  5840      LDR         R0,[R0,R1]
 00000200  2803      CMP         R0,#0x3
 00000202  D000      BNE         $+4
 00000204  E092      B           L_263  ; T=0x0000032C
 1042:         if (curTime > (stim[i].startTime+100))
 00000208  213C      MOV         R1,#0x3C
 0000020A  4379      MUL         R1,R7 ; i
 0000020C  4800      LDR         R0,=stim + 0x28 ; stim+40
 0000020E  5841      LDR         R1,[R0,R1]
 00000210  3164      ADD         R1,#0x64
 00000212  4800      LDR         R0,=curTime ; curTime
 00000214  6800      LDR         R0,[R0,#0x0] ; curTime
 00000216  4288      CMP         R0,R1
 00000218  D800      BLS         $+4
 0000021A  E085      B           L_264  ; T=0x00000328
 1044:             if (stim[i].kind == stimSnd1)
 0000021E  213C      MOV         R1,#0x3C
 00000220  4379      MUL         R1,R7 ; i
 00000222  4800      LDR         R0,=stim + 0x8 ; stim+8
 00000224  5840      LDR         R0,[R0,R1]
 00000226  2865      CMP         R0,#0x65
 00000228  D1FF      BNE         L_265  ; T=0x0000022A
 1045:                 bit = TstBitPar(inpRP2_1);
 0000022A  2002      MOV         R0,#0x2
 0000022C  F7FF      BL          TstBitPar?T  ; T=0x0001  (1)
 0000022E  FEE8      BL          TstBitPar?T  ; T=0x0001  (2)
 00000230  9001      STR         R0,[R13,#0x4] ; bit
 00000232  E7FE      B           L_266  ; T=0x00000232
 00000234          L_265:
 1047:                 bit = TstBitPar(inpRP2_2);
 00000234  2004      MOV         R0,#0x4
 00000236  F7FF      BL          TstBitPar?T  ; T=0x0001  (1)
 00000238  FEE3      BL          TstBitPar?T  ; T=0x0001  (2)
 0000023A  9001      STR         R0,[R13,#0x4] ; bit
 0000023C          L_266:
 1048:             if (bit == 0)
 0000023C  9801      LDR         R0,[R13,#0x4] ; bit
 0000023E  2800      CMP         R0,#0x0
 00000240  D000      BNE         $+4
 00000242  E071      B           L_264  ; T=0x00000328
 1050:                 stim[i].stopTime = curTime;
 00000246  4800      LDR         R0,=curTime ; curTime
 00000248  6802      LDR         R2,[R0,#0x0] ; curTime
 0000024A  213C      MOV         R1,#0x3C
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 88  

 0000024C  4379      MUL         R1,R7 ; i
 0000024E  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000250  5042      STR         R2,[R0,R1]
 1051:                 stim[i].status   = statDone;
 00000252  2005      MOV         R0,#0x5
 00000254  4800      LDR         R2,=stim + 0x4 ; stim+4
 00000256  5050      STR         R0,[R2,R1]
 1053:                 n = stim[i].posY + 2;
 00000258  4800      LDR         R0,=stim + 0x1C ; stim+28
 0000025A  5845      LDR         R5,[R0,R1]
 0000025C  3502      ADD         R5,#0x2
 1055:                 if (n == 32) n = 1;
 0000025E  2D20      CMP         R5,#0x20 ; n
 00000260  D1FA      BNE         L_268  ; T=0x00000258
 00000262  2501      MOV         R5,#0x1
 00000264          L_268:
 1056:                 if (n == 33) n = 2;
 00000264  2D21      CMP         R5,#0x21 ; n
 00000266  D1FA      BNE         L_269  ; T=0x0000025E
 00000268  2502      MOV         R5,#0x2
 0000026A          L_269:
 1057:                 if (n < 100) board = n / 8; else board = ((n - 100) / 8) + 4;
 0000026A  2D64      CMP         R5,#0x64 ; n
 0000026C  DA00      BGE         L_270  ; T=0x00000270
 0000026E  2108      MOV         R1,#0x8
 00000270  1C28      MOV         R0,R5 ; n
 00000272  F7FF      BL          ?C?SDIV?T  ; T=0x0001  (1) ; ?C?SDIV?T
 00000274  FEC5      BL          ?C?SDIV?T  ; T=0x0001  (2) ; ?C?SDIV?T
 00000276  1C08      MOV         R0,R1
 00000278  1C04      MOV         R4,R0 ; board
 0000027A  E001      B           L_271  ; T=0x00000280
 0000027C          L_270:
 0000027C  1C28      MOV         R0,R5 ; n
 0000027E  3864      SUB         R0,#0x64
 00000280  2108      MOV         R1,#0x8
 00000282  F7FF      BL          ?C?SDIV?T  ; T=0x0001  (1) ; ?C?SDIV?T
 00000284  FEBD      BL          ?C?SDIV?T  ; T=0x0001  (2) ; ?C?SDIV?T
 00000286  1C08      MOV         R0,R1
 00000288  1C04      MOV         R4,R0
 0000028A  3404      ADD         R4,#0x4
 0000028C          L_271:
 1058:                 if (n > 100) n = n - 100 + 32;  // correctie voor/achter en board 4=board 0
 0000028C  2D64      CMP         R5,#0x64 ; n
 0000028E  DDFA      BLE         L_272  ; T=0x00000286
 00000290  3D44      SUB         R5,#0x44
 00000292          L_272:
 1059:                 speaker = n - 8*board;
 00000292  00E1      LSL         R1,R4,#0x3 ; board
 00000294  1A68      SUB         R0,R5,R1 ; n
 00000296  9002      STR         R0,[R13,#0x8] ; speaker
 1060:                 address   = 0x4E;
 00000298  204E      MOV         R0,#0x4E
 0000029A  9000      STR         R0,[R13,#0x0] ; address
 1061:                 buffer[0] = boards[board]; 
 0000029C  00A1      LSL         R1,R4,#0x2 ; board
 0000029E  4800      LDR         R0,=boards ; boards
 000002A0  5841      LDR         R1,[R0,R1]
 000002A2  A803      ADD         R0,R13,#0xC
 000002A4  7001      STRB        R1,[R0,#0x0] ; buffer
 1062:                 I2C_SendByte(address, 1, buffer);
 000002A6  9800      LDR         R0,[R13,#0x0] ; address
 000002A8  AA03      ADD         R2,R13,#0xC
 000002AA  2101      MOV         R1,#0x1
 000002AC  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 000002AE  FEA8      BL          I2C_SendByte?T  ; T=0x0001  (2)
 1064:                 if (speaker < 4)
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 89  

 000002B0  9A02      LDR         R2,[R13,#0x8] ; speaker
 000002B2  2A04      CMP         R2,#0x4
 000002B4  DA13      BGE         L_273  ; T=0x000002DE
 1066:                     address  = 0x44;
 000002B6  2044      MOV         R0,#0x44
 000002B8  9000      STR         R0,[R13,#0x0] ; address
 1067:                     tmp = statusBoards[board][1];
 000002BA  210C      MOV         R1,#0xC
 000002BC  4361      MUL         R1,R4 ; board
 000002BE  4800      LDR         R0,=statusBoards + 0x4 ; statusBoards+4
 000002C0  5846      LDR         R6,[R0,R1]
 1068:                     if (stim[i].kind == stimSnd1)
 000002C2  233C      MOV         R3,#0x3C
 000002C4  437B      MUL         R3,R7 ; i
 000002C6  4800      LDR         R0,=stim + 0x8 ; stim+8
 000002C8  58C0      LDR         R0,[R0,R3]
 000002CA  2865      CMP         R0,#0x65
 000002CC  D1FF      BNE         L_274  ; T=0x000002CE
 1069:                         tmp |= ~gain1[speaker];
 000002CE  0093      LSL         R3,R2,#0x2
 000002D0  4800      LDR         R0,=gain1 ; gain1
 000002D2  58C0      LDR         R0,[R0,R3]
 000002D4  43C0      MVN         R0,R0
 000002D6  4306      ORR         R6,R0
 000002D8  E7FE      B           L_275  ; T=0x000002D8
 000002DA          L_274:
 1071:                         tmp |= ~gain2[speaker];
 000002DA  0092      LSL         R2,R2,#0x2
 000002DC  4800      LDR         R0,=gain2 ; gain2
 000002DE  5880      LDR         R0,[R0,R2]
 000002E0  43C0      MVN         R0,R0
 000002E2  4306      ORR         R6,R0
 000002E4          L_275:
 1072:                     statusBoards[board][1] = tmp;
 000002E4  4800      LDR         R0,=statusBoards + 0x4 ; statusBoards+4
 000002E6  5046      STR         R6,[R0,R1] ; tmp
 1073:                 }
 000002E8  E014      B           L_276  ; T=0x00000314
 000002EA          L_273:
 1076:                     address  = 0x42;
 000002EA  2042      MOV         R0,#0x42
 000002EC  9000      STR         R0,[R13,#0x0] ; address
 1077:                     tmp = statusBoards[board][2];
 000002EE  210C      MOV         R1,#0xC
 000002F0  4361      MUL         R1,R4 ; board
 000002F2  4800      LDR         R0,=statusBoards + 0x8 ; statusBoards+8
 000002F4  5846      LDR         R6,[R0,R1]
 1078:                     if (stim[i].kind == stimSnd1)
 000002F6  223C      MOV         R2,#0x3C
 000002F8  437A      MUL         R2,R7 ; i
 000002FA  4800      LDR         R0,=stim + 0x8 ; stim+8
 000002FC  5880      LDR         R0,[R0,R2]
 000002FE  2865      CMP         R0,#0x65
 00000300  D100      BNE         L_277  ; T=0x00000304
 1079:                         tmp |= ~gain1[speaker];
 00000302  9A02      LDR         R2,[R13,#0x8] ; speaker
 00000304  0092      LSL         R2,R2,#0x2
 00000306  4800      LDR         R0,=gain1 ; gain1
 00000308  5880      LDR         R0,[R0,R2]
 0000030A  43C0      MVN         R0,R0
 0000030C  4306      ORR         R6,R0
 0000030E  E7FF      B           L_278  ; T=0x00000310
 00000310          L_277:
 1081:                         tmp |= ~gain2[speaker];
 00000310  9A02      LDR         R2,[R13,#0x8] ; speaker
 00000312  0092      LSL         R2,R2,#0x2
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 90  

 00000314  4800      LDR         R0,=gain2 ; gain2
 00000316  5880      LDR         R0,[R0,R2]
 00000318  43C0      MVN         R0,R0
 0000031A  4306      ORR         R6,R0
 0000031C          L_278:
 1082:                     statusBoards[board][2] = tmp;
 0000031C  4800      LDR         R0,=statusBoards + 0x8 ; statusBoards+8
 0000031E  5046      STR         R6,[R0,R1] ; tmp
 1083:                 }
 00000320          L_276:
 1085:                 buffer[0] = tmp;
 00000320  1C31      MOV         R1,R6 ; tmp
 00000322  A803      ADD         R0,R13,#0xC
 00000324  7001      STRB        R1,[R0,#0x0] ; buffer
 1086:                 I2C_SendByte(address, 1, buffer);
 00000326  9800      LDR         R0,[R13,#0x0] ; address
 00000328  AA03      ADD         R2,R13,#0xC
 0000032A  2101      MOV         R1,#0x1
 0000032C  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 0000032E  FE68      BL          I2C_SendByte?T  ; T=0x0001  (2)
 1087:                  return 0;
 00000330  2000      MOV         R0,#0x0
 00000332  E7FC      B           L_262  ; T=0x0000032E
 1089:         }
 00000334          L_264:
 1090:         return 1;
 00000334  2001      MOV         R0,#0x1
 00000336  E7FA      B           L_262  ; T=0x0000032E
 1091:     }
 00000338          L_263:
 1092:     return 0;
 00000338  2000      MOV         R0,#0x0
 0000033A            ; SCOPE-END
 1093: }
 0000033A          L_262:
 0000033A  B004      ADD         R13,#0x10
 0000033C  BCF0      POP         {R4-R7}
 0000033E  BC08      POP         {R3}
 00000340  4718      BX          R3
 00000342          ENDP ; 'ExecSnd?T'


*** CODE SEGMENT '?PR?SpeakersOff?T?Human':
 1095: void SpeakersOff(void)
 00000000  B510      PUSH        {R4,LR}
 00000002  B081      SUB         R13,#0x4
 1096: { // niet goed, per board moeten sig en speakers worden gereset.
 00000004            ; SCOPE-START
 1100:     address   = 0x4E;   // board
 00000004  244E      MOV         R4,#0x4E
 00000006  ---- Variable 'address' assigned to Register 'R4' ----
 1101:     buffer[0] = 0xFF;   I2C_SendByte(address, 1, buffer);
 00000006  21FF      MOV         R1,#0xFF
 00000008  A800      ADD         R0,R13,#0x0
 0000000A  7001      STRB        R1,[R0,#0x0] ; buffer
 0000000C  1C20      MOV         R0,R4
 0000000E  AA00      ADD         R2,R13,#0x0
 00000010  2101      MOV         R1,#0x1
 00000012  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 00000014  FFF5      BL          I2C_SendByte?T  ; T=0x0001  (2)
 1103:     address   = 0x40;   // signal
 00000016  2440      MOV         R4,#0x40
 1104:     buffer[0] = 0xFF;   I2C_SendByte(address, 1, buffer);
 00000018  21FF      MOV         R1,#0xFF
 0000001A  A800      ADD         R0,R13,#0x0
 0000001C  7001      STRB        R1,[R0,#0x0] ; buffer
 0000001E  1C20      MOV         R0,R4
 00000020  AA00      ADD         R2,R13,#0x0
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 91  

 00000022  2101      MOV         R1,#0x1
 00000024  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 00000026  FFEC      BL          I2C_SendByte?T  ; T=0x0001  (2)
 1106:     buffer[0] = 0xFF;   // speakers
 00000028  21FF      MOV         R1,#0xFF
 0000002A  A800      ADD         R0,R13,#0x0
 0000002C  7001      STRB        R1,[R0,#0x0] ; buffer
 1107:     address  = 0x44;    I2C_SendByte(address, 1, buffer);
 0000002E  2444      MOV         R4,#0x44
 00000030  1C20      MOV         R0,R4
 00000032  AA00      ADD         R2,R13,#0x0
 00000034  2101      MOV         R1,#0x1
 00000036  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 00000038  FFE3      BL          I2C_SendByte?T  ; T=0x0001  (2)
 1108:     address  = 0x42;    I2C_SendByte(address, 1, buffer);
 0000003A  2442      MOV         R4,#0x42
 0000003C  1C20      MOV         R0,R4
 0000003E  AA00      ADD         R2,R13,#0x0
 00000040  2101      MOV         R1,#0x1
 00000042  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 00000044  FFDD      BL          I2C_SendByte?T  ; T=0x0001  (2)
 00000046            ; SCOPE-END
 1109: }
 00000046  B001      ADD         R13,#0x4
 00000048  BC10      POP         {R4}
 0000004A  BC08      POP         {R3}
 0000004C  4718      BX          R3
 0000004E          ENDP ; 'SpeakersOff?T'


*** CODE SEGMENT '?PR?ExecEvent?T?Human':
 1110: void ExecEvent(int event)
 00000000  B530      PUSH        {R4-R5,LR}
 00000002  1C04      MOV         R4,R0 ; event
 00000004  ---- Variable 'event' assigned to Register 'R4' ----
 1111: {
 00000004            ; SCOPE-START
 1113:     time = Clock_GetTicks();
 00000004  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000006  FFFC      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000008  1C02      MOV         R2,R0 ; time
 0000000A  ---- Variable 'time' assigned to Register 'R2' ----
 1114:     for (i = 0; i <= nStim; i++)
 0000000A  2100      MOV         R1,#0x0
 0000000C  ---- Variable 'i' assigned to Register 'R1' ----
 0000000C  E01A      B           L_281  ; T=0x00000044
 0000000E          L_282:
 1116:         if (stim[i].startRef == event)
 0000000E  233C      MOV         R3,#0x3C
 00000010  434B      MUL         R3,R1 ; i
 00000012  4800      LDR         R0,=stim + 0x24 ; stim+36
 00000014  58C5      LDR         R5,[R0,R3]
 00000016  42A5      CMP         R5,R4 ; event
 00000018  D107      BNE         L_284  ; T=0x0000002A
 1118:             stim[i].startRef = 0;
 0000001A  2000      MOV         R0,#0x0
 0000001C  4800      LDR         R5,=stim + 0x24 ; stim+36
 0000001E  50E8      STR         R0,[R5,R3]
 1119:             stim[i].startTime += time;
 00000020  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000022  18C0      ADD         R0,R3 ; stim+40
 00000024  6805      LDR         R5,[R0,#0x0]
 00000026  18AD      ADD         R5,R2 ; time
 00000028  6005      STR         R5,[R0,#0x0]
 1120:         }
 0000002A          L_284:
 1121:         if (stim[i].stopRef == event)
 0000002A  4800      LDR         R0,=stim + 0x2C ; stim+44
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 92  

 0000002C  58C5      LDR         R5,[R0,R3]
 0000002E  42A5      CMP         R5,R4 ; event
 00000030  D107      BNE         L_279  ; T=0x00000042
 1123:             stim[i].stopRef = 0;
 00000032  2000      MOV         R0,#0x0
 00000034  4800      LDR         R5,=stim + 0x2C ; stim+44
 00000036  50E8      STR         R0,[R5,R3]
 1124:             stim[i].stopTime += time;
 00000038  4800      LDR         R0,=stim + 0x30 ; stim+48
 0000003A  18C0      ADD         R0,R3 ; stim+48
 0000003C  6803      LDR         R3,[R0,#0x0]
 0000003E  189B      ADD         R3,R2 ; time
 00000040  6003      STR         R3,[R0,#0x0]
 1126:     }
 00000042          L_279:
 00000042  3101      ADD         R1,#0x1
 00000044          L_281:
 00000044  4800      LDR         R0,=nStim ; nStim
 00000046  6800      LDR         R0,[R0,#0x0] ; nStim
 00000048  4281      CMP         R1,R0 ; i
 0000004A  DDE0      BLE         L_282  ; T=0x0000000E
 0000004C            ; SCOPE-END
 1127: }
 0000004C  BC30      POP         {R4-R5}
 0000004E  BC08      POP         {R3}
 00000050  4718      BX          R3
 00000052          ENDP ; 'ExecEvent?T'


*** CODE SEGMENT '?PR?ExecTrg0?T?Human':
 1129: int ExecTrg0(int i)
 00000000  B570      PUSH        {R4-R6,LR}
 00000002  1C06      MOV         R6,R0 ; i
 00000004  ---- Variable 'i' assigned to Register 'R6' ----
 00000004  ---- Variable 'bit' assigned to Register 'R4' ----
 1130: {
 00000004            ; SCOPE-START
 1132:     curTime = Clock_GetTicks();
 00000004  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000006  FFFC      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000008  4800      LDR         R1,=curTime ; curTime
 0000000A  6008      STR         R0,[R1,#0x0] ; curTime
 1133:     if (stim[i].status == statInit)
 0000000C  253C      MOV         R5,#0x3C
 0000000E  4375      MUL         R5,R6 ; i
 00000010  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000012  5940      LDR         R0,[R0,R5]
 00000014  2800      CMP         R0,#0x0
 00000016  D128      BNE         L_286  ; T=0x0000006A
 1135:         if ((stim[i].startRef == 0) && (curTime >= stim[i].startTime))
 00000018  4800      LDR         R0,=stim + 0x24 ; stim+36
 0000001A  5940      LDR         R0,[R0,R5]
 0000001C  2800      CMP         R0,#0x0
 0000001E  D122      BNE         L_287  ; T=0x00000066
 00000020  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000022  5941      LDR         R1,[R0,R5]
 00000024  4800      LDR         R0,=curTime ; curTime
 00000026  6800      LDR         R0,[R0,#0x0] ; curTime
 00000028  4288      CMP         R0,R1
 0000002A  D31C      BCC         L_287  ; T=0x00000066
 1137:             bit = TstBitPar(inpExtTrigger);
 0000002C  2010      MOV         R0,#0x10
 0000002E  F7FF      BL          TstBitPar?T  ; T=0x0001  (1)
 00000030  FFE7      BL          TstBitPar?T  ; T=0x0001  (2)
 00000032  1C04      MOV         R4,R0 ; bit
 1138:             if (stim[i].edge == 1)
 00000034  223C      MOV         R2,#0x3C
 00000036  4372      MUL         R2,R6 ; i
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 93  

 00000038  4800      LDR         R0,=stim + 0x10 ; stim+16
 0000003A  5880      LDR         R0,[R0,R2]
 0000003C  2801      CMP         R0,#0x1
 0000003E  D109      BNE         L_288  ; T=0x00000054
 1140:                 if (bit == 0)
 00000040  2C00      CMP         R4,#0x0 ; bit
 00000042  D110      BNE         L_287  ; T=0x00000066
 1142:                     stim[i].startTime = curTime;
 00000044  4800      LDR         R0,=curTime ; curTime
 00000046  6800      LDR         R0,[R0,#0x0] ; curTime
 00000048  4800      LDR         R1,=stim + 0x28 ; stim+40
 0000004A  5088      STR         R0,[R1,R2]
 1143:                     stim[i].status    = statRun;
 0000004C  2003      MOV         R0,#0x3
 0000004E  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000050  5088      STR         R0,[R1,R2]
 1145:             }
 00000052  E008      B           L_287  ; T=0x00000066
 00000054          L_288:
 1148:                 if (bit > 0)
 00000054  2C00      CMP         R4,#0x0 ; bit
 00000056  DD06      BLE         L_287  ; T=0x00000066
 1150:                     stim[i].startTime = curTime;
 00000058  4800      LDR         R0,=curTime ; curTime
 0000005A  6800      LDR         R0,[R0,#0x0] ; curTime
 0000005C  4800      LDR         R1,=stim + 0x28 ; stim+40
 0000005E  5088      STR         R0,[R1,R2]
 1151:                     stim[i].status    = statRun;
 00000060  2003      MOV         R0,#0x3
 00000062  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000064  5088      STR         R0,[R1,R2]
 1154:         }
 00000066          L_287:
 1155:         return 1;
 00000066  2001      MOV         R0,#0x1
 00000068  E02E      B           L_292  ; T=0x000000C8
 1156:     }
 0000006A          L_286:
 1157:     if (stim[i].status == statRun)
 0000006A  4800      LDR         R0,=stim + 0x4 ; stim+4
 0000006C  5940      LDR         R0,[R0,R5]
 0000006E  2803      CMP         R0,#0x3
 00000070  D129      BNE         L_293  ; T=0x000000C6
 1159:         bit = TstBitPar(inpExtTrigger);
 00000072  2010      MOV         R0,#0x10
 00000074  F7FF      BL          TstBitPar?T  ; T=0x0001  (1)
 00000076  FFC4      BL          TstBitPar?T  ; T=0x0001  (2)
 00000078  1C04      MOV         R4,R0 ; bit
 1160:         if (stim[i].edge == 1)
 0000007A  253C      MOV         R5,#0x3C
 0000007C  4375      MUL         R5,R6 ; i
 0000007E  4800      LDR         R0,=stim + 0x10 ; stim+16
 00000080  5940      LDR         R0,[R0,R5]
 00000082  2801      CMP         R0,#0x1
 00000084  D10E      BNE         L_294  ; T=0x000000A4
 1162:             if (bit > 0)
 00000086  2C00      CMP         R4,#0x0 ; bit
 00000088  DD1B      BLE         L_296  ; T=0x000000C2
 1164:                 stim[i].stopTime = curTime;
 0000008A  4800      LDR         R0,=curTime ; curTime
 0000008C  6800      LDR         R0,[R0,#0x0] ; curTime
 0000008E  4800      LDR         R1,=stim + 0x30 ; stim+48
 00000090  5148      STR         R0,[R1,R5]
 1165:                 stim[i].status   = statDone;
 00000092  2005      MOV         R0,#0x5
 00000094  4800      LDR         R1,=stim + 0x4 ; stim+4
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 94  

 00000096  5148      STR         R0,[R1,R5]
 1166:                 ExecEvent(stim[i].event);
 00000098  4800      LDR         R0,=stim + 0x38 ; stim+56
 0000009A  5940      LDR         R0,[R0,R5]
 0000009C  F7FF      BL          ExecEvent?T  ; T=0x0001  (1)
 0000009E  FFB0      BL          ExecEvent?T  ; T=0x0001  (2)
 1167:                 return 0;
 000000A0  2000      MOV         R0,#0x0
 000000A2  E011      B           L_292  ; T=0x000000C8
 1169:         }
 000000A4          L_294:
 1172:             if (bit == 0)
 000000A4  2C00      CMP         R4,#0x0 ; bit
 000000A6  D10C      BNE         L_296  ; T=0x000000C2
 1174:                 stim[i].stopTime = curTime;
 000000A8  4800      LDR         R0,=curTime ; curTime
 000000AA  6800      LDR         R0,[R0,#0x0] ; curTime
 000000AC  4800      LDR         R1,=stim + 0x30 ; stim+48
 000000AE  5148      STR         R0,[R1,R5]
 1175:                 stim[i].status   = statDone;
 000000B0  2005      MOV         R0,#0x5
 000000B2  4800      LDR         R1,=stim + 0x4 ; stim+4
 000000B4  5148      STR         R0,[R1,R5]
 1176:                 ExecEvent(stim[i].event);
 000000B6  4800      LDR         R0,=stim + 0x38 ; stim+56
 000000B8  5940      LDR         R0,[R0,R5]
 000000BA  F7FF      BL          ExecEvent?T  ; T=0x0001  (1)
 000000BC  FFA1      BL          ExecEvent?T  ; T=0x0001  (2)
 1177:                 return 0;
 000000BE  2000      MOV         R0,#0x0
 000000C0  E002      B           L_292  ; T=0x000000C8
 1179:         }
 000000C2          L_296:
 1180:         return 1;
 000000C2  2001      MOV         R0,#0x1
 000000C4  E000      B           L_292  ; T=0x000000C8
 1181:     }
 000000C6          L_293:
 1182:     return 0;
 000000C6  2000      MOV         R0,#0x0
 000000C8            ; SCOPE-END
 1183: }
 000000C8          L_292:
 000000C8  BC70      POP         {R4-R6}
 000000CA  BC08      POP         {R3}
 000000CC  4718      BX          R3
 000000CE          ENDP ; 'ExecTrg0?T'


*** CODE SEGMENT '?PR?ExecLas?T?Human':
 1185: int ExecLas(int i) 
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C05      MOV         R5,R0 ; i
 00000004  ---- Variable 'i' assigned to Register 'R5' ----
 1186: {
 00000004            ; SCOPE-START
 1187:     int bitNo = (1 << (stim[i].bitNo-1));
 00000004  273C      MOV         R7,#0x3C
 00000006  436F      MUL         R7,R5 ; i
 00000008  4800      LDR         R0,=stim + 0x14 ; stim+20
 0000000A  59C0      LDR         R0,[R0,R7]
 0000000C  3801      SUB         R0,#0x1
 0000000E  2401      MOV         R4,#0x1
 00000010  4084      LSL         R4,R0
 00000012  ---- Variable 'bitNo' assigned to Register 'R4' ----
 1188:     curTime = Clock_GetTicks();
 00000012  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000014  FFF5      BL          Clock_GetTicks?T  ; T=0x0001  (2)
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 95  

 00000016  4800      LDR         R1,=curTime ; curTime
 00000018  6008      STR         R0,[R1,#0x0] ; curTime
 1190:     if (stim[i].status == statInit) 
 0000001A  4800      LDR         R0,=stim + 0x4 ; stim+4
 0000001C  59C6      LDR         R6,[R0,R7]
 0000001E  2E00      CMP         R6,#0x0
 00000020  D119      BNE         L_298  ; T=0x00000056
 1192:         if ((stim[i].startRef == 0) && (curTime >= stim[i].startTime)) 
 00000022  4800      LDR         R0,=stim + 0x24 ; stim+36
 00000024  59C0      LDR         R0,[R0,R7]
 00000026  2800      CMP         R0,#0x0
 00000028  D113      BNE         L_299  ; T=0x00000052
 0000002A  4800      LDR         R0,=stim + 0x28 ; stim+40
 0000002C  59C1      LDR         R1,[R0,R7]
 0000002E  4800      LDR         R0,=curTime ; curTime
 00000030  6800      LDR         R0,[R0,#0x0] ; curTime
 00000032  4288      CMP         R0,R1
 00000034  D30D      BCC         L_299  ; T=0x00000052
 1194:             curTime = Clock_GetTicks();
 00000036  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000038  FFE3      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 0000003A  4800      LDR         R1,=curTime ; curTime
 0000003C  6008      STR         R0,[R1,#0x0] ; curTime
 1195:             stim[i].startTime = curTime;
 0000003E  4800      LDR         R0,=curTime ; curTime
 00000040  6800      LDR         R0,[R0,#0x0] ; curTime
 00000042  4800      LDR         R1,=stim + 0x28 ; stim+40
 00000044  51C8      STR         R0,[R1,R7]
 1196:             stim[i].status = statRun;
 00000046  2003      MOV         R0,#0x3
 00000048  4800      LDR         R1,=stim + 0x4 ; stim+4
 0000004A  51C8      STR         R0,[R1,R7]
 1197:             SetBitsPar(bitNo);
 0000004C  1C20      MOV         R0,R4
 0000004E  F7FF      BL          SetBitsPar?T  ; T=0x0001  (1)
 00000050  FFD7      BL          SetBitsPar?T  ; T=0x0001  (2)
 1198:         } 
 00000052          L_299:
 1199:         return 1;
 00000052  2001      MOV         R0,#0x1
 00000054  E026      B           L_300  ; T=0x000000A4
 1200:     }
 00000056          L_298:
 1202:     if (stim[i].status == statRun) 
 00000056  2E03      CMP         R6,#0x3
 00000058  D123      BNE         L_301  ; T=0x000000A2
 1204:         if ((stim[i].stopRef == 0) && (curTime >= stim[i].stopTime)) 
 0000005A  213C      MOV         R1,#0x3C
 0000005C  4369      MUL         R1,R5 ; i
 0000005E  4800      LDR         R0,=stim + 0x2C ; stim+44
 00000060  5840      LDR         R0,[R0,R1]
 00000062  2800      CMP         R0,#0x0
 00000064  D11B      BNE         L_302  ; T=0x0000009E
 00000066  213C      MOV         R1,#0x3C
 00000068  4369      MUL         R1,R5 ; i
 0000006A  4800      LDR         R0,=stim + 0x30 ; stim+48
 0000006C  5841      LDR         R1,[R0,R1]
 0000006E  4800      LDR         R0,=curTime ; curTime
 00000070  6800      LDR         R0,[R0,#0x0] ; curTime
 00000072  4288      CMP         R0,R1
 00000074  D313      BCC         L_302  ; T=0x0000009E
 1206:             curTime = Clock_GetTicks();
 00000076  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000078  FFC3      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 0000007A  4800      LDR         R1,=curTime ; curTime
 0000007C  6008      STR         R0,[R1,#0x0] ; curTime
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 96  

 1207:             stim[i].stopTime = curTime;
 0000007E  4800      LDR         R0,=curTime ; curTime
 00000080  6801      LDR         R1,[R0,#0x0] ; curTime
 00000082  223C      MOV         R2,#0x3C
 00000084  436A      MUL         R2,R5 ; i
 00000086  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000088  5081      STR         R1,[R0,R2]
 1208:             stim[i].status = statDone;
 0000008A  2105      MOV         R1,#0x5
 0000008C  223C      MOV         R2,#0x3C
 0000008E  436A      MUL         R2,R5 ; i
 00000090  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000092  5081      STR         R1,[R0,R2]
 1209:             ClrBitsPar(bitNo);
 00000094  1C20      MOV         R0,R4
 00000096  F7FF      BL          ClrBitsPar?T  ; T=0x0001  (1)
 00000098  FFB3      BL          ClrBitsPar?T  ; T=0x0001  (2)
 1210:             return 0; 
 0000009A  2000      MOV         R0,#0x0
 0000009C  E002      B           L_300  ; T=0x000000A4
 1211:         } 
 0000009E          L_302:
 1212:         return 1;
 0000009E  2001      MOV         R0,#0x1
 000000A0  E000      B           L_300  ; T=0x000000A4
 1213:     }
 000000A2          L_301:
 1214:     return 0;
 000000A2  2000      MOV         R0,#0x0
 000000A4            ; SCOPE-END
 1215: }
 000000A4          L_300:
 000000A4  BCF0      POP         {R4-R7}
 000000A6  BC08      POP         {R3}
 000000A8  4718      BX          R3
 000000AA          ENDP ; 'ExecLas?T'


*** CODE SEGMENT '?PR?ExecAcq?T?Human':
 1217: int ExecAcq(int i)
 00000000  B570      PUSH        {R4-R6,LR}
 00000002  1C04      MOV         R4,R0 ; i
 00000004  ---- Variable 'i' assigned to Register 'R4' ----
 1218: {
 00000004            ; SCOPE-START
 1221:     curTime = Clock_GetTicks();
 00000004  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000006  FFFC      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000008  4800      LDR         R1,=curTime ; curTime
 0000000A  6008      STR         R0,[R1,#0x0] ; curTime
 1222:     if (stim[i].status == statInit)
 0000000C  253C      MOV         R5,#0x3C
 0000000E  4365      MUL         R5,R4 ; i
 00000010  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000012  5946      LDR         R6,[R0,R5]
 00000014  2E00      CMP         R6,#0x0
 00000016  D116      BNE         L_303  ; T=0x00000046
 1224:         if ((stim[i].startRef == 0) && (curTime >= stim[i].startTime))
 00000018  4800      LDR         R0,=stim + 0x24 ; stim+36
 0000001A  5940      LDR         R0,[R0,R5]
 0000001C  2800      CMP         R0,#0x0
 0000001E  D110      BNE         L_304  ; T=0x00000042
 00000020  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000022  5941      LDR         R1,[R0,R5]
 00000024  4800      LDR         R0,=curTime ; curTime
 00000026  6800      LDR         R0,[R0,#0x0] ; curTime
 00000028  4288      CMP         R0,R1
 0000002A  D30A      BCC         L_304  ; T=0x00000042
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 97  

 1226:             stim[i].startTime = curTime;
 0000002C  4800      LDR         R1,=stim + 0x28 ; stim+40
 0000002E  5148      STR         R0,[R1,R5]
 1227:             Trigger(outRA16,true);
 00000030  2008      MOV         R0,#0x8
 00000032  2101      MOV         R1,#0x1
 00000034  F7FF      BL          Trigger?T  ; T=0x0001  (1)
 00000036  FFE4      BL          Trigger?T  ; T=0x0001  (2)
 1228:             stim[i].status = statRun;                      
 00000038  2103      MOV         R1,#0x3
 0000003A  223C      MOV         R2,#0x3C
 0000003C  4362      MUL         R2,R4 ; i
 0000003E  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000040  5081      STR         R1,[R0,R2]
 1229:         }
 00000042          L_304:
 1230:         return 1;
 00000042  2001      MOV         R0,#0x1
 00000044  E01B      B           L_305  ; T=0x0000007E
 1231:     }
 00000046          L_303:
 1233:     if (stim[i].status == statRun)
 00000046  2E03      CMP         R6,#0x3
 00000048  D118      BNE         L_306  ; T=0x0000007C
 1235:         if (curTime > (stim[i].startTime+100))
 0000004A  4800      LDR         R0,=stim + 0x28 ; stim+40
 0000004C  5941      LDR         R1,[R0,R5]
 0000004E  3164      ADD         R1,#0x64
 00000050  4800      LDR         R0,=curTime ; curTime
 00000052  6800      LDR         R0,[R0,#0x0] ; curTime
 00000054  4288      CMP         R0,R1
 00000056  D90F      BLS         L_307  ; T=0x00000078
 1237:             bit = TstBitPar(inpRA16);
 00000058  2008      MOV         R0,#0x8
 0000005A  F7FF      BL          TstBitPar?T  ; T=0x0001  (1)
 0000005C  FFD1      BL          TstBitPar?T  ; T=0x0001  (2)
 0000005E  ---- Variable 'bit' assigned to Register 'R0' ----
 1238:             if (bit == 0)
 0000005E  2800      CMP         R0,#0x0 ; bit
 00000060  D10A      BNE         L_307  ; T=0x00000078
 1240:                 stim[i].stopTime = curTime;
 00000062  4800      LDR         R0,=curTime ; curTime
 00000064  6801      LDR         R1,[R0,#0x0] ; curTime
 00000066  223C      MOV         R2,#0x3C
 00000068  4362      MUL         R2,R4 ; i
 0000006A  4800      LDR         R0,=stim + 0x30 ; stim+48
 0000006C  5081      STR         R1,[R0,R2]
 1241:                 stim[i].status = statDone;
 0000006E  2005      MOV         R0,#0x5
 00000070  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000072  5088      STR         R0,[R1,R2]
 1242:                 return 0;
 00000074  2000      MOV         R0,#0x0
 00000076  E002      B           L_305  ; T=0x0000007E
 1244:         }
 00000078          L_307:
 1245:         return 1;
 00000078  2001      MOV         R0,#0x1
 0000007A  E000      B           L_305  ; T=0x0000007E
 1246:     }
 0000007C          L_306:
 1248:     return 0;
 0000007C  2000      MOV         R0,#0x0
 0000007E            ; SCOPE-END
 1249: }
 0000007E          L_305:
ARM COMPILER V2.11,  Human                                                                 20/10/09  09:57:55  PAGE 98  

 0000007E  BC70      POP         {R4-R6}
 00000080  BC08      POP         {R3}
 00000082  4718      BX          R3
 00000084          ENDP ; 'ExecAcq?T'


*** CODE SEGMENT '?PR?GetTime?T?Human':
 1251: void GetTime()
 00000000  B500      PUSH        {LR}
 1252: {
 00000002            ; SCOPE-START
 1254:     val = Clock_GetTicks();
 00000002  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000004  FFFD      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000006  1C02      MOV         R2,R0 ; val
 00000008  ---- Variable 'val' assigned to Register 'R2' ----
 1255:     n = sprintf(outBuf,"%d\n",val);
 00000008  4800      LDR         R0,=outBuf ; outBuf
 0000000A  4800      LDR         R1,=??S_2 ; ??S_2
 0000000C  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 0000000E  FFF8      BL          sprintf?T  ; T=0x0001  (2)
 00000010  1C01      MOV         R1,R0 ; n
 00000012  ---- Variable 'n' assigned to Register 'R1' ----
 1256:     i = UART0_Str(outBuf, n);
 00000012  4800      LDR         R0,=outBuf ; outBuf
 00000014  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000016  FFF4      BL          UART0_Str?T  ; T=0x0001  (2)
 1257:     nBuffer[1] = 0;
 00000018  2100      MOV         R1,#0x0
 0000001A  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 0000001C  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 0000001E            ; SCOPE-END
 1258: }
 0000001E  BC08      POP         {R3}
 00000020  4718      BX          R3
 00000022          ENDP ; 'GetTime?T'



Module Information          Static
----------------------------------
  code size            =    ------
  data size            =      2242
  const size           =       447
End of Module Information.


ARM COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
