ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 1   


ARM COMPILER V2.11, COMPILATION OF MODULE Fart
OBJECT MODULE PLACED IN Fart.OBJ
COMPILER INVOKED BY: C:\Keil\ARM\BIN\CA.exe Fart.c THUMB BROWSE TABS(4) 

stmt  level    source

    1          /*********************************************************************************************
    2                                      Fart.c
    3              05-Sep-2008     Fart is a new micro controller program for human and monkey
    4                              experiments, replacing Human and Monkey.
    5              22-Sep-2008     Finite state machine
    6              17-Apr-2009     3.00 New design
    7              04-May-2009     3.10 stimBar has improved (fix, tar and dim are removed)
    8                              in case of an error T_trial is negative and the record 
    9                              is cleared.
   10                              3.11 Bar, Sky, rew and rec are tested with a script of Tom
   11              02-Jun-2009     3.20 Sound-
   12                              3.21 Selection speakers + volume
   13                              3.22 playing sound
   14              21-Jul-2009     Max stimuli is now 50
   15                              GetStateBar returns a new line
   16              02-Sep-2009     stimRec extended with stop time
   17                              new stimulus las 
   18              24-Sep-2009     Abort function implemented for testing timeouts
   19              05-Oct-2009     Init sets nStim to 0.
   20              04-Nov-2009     3.41 Reading results with mex functions and data to Matlab.
   21                              Input en output buffer has increased from 80 to 128
   22              07-Jan-2010     cmdNNMod en cmdNNSim for testing neural networks
   23              03-Feb-2010     3.60 Windowing
   24          ----------------------------------------------------------------------------------------------
   25              04-Feb-2010     1.00 From now on one program, Fart: replacing C++ for both arches
   26                              Windowing cpmpleted.
   27              12-Feb-2010     1.00 Velocity tested with Matlab, input tone generator.
   28              16-Feb-2010     1.01 Velocity, input NN's. Head, eye velocity calculated
   29                              towards a goal.
   30              01-Mar-2010     1.02 Implementation triggering by velocity, tested with Tom
   31          *********************************************************************************************/
   32          #include <lpc21xx.h>
   33          #include <stdio.h>
   34          #include <inttypes.h>
   35          #include <math.h>
   36          
   37          #include "Fart.h"
   38          #include "Config.h"
   39          #include "Clock.h"
   40          #include "Serial.h"
   41          #include "i2c.h"
   42          
   43          //=> Check output (Fart1/Fart2) in "Project->Options for Target Fart"
   44          //=> and global.h for contional compiling 
   45          #ifdef Fart1
               char version[] = "LPC2119->Fart1 1.11 08-Apr-2010\n";                  
               #endif
   48          #ifdef Fart2
   49          char version[] = "LPC2119->Fart2 1.11 08-Apr-2010\n";                  
   50          #endif
   51          //========================================= A D C ==========================================//
   52          adc_buffer  AdcBuffer;          // 8 channels adc buffer
   53          int         AdcActive;          // Active adc channel (1..8)
   54          //======================================= M A I N =========================================//
   55          char        inBuf[128];         // used for RS232 communication
   56          char        outBuf[128];
   57          int         inpPnt, outPnt;     // de bijbehorende pointers
   58          int32_t     nBuffer[25];        // commands and parameters
   59          double      rBuffer[25];        // commands and parameters for NN
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 2   

   60          char        wrd[10];            // memory, 1 word from inBuf
   61          
   62          
   63          uint32_t    startTime;          // start after ITI  = reference time
   64          uint32_t    curTime;            // crrent time
   65          int         ITI       = 0;      // Inter Trial Interval
   66          int         errFlag   = false;  // Flag used within some functions
   67          int         errTime   = 0;      // Time error was occured
   68          recStim     stim[40];           // Buffer with stim records
   69          int         nStim     = 0;      // Index stim buffer
   70          
   71          NNMOD       NNs[4];             // Buffer for 4 NN
   72          int         NetNum;             // Temporary index for loading NN model
   73          FIXWND      fixWindows[10];     // Buffer for 10 Fixation windows
   74          double      speed[2];           // 0=slope, 1=offset
   75          int         pntNN;
   76          int         seconds = 0;        // clock, seconds
   77          uint32_t    ticks   = 0;        // closk, ticks
   78          int         MCS     = 1;        // Micro Controller Status
   79          
   80          //=================================== H A R D  W A R E =====================================//
   81          recLedIC Leds[2][2][4];     // [front/back] [internal selection PCA 9532 LS0..LS3]
   82          recLedIC Sky[13];           // 5,9,14,20,27,35,44,54,65 degrees
   83          
   84          int boards[8]   = {0xF7,0xFB,0xFD,0xFE,0x7F,0xBF,0xDF,0xEF};  // pre selection speaker
   85          int speakers[8] = {0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01};
   86          int gain1[8]    = {0x7F,0xDF,0xF7,0xFD,0x7F,0xDF,0xF7,0xFD};  // snd1
   87          int gain2[8]    = {0xBF,0xEF,0xFB,0xFE,0xBF,0xEF,0xFB,0xFE};  // snd2
   88          // signal: bit=0->signal2, bit=1->signal1
   89          int statusBoards[8][3];  // [board][signal, gain1..4, gain5..8]
   90                                   // 0x4E=board, 0x40=signal, 0x44 gain1..4, 0x42 gain5..8  
   91          
   92          int         parInp  = 0;        // digital I/O, input
   93          int         parOutp = 0;        // digital I/O, output
   94          
   95          int         recBit  = 0;        // Trigger record (TDT)
   96          int         rewBit  = 0;        // Trigger reward
   97          int         sndBit  = 0;        // Trigger sound
   98          int         lasBit  = 0;        // Trigger Laser
   99          
  100          char        state[80];          // State of each seperate stimulus
  101          unsigned int T_trial = 0;       // Trial elapsed time
  102          unsigned int T_ITI   = 0;       // ITI elapsed time
  103          unsigned int T_start = 0;       // Trial begin time
  104          unsigned int T_done  = 0;       // Trial end time
  105          
  106          /************************************** A D C ***********************************************/
  107          void ADC_Init(void)
  108          {   // Clock AD converter has to be less than 4.5 MHz.   (50 Mhz / (CLKDIV+1))  
  109   1          // Channels 0..3             7:0  -> 0F
  110   1          // Clock divided by         15:8  -> FF     (0D = 3.5714 MHz)    (FF = 0.19607 mHz)
  111   1          // Burst mode off           16    ->  0
  112   1          // CLKS 11 clocks           19:17 ->  0
  113   1          // Power down PDN=1         21    ->  1
  114   1          // No start                 26:24 ->  0
  115   1          int i,n,channel;
  116   1      
  117   1          for(i=0; i<8; i++)
  118   1          {
  119   2              for (n=0; n<11; n++)
  120   2              {
  121   3                  AdcBuffer.data[i][n] = 0;
  122   3              }
  123   2          }
  124   1      
  125   1          AdcActive = 0;
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 3   

  126   1          channel = (1 << AdcActive);
  127   1          PINSEL1 |= 0x55 << 22;              // channels 0,1,2,3
  128   1          ADCR = channel;
  129   1          ADCR |= ((0xFF << 8) | (1 << 21)); 
  130   1      
  131   1          VICVectAddr3 = (unsigned long)ADC_irq;
  132   1          VICVectCntl3 = 0x20 | 18;       // ADC interrupt (irq enable + number of interrupt)
  133   1          VICIntEnable = 1 << 18;         // Enable ADC interrupt
  134   1      
  135   1          ADCR |= (0x001 << 24);
  136   1      }
  137          
  138          void ADC_irq(void) __irq
  139          {
  140   1          int i, val, chan;
  141   1          double dVal;
  142   1      
  143   1          val  = ((ADDR >>  6) & 0x03FF);     // Get result
  144   1          chan = ((ADDR >> 24) & 0x0003);     // and channel
  145   1          chan = chan | (AdcActive & 0x04);   // add group (multiplexer)
  146   1          dVal = val;
  147   1      #ifdef Fart1
                       dVal = (dVal-523.0)/375;
               #endif
  150   1      #ifdef Fart2
  151   1              dVal = (dVal-559.0)/447;
  152   1      #endif
  153   1      
  154   1          for (i=1; i<10; i++)
  155   1          {
  156   2              AdcBuffer.data[chan][i] = AdcBuffer.data[chan][i+1];
  157   2          }
  158   1          AdcBuffer.data[chan][10] = dVal;
  159   1      
  160   1          dVal = 0;
  161   1          for (i=1; i<11; i++)
  162   1          {
  163   2              dVal += AdcBuffer.data[chan][i];    
  164   2          }
  165   1          AdcBuffer.data[chan][0] = dVal/10.0;
  166   1          AdcActive = AdcNext(AdcActive);
  167   1          if ((AdcActive & 0x04) > 0)             // select group
  168   1              IOCLR0 = 0x8000;
  169   1          else
  170   1              IOSET0 = 0x8000;
  171   1          chan = (1 << (AdcActive & 0x03));       // remove group select
  172   1      
  173   1          VICVectAddr = 3;                        // Acknowledge interrupt
  174   1      
  175   1          ADCR &= ~0xF;
  176   1          ADCR |= chan;
  177   1          ADCR |= (0x001 << 24);
  178   1      }
  179          
  180          int AdcNext(int current)
  181          {
  182   1          int next;
  183   1          next = current;
  184   1          if (++next == 8) next = 0;
  185   1          return next;
  186   1      }
  187          
  188          /**************************************** M A I N *******************************************/
  189          int main (void)
  190          {
  191   1          int i, n, m;
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 4   

  192   1          int inChar;
  193   1          int num     = 0;
  194   1          int ITI     = 0;
  195   1          int done  = false;
  196   1          int EOL   = false;
  197   1          int abort = false;
  198   1          int flag  = false;
  199   1          char CR[] = "\n";
  200   1          char SP[] = " ";
  201   1          char NUMBERS[] = "0123456789";
  202   1          softReset();
  203   1          /********************************************************************/
  204   1          for (;;)
  205   1          {
  206   2              while ((UART0_RxNumber() > 0) && (EOL == false))
  207   2              {
  208   3                  inChar = UART0_Get();
  209   3                  if (inChar == ESCAPE) abort = true;
  210   3                  if ((inChar == LF))
  211   3                  {
  212   4                      EOL        = true;          // new command
  213   4                      inBuf[num] = 0;
  214   4                      splitInput();               // command plus parameters
  215   4                  }
  216   3                  if (EOL == false) inBuf[num++] = (char) inChar;
  217   3              }
  218   2              /********************************************************************/
  219   2              curTime = Clock_GetTicks();
  220   2              seconds = Clock_GetSeconds();
  221   2              ticks   = curTime;
  222   2              parInp  = GetBitsPar();
  223   2      
  224   2              /********************************************************************/
  225   2              if ((MCS == statInit) && (EOL == true))
  226   2              {
  227   3                  switch(nBuffer[1])
  228   3                  {
  229   4                  case cmdSaveTrial:  execSaveTrial();break;
  230   4                  case cmdStim:       execStim();     break;
  231   4                  case cmdInit:       execInit();     break;
  232   4                  case cmdInfo:       getInfo();      break;
  233   4                  case cmdState:      getState();     break;
  234   4                  case cmdStateTrial: getStateTrial();break;
  235   4                  case cmdClock:      getClock();     break;
  236   4                  case cmdTime:       getTime();      break;
  237   4                  case cmdClrTime:    clrTime();      break;
  238   4                  case cmdReset:      execReset();    break;
  239   4                  case cmdAbort:      execAbort();    break;
  240   4                  case cmdNextTrial:  execNextTrial();break;
  241   4                  case cmdBar:        getBarState();  break;
  242   4                  case cmdADC:        getADC();       break;
  243   4                  case cmdSelADC:     selectADC();    break;
  244   4                  case cmdPin:        getPIO();       break;
  245   4                  case cmdSpeaker:    setSpeaker();   break;
  246   4                  case cmdNNMod:      loadNNMod();    break;
  247   4                  case cmdNNSim:      simulateNN(-1); break;
  248   4                  case cmdFixWnd:     setFixWindow(); break;
  249   4                  case cmdSpeed:      getSpeed();     break;
  250   4                  }
  251   3                  EOL = false;
  252   3                  num = 0;
  253   3              }
  254   2              /********************************************************************/
  255   2              if ((MCS == statNextTrial) && (EOL == true))
  256   2              {
  257   3                  flag = true;
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 5   

  258   3                  switch(nBuffer[1])
  259   3                  {
  260   4                  case cmdStartTrial: execStartTrial(); flag = false;   break;
  261   4                  case cmdState:      getState();       flag = false;   break;
  262   4                  case cmdStateTrial: getStateTrial();  flag = false;   break;
  263   4                  case cmdPin:        getPIO();         flag = false;   break;
  264   4                  case cmdAbort:      execAbort();      flag = false;   break;
  265   4                  }
  266   3      
  267   3                  switch(nBuffer[1])
  268   3                  {
  269   4                  case stimBar:   
  270   4                      stim[nStim].status    = statInit;
  271   4                      stim[nStim].kind      = stimBar;
  272   4                      stim[nStim].mode      = nBuffer[2];
  273   4                      stim[nStim].edge      = nBuffer[3];
  274   4                      stim[nStim].bitNo     = nBuffer[4];
  275   4                      stim[nStim].startRef  = nBuffer[5];
  276   4                      stim[nStim].startTime = nBuffer[6];
  277   4                      stim[nStim].stopRef   = nBuffer[7];
  278   4                      stim[nStim].stopTime  = nBuffer[8];
  279   4                      stim[nStim].event     = nBuffer[9];
  280   4                      nStim++;
  281   4                      break;
  282   4                  case stimRec:
  283   4                      stim[nStim].status    = statInit;
  284   4                      stim[nStim].kind      = stimRec;
  285   4                      stim[nStim].bitNo     = nBuffer[2];
  286   4                      stim[nStim].startRef  = nBuffer[3];
  287   4                      stim[nStim].startTime = nBuffer[4];
  288   4                      stim[nStim].stopRef   = nBuffer[5];
  289   4                      stim[nStim].stopTime  = nBuffer[6];
  290   4                      stim[nStim].event     = nBuffer[7];
  291   4                      recBit = (1 << (stim[nStim].bitNo-1));
  292   4                      nStim++;
  293   4                      break;
  294   4                  case stimRew:
  295   4                      stim[nStim].status    = statInit;
  296   4                      stim[nStim].kind      = stimRew;
  297   4                      stim[nStim].bitNo     = nBuffer[2];
  298   4                      stim[nStim].startRef  = nBuffer[3];
  299   4                      stim[nStim].startTime = nBuffer[4];
  300   4                      stim[nStim].stopRef   = nBuffer[5];
  301   4                      stim[nStim].stopTime  = nBuffer[6];
  302   4                      stim[nStim].event     = nBuffer[7];
  303   4                      rewBit = (1 << (stim[nStim].bitNo-1));
  304   4                      nStim++;
  305   4                      break;
  306   4                  case stimLas:
  307   4                      stim[nStim].status    = statInit;
  308   4                      stim[nStim].kind      = stimLas;
  309   4                      stim[nStim].bitNo     = nBuffer[2];
  310   4                      stim[nStim].startRef  = nBuffer[3];
  311   4                      stim[nStim].startTime = nBuffer[4];
  312   4                      stim[nStim].stopRef   = nBuffer[5];
  313   4                      stim[nStim].stopTime  = nBuffer[6];
  314   4                      stim[nStim].event     = nBuffer[7];
  315   4                      lasBit = (1 << (stim[nStim].bitNo-1));
  316   4                      nStim++;
  317   4                      break;
  318   4                  case stimSky:
  319   4                      stim[nStim].status    = statInit;
  320   4                      stim[nStim].kind      = stimSky;
  321   4                      stim[nStim].posX      = nBuffer[2];
  322   4                      stim[nStim].posY      = nBuffer[3];
  323   4                      stim[nStim].level     = nBuffer[4];
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 6   

  324   4                      stim[nStim].startRef  = nBuffer[5];
  325   4                      stim[nStim].startTime = nBuffer[6];
  326   4                      stim[nStim].stopRef   = nBuffer[7];
  327   4                      stim[nStim].stopTime  = nBuffer[8];
  328   4                      stim[nStim].event     = nBuffer[9];
  329   4                      nStim++;
  330   4                      break;                                                     
  331   4                  case stimLed:
  332   4                      stim[nStim].status    = statInit;
  333   4                      stim[nStim].kind      = stimLed;
  334   4                      stim[nStim].posX      = nBuffer[2];
  335   4                      stim[nStim].posY      = nBuffer[3];
  336   4                      stim[nStim].level     = nBuffer[4];
  337   4                      stim[nStim].startRef  = nBuffer[5];
  338   4                      stim[nStim].startTime = nBuffer[6];
  339   4                      stim[nStim].stopRef   = nBuffer[7];
  340   4                      stim[nStim].stopTime  = nBuffer[8];
  341   4                      stim[nStim].event     = nBuffer[9];
  342   4                      nStim++;
  343   4                      break;
  344   4                  case stimSnd1:  
  345   4                      stim[nStim].status    = statInit;
  346   4                      stim[nStim].kind      = stimSnd1;
  347   4                      stim[nStim].bitNo     = nBuffer[2];
  348   4                      stim[nStim].startRef  = nBuffer[3];
  349   4                      stim[nStim].startTime = nBuffer[4];
  350   4                      stim[nStim].stopRef   = nBuffer[5];
  351   4                      stim[nStim].stopTime  = nBuffer[6];
  352   4                      stim[nStim].event     = nBuffer[7];
  353   4                      sndBit = (1 << (stim[nStim].bitNo-1));
  354   4                      nStim++;
  355   4                      break;
  356   4                  case stimSnd2:  
  357   4                      stim[nStim].status    = statInit;
  358   4                      stim[nStim].kind      = stimSnd1;
  359   4                      stim[nStim].bitNo     = nBuffer[2];
  360   4                      stim[nStim].startRef  = nBuffer[3];
  361   4                      stim[nStim].startTime = nBuffer[4];
  362   4                      stim[nStim].stopRef   = nBuffer[5];
  363   4                      stim[nStim].stopTime  = nBuffer[6];
  364   4                      stim[nStim].event     = nBuffer[7];
  365   4                      sndBit = (1 << (stim[nStim].bitNo-1));
  366   4                      nStim++;
  367   4                      break;
  368   4                  case stimFixWnd:
  369   4                      stim[nStim].status    = statInit;
  370   4                      stim[nStim].kind      = stimFixWnd;
  371   4                      stim[nStim].index     = nBuffer[ 2];
  372   4                      stim[nStim].posX      = nBuffer[ 3];
  373   4                      stim[nStim].posY      = nBuffer[ 4];        
  374   4                      stim[nStim].winX      = nBuffer[ 5];
  375   4                      stim[nStim].winY      = nBuffer[ 6];        
  376   4                      stim[nStim].startRef  = nBuffer[ 7];
  377   4                      stim[nStim].startTime = nBuffer[ 8];
  378   4                      stim[nStim].stopRef   = nBuffer[ 9];
  379   4                      stim[nStim].stopTime  = nBuffer[10];
  380   4                      stim[nStim].delay     = nBuffer[11];
  381   4                      stim[nStim].event     = nBuffer[12]; 
  382   4                      nStim++;                            
  383   4                      break;
  384   4                  case stimSpeed:
  385   4                      stim[nStim].status    = statInit;
  386   4                      stim[nStim].kind      = stimSpeed;
  387   4                      stim[nStim].mode      = nBuffer[ 2];  // matlab numbering
  388   4                                                            // xxx321-X, 654xxx-Y
  389   4                                                            // bit 3xx = 1 Yes
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 7   

  390   4                                                            // bit x21 = id NN
  391   4                      stim[nStim].posX      = nBuffer[ 3];  // target 
  392   4                      stim[nStim].posY      = nBuffer[ 4];        
  393   4                      stim[nStim].startRef  = nBuffer[ 5];
  394   4                      stim[nStim].startTime = nBuffer[ 6];
  395   4                      stim[nStim].stopRef   = nBuffer[ 7];
  396   4                      stim[nStim].stopTime  = nBuffer[ 8];
  397   4                      stim[nStim].level     = nBuffer[ 9];  // velocity
  398   4                      stim[nStim].event     = nBuffer[10];
  399   4                      nStim++;                             
  400   4                      break;
  401   4                  }
  402   3      
  403   3                  if (flag == true)
  404   3                  {
  405   4                      n = sprintf(outBuf,"%d\n",curTime);
  406   4                      i = UART0_Str(outBuf, n);
  407   4                      nBuffer[1] = 0;
  408   4                  }
  409   3                  EOL = false;
  410   3                  num = 0;
  411   3              }
  412   2              /********************************************************************/
  413   2              curTime = Clock_GetTicks();
  414   2              seconds = Clock_GetSeconds();
  415   2              ticks   = curTime;
  416   2              parInp  = GetBitsPar();
  417   2              /********************************************************************/
  418   2              if (MCS == statRunTrial)
  419   2              {
  420   3                  if (EOL == true)
  421   3                  {
  422   4                      switch(nBuffer[1])
  423   4                      {
  424   5                      case cmdBar:    getBarState();  break;
  425   5                      case cmdState:  getState();     break;
  426   5                      case cmdStateTrial: getStateTrial(); break;
  427   5                      case cmdClock:  getClock();     break;
  428   5                      case cmdADC:    getADC();       break;
  429   5                      case cmdReset:  execReset();    break;
  430   5                      case cmdPin:    getPIO();       break;
  431   5                      case cmdAbort:  execAbort();    break;
  432   5                      case cmdSpeed:  getSpeed();     break;
  433   5                      case cmdNNSim:  simulateNN(-1); break;
  434   5                      }
  435   4                      EOL = false;
  436   4                      num = 0;
  437   4                  }
  438   3                  done = 0;
  439   3                  n = 0;
  440   3                  state[n] = CR[0];
  441   3                  curTime = Clock_GetTicks() - T_start;
  442   3                  for (i = 0; i < nStim; i++)
  443   3                  {
  444   4                      switch(stim[i].kind)
  445   4                      {
  446   5                          case stimBar:    m = execBar(i);    state[n++] = NUMBERS[m]; done += m; break;
  447   5                          case stimSky:    m = execSky(i);    state[n++] = NUMBERS[m]; done += m; break;
  448   5                          case stimLed:    m = execLed(i);    state[n++] = NUMBERS[m]; done += m; break;
  449   5                          case stimRec:    m = execRec(i);    state[n++] = NUMBERS[m]; done += m; break;
  450   5                          case stimRew:    m = execRew(i);    state[n++] = NUMBERS[m]; done += m; break; 
  451   5                          case stimLas:    m = execLas(i);    state[n++] = NUMBERS[m]; done += m; break; 
  452   5                          case stimSnd1:   m = execSnd(i);    state[n++] = NUMBERS[m]; done += m; break; 
  453   5                          case stimSnd2:   m = execSnd(i);    state[n++] = NUMBERS[m]; done += m; break; 
  454   5                          case stimFixWnd: m = execFixWnd(i); state[n++] = NUMBERS[m]; done += m; break; 
  455   5                          case stimSpeed:  m = execSpeed(i);  state[n++] = NUMBERS[m]; done += m; break; 
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 8   

  456   5                      }
  457   4                      state[n++] = SP[0];
  458   4                  }
  459   3                  state[n++] = CR[0]; 
  460   3                  state[n] = 0;
  461   3                  if (done == 0)
  462   3                  {
  463   4                      if (errFlag == false)
  464   4                      {
  465   5                          MCS = statDoneTrial;
  466   5                          T_done  = Clock_GetTicks();
  467   5                          T_trial = T_done - T_start;
  468   5                      }
  469   4                      else
  470   4                      {
  471   5                          MCS = statDoneTrial;
  472   5                          T_done  = Clock_GetTicks();
  473   5                          T_trial = -1*(T_done - T_start);
  474   5                       }
  475   4                  }
  476   3      
  477   3              }
  478   2              /********************************************************************/
  479   2              if (MCS == statDoneTrial)
  480   2              {
  481   3                  if (EOL == true)
  482   3                  {
  483   4                      switch(nBuffer[1])
  484   4                      {
  485   5                      case cmdInit:   execInit();     break;
  486   5                      case cmdState:  getState();     break;
  487   5                      case cmdStateTrial: getStateTrial();break;
  488   5                      case cmdBar:    getBarState();  break;
  489   5                      case cmdClock:  getClock();     break;
  490   5                      case cmdSaveTrial:  execSaveTrial();break;
  491   5                      case cmdADC:    getADC();       break;      
  492   5                      case cmdReset:  execReset();    break;
  493   5                      case cmdPin:    getPIO();       break;
  494   5                      case cmdAbort:  execAbort();    break;
  495   5                      }
  496   4                      EOL = false;
  497   4                      num = 0;
  498   4                  }
  499   3              }
  500   2              /********************************************************************/
  501   2              if ((seconds & 0x01) > 0) ClrBitsPar(0x01); else SetBitsPar(0x01);
  502   2          }
  503   1      
  504   1          return 0;
  505   1      }
  506          
  507          void getPIO(void)
  508          {
  509   1          int i, n, val;
  510   1      
  511   1          val = GetBitsPar();
  512   1          val = ((parOutp << 8) | val);
  513   1          n = sprintf(outBuf,"%d\n",val);
  514   1          i = UART0_Str(outBuf, n);
  515   1          nBuffer[1] = 0;
  516   1      }
  517          
  518          void SetBitsPar(int i)
  519          {
  520   1          IOSET0 = (i & 0xFF) << 4;          
  521   1      }
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 9   

  522          
  523          
  524          void ClrBitsPar(int i)
  525          {
  526   1          IOCLR0 = (i & 0xFF) << 4;
  527   1      }
  528          
  529          void ClrAllBitsPar(void)
  530          {
  531   1          IOCLR0 = 0xFF << 4;
  532   1      }
  533          
  534          int GetBitsPar(void)
  535          {
  536   1          int i;
  537   1      #ifdef Fart1
                   i = (IOPIN0 >> 17) & 0x00FF;  // big arche
               #endif
  540   1      
  541   1      #ifdef Fart2
  542   1          i = (IOPIN0 >> 18) & 0x00FF;  // small arche
  543   1      #endif
  544   1          return i;
  545   1      }
  546          
  547          int TstBitPar(int bit)
  548          {
  549   1          int i;
  550   1          i = GetBitsPar();
  551   1          i = (i & bit);
  552   1      
  553   1          return i;
  554   1      }
  555          
  556          
  557          void execResults()
  558          {
  559   1          int n,i;
  560   1          n = sprintf(outBuf,"%d;%d\n",startTime, nStim);
  561   1          i = UART0_Str(outBuf, n);
  562   1          nBuffer[1] = 0;
  563   1          MCS = statInit;
  564   1      }
  565          
  566          void execTime()
  567          {
  568   1          int n,i;
  569   1      
  570   1          n = sprintf(outBuf,"%d\n",Clock_GetTicks());
  571   1          i = UART0_Str(outBuf, n);
  572   1          nBuffer[1] = 0;
  573   1      }
  574          
  575          void execError(void)
  576          {
  577   1          int i;
  578   1          for (i = 0; i < nStim; i++)
  579   1          {
  580   2              if (stim[i].status != statDone)
  581   2                  stim[i].status = statError;
  582   2          }
  583   1          if (sndBit > 0)
  584   1          {
  585   2              ClrBitsPar(sndBit);
  586   2              parOutp &= ~sndBit;
  587   2          }
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 10  

  588   1          if (rewBit > 0)
  589   1          {
  590   2              ClrBitsPar(rewBit);
  591   2              parOutp &= ~rewBit;
  592   2          }
  593   1          if (recBit > 0)
  594   1          {
  595   2              ClrBitsPar(recBit);
  596   2              parOutp &= ~recBit;
  597   2          }
  598   1          if (lasBit > 0)
  599   1          {
  600   2              ClrBitsPar(lasBit);
  601   2              parOutp &= ~lasBit;
  602   2          }
  603   1          ClearSky();
  604   1          errFlag = true;
  605   1          errTime = Clock_GetTicks();
  606   1      }
  607          
  608          void WaitForEnter(void)
  609          {
  610   1          int inChar;
  611   1          inChar = -1;
  612   1          
  613   1          Clock_ClrCountWait();
  614   1      
  615   1          while (inChar != LF)
  616   1          {
  617   2              if (UART0_RxNumber() > 0)
  618   2              {
  619   3                  inChar = UART0_Get();
  620   3              }
  621   2              else
  622   2              {
  623   3                  if (Clock_GetCountWait() == 100) inChar = LF;
  624   3              }
  625   2          }
  626   1      }
  627          
  628          void setSpeaker(void)
  629          {
  630   1          int n, i, tmp, board, address, speaker;
  631   1          unsigned char buffer[2];
  632   1          int OnOff   = nBuffer[4];
  633   1          int channel = nBuffer[3];
  634   1          // Select board and speaker
  635   1      #ifdef Fart1
                   n = nBuffer[2] + 2;
                   if (n == 32) n = 1;
                   if (n == 33) n = 2;
               #endif
  640   1      
  641   1      #ifdef Fart2
  642   1          n = nBuffer[2] - 1;
  643   1      #endif
  644   1          // < 100 front- else back
  645   1          if (n < 100) board = n / 8; else board = ((n - 100) / 8) + 4;
  646   1          if (n >= 100) n = n - 100 + 32;  // correction front/back and board 4=board 0
  647   1          speaker = n - 8*board;
  648   1          address   = 0x4E;
  649   1      
  650   1          buffer[0] = boards[board]; 
  651   1          I2C_SendByte(address, 1, buffer);
  652   1          // Set signal 1 or 2
  653   1          if (OnOff == 1)
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 11  

  654   1          {
  655   2              tmp = statusBoards[board][0];
  656   2              if (channel == stimSnd1) 
  657   2                  tmp |= speakers[speaker];       // set speakerbit
  658   2              else
  659   2                  tmp &= ~speakers[speaker];      // clr speakerbit 
  660   2      
  661   2              statusBoards[board][0] = tmp;
  662   2              buffer[0] = tmp;
  663   2              address   = 0x40;
  664   2              I2C_SendByte(address, 1, buffer);
  665   2          }
  666   1      
  667   1          if (OnOff == 1)
  668   1          {
  669   2              if (speaker < 4)
  670   2              {
  671   3                  address  = 0x44;
  672   3                  tmp = statusBoards[board][1];
  673   3                  if (channel == stimSnd1)
  674   3                      tmp &= gain1[speaker];
  675   3                  else
  676   3                      tmp &= gain2[speaker];
  677   3                  statusBoards[board][1] = tmp;
  678   3              }
  679   2              else
  680   2              {
  681   3                  address  = 0x42;
  682   3                  tmp = statusBoards[board][2];
  683   3                  if (channel == stimSnd1)
  684   3                      tmp &= gain1[speaker];
  685   3                  else
  686   3                      tmp &= gain2[speaker];
  687   3                  statusBoards[board][2] = tmp;
  688   3              }
  689   2          }
  690   1          else
  691   1          {
  692   2              if (speaker < 4)
  693   2              {
  694   3                  address  = 0x44;
  695   3                  tmp = statusBoards[board][1];
  696   3                  if (channel == stimSnd1)
  697   3                      tmp |= ~gain1[speaker];
  698   3                  else
  699   3                      tmp |= ~gain2[speaker];
  700   3                  statusBoards[board][1] = tmp;
  701   3              }
  702   2              else
  703   2              {
  704   3                  address  = 0x42;
  705   3                  tmp = statusBoards[board][2];
  706   3                  if (channel == stimSnd1)
  707   3                      tmp |= ~gain1[speaker];
  708   3                  else
  709   3                      tmp |= ~gain2[speaker];
  710   3                  statusBoards[board][2] = tmp;
  711   3              }
  712   2          }
  713   1          buffer[0] = tmp;
  714   1          I2C_SendByte(address, 1, buffer);
  715   1      
  716   1          n = sprintf(outBuf,"%d\n",tmp);
  717   1          i = UART0_Str(outBuf, n);
  718   1      
  719   1          nBuffer[1] = 0;
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 12  

  720   1      }
  721          
  722          void setFixWindow()
  723          {
  724   1          int i,n;
  725   1          int id = nBuffer[2];
  726   1          fixWindows[id].fix  = 0;
  727   1          fixWindows[id].Xnet = nBuffer[3];
  728   1          fixWindows[id].Ynet = nBuffer[4];
  729   1          fixWindows[id].Xh   = nBuffer[5]; ///10.0;
  730   1          fixWindows[id].Yh   = nBuffer[6]; ///10.0;
  731   1          fixWindows[id].time = 0;
  732   1      
  733   1          n=sprintf(outBuf,"%d %d %d %d\n",
  734   1              fixWindows[id].Xnet,
  735   1              fixWindows[id].Ynet,
  736   1              (int) fixWindows[id].Xh,
  737   1              (int) fixWindows[id].Yh);
  738   1          i = UART0_Str(outBuf, n);
  739   1      
  740   1          nBuffer[1] = 0;
  741   1      }
  742          
  743          /***************************************************************************************/
  744          void execInit()
  745          {
  746   1          int n, i;
  747   1          MCS   = statInit;
  748   1          nStim = 0;
  749   1          n = sprintf(outBuf,"%d\n",curTime);
  750   1          i = UART0_Str(outBuf, n);
  751   1      
  752   1          nBuffer[1] = 0;
  753   1      }
  754          /***************************************************************************************/
  755          void getTime()
  756          {
  757   1          int val;
  758   1          int n, i;
  759   1          val = Clock_GetTicks();
  760   1          n = sprintf(outBuf,"%d\n",val);
  761   1          i = UART0_Str(outBuf, n);
  762   1          nBuffer[1] = 0;
  763   1      }
  764          /***************************************************************************************/
  765          void clrTime()
  766          {
  767   1          Clock_Reset();
  768   1          getTime();
  769   1          nBuffer[1] = 0;
  770   1      }
  771          /***************************************************************************************/
  772          void execReset()
  773          {
  774   1          int n,i;
  775   1      
  776   1      //  Clock_Reset();
  777   1          softReset();
  778   1          n = sprintf(outBuf,"%d\n",curTime);
  779   1          i = UART0_Str(outBuf, n);
  780   1          nBuffer[1] = 0;
  781   1      }
  782          /***************************************************************************************/
  783          void execAbort()
  784          {
  785   1          int n,i;
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 13  

  786   1          
  787   1          execError();
  788   1          n = sprintf(outBuf,"-998\n");
  789   1          i = UART0_Str(outBuf, n);
  790   1          MCS   = statInit;
  791   1          nStim = 0;
  792   1          nBuffer[1] = 0;
  793   1      }
  794          /***************************************************************************************/
  795          void execSaveTrial()
  796          {
  797   1          int i,n,lp;
  798   1      
  799   1          n = sprintf(outBuf,"%d %d %d\n",nStim, T_ITI, T_trial);
  800   1          i = UART0_Str(outBuf, n);
  801   1          for (lp = 0; lp < nStim; lp++)
  802   1          {
  803   2              WaitForEnter();
  804   2              n = sprintf(outBuf,"%d %d %d %d\n",
  805   2                  stim[lp].kind,stim[lp].status,stim[lp].startTime,stim[lp].stopTime);
  806   2              i = UART0_Str(outBuf, n);
  807   2          }
  808   1          MCS = statInit;
  809   1          nBuffer[1] = 0;
  810   1      }
  811          /***************************************************************************************/
  812          int execRew(int index)
  813          {
  814   1          int newTime = Clock_GetTicks() - T_start;
  815   1      
  816   1          if (stim[index].status == statInit)
  817   1          {
  818   2              if ((stim[index].startRef == 0) && (curTime >= stim[index].startTime))
  819   2              {
  820   3                  stim[index].startTime = newTime;
  821   3                  stim[index].status    = statRun;
  822   3                  SetBitsPar(rewBit);   // Trigger high
  823   3                  parOutp |= rewBit;
  824   3                  return 1;
  825   3              }
  826   2              return 2;
  827   2          }
  828   1          
  829   1          if (stim[index].status == statRun)
  830   1          {
  831   2              if ((stim[index].stopRef == 0) && (curTime >= stim[index].stopTime))
  832   2              {
  833   3                  ClrBitsPar(rewBit);
  834   3                  stim[index].stopTime = newTime;
  835   3                  stim[index].status   = statDone;
  836   3                  execEvent(stim[index].event);
  837   3                  return 0;
  838   3              }
  839   2              return 1;
  840   2          }
  841   1          return 0;
  842   1      }
  843          /***************************************************************************************/
  844          int execLas(int index)
  845          {
  846   1          int newTime = Clock_GetTicks() - T_start;
  847   1      
  848   1          if (stim[index].status == statInit)
  849   1          {
  850   2              if ((stim[index].startRef == 0) && (curTime >= stim[index].startTime))
  851   2              {
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 14  

  852   3                  stim[index].startTime = newTime;
  853   3                  stim[index].status    = statRun;
  854   3                  SetBitsPar(lasBit);   // Trigger high
  855   3                  parOutp |= lasBit;
  856   3                  return 1;
  857   3              }
  858   2              return 2;
  859   2          }
  860   1          
  861   1          if (stim[index].status == statRun)
  862   1          {
  863   2              if ((stim[index].stopRef == 0) && (curTime >= stim[index].stopTime))
  864   2              {
  865   3                  ClrBitsPar(lasBit);
  866   3                  stim[index].stopTime = newTime;
  867   3                  stim[index].status   = statDone;
  868   3                  execEvent(stim[index].event);
  869   3                  return 0;
  870   3              }
  871   2              return 1;
  872   2          }
  873   1          return 0;
  874   1      }
  875          /***************************************************************************************/
  876          void getBarState()
  877          {
  878   1          int i, n;
  879   1          n = sprintf(outBuf,"%d\n",curTime);
  880   1          i = UART0_Str(outBuf, n);
  881   1          nBuffer[1] = 0;
  882   1      }
  883          /***************************************************************************************/
  884          void getADC()
  885          {
  886   1          int n, i;
  887   1          double val0, val1, val2, val3, val4, val5, val6, val7;
  888   1      //  adc_buffer AdcBuffer;
  889   1      
  890   1      //  AdcBuffer = ADC_GetSamples();
  891   1          val0 = AdcBuffer.data[0][0];
  892   1          val1 = AdcBuffer.data[1][0];
  893   1          val2 = AdcBuffer.data[2][0];
  894   1          val3 = AdcBuffer.data[3][0];
  895   1          val4 = AdcBuffer.data[4][0];
  896   1          val5 = AdcBuffer.data[5][0];
  897   1          val6 = AdcBuffer.data[6][0];
  898   1          val7 = AdcBuffer.data[7][0];
  899   1      
  900   1          n = sprintf(outBuf,"%d %f %f %f %f %f %f %f %f\n",Clock_GetTicks(),val0,val1,val2,val3,val4,val5,val6,va
             -l7);
  901   1          i = UART0_Str(outBuf, n);
  902   1          nBuffer[1] = 0;
  903   1      }
  904          void selectADC()
  905          {
  906   1          int n, i;
  907   1      //  ADC_Select(nBuffer[2]); 
  908   1      
  909   1          n = sprintf(outBuf,"%d\n",curTime);
  910   1          i = UART0_Str(outBuf, n);
  911   1          nBuffer[1] = 0;
  912   1      }
  913          int softReset()
  914          {
  915   1          if (InitAll()  != 0)
  916   1              return -1;
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 15  

  917   1          ClrAllBitsPar();
  918   1          Clock_Reset();
  919   1                            
  920   1          MCS = statInit;
  921   1          nStim = 0;
  922   1          return 0;
  923   1      }
  924          /* =================================================================================== */
  925          /* =                            Algemeen gebruikte functies                          = */
  926          /* = ------------------------------------------------------------------------------- = */
  927          /* = Delay      -> Simple delay function                                             = */
  928          /* = getWord    -> Get one word from the input buffer                                = */
  929          /* = getVal     -> Returns the value of a word (getWord)                             = */
  930          /* = splitInput -> Splits het input buffer in een array                              = */
  931          /* = InitAll    -> Initialize the controller, ledsky ed                              = */
  932          /* =================================================================================== */
  933          void Delay (unsigned long a)
  934          {
  935   1          while (--a != 0);
  936   1      }
  937          /* *********************************************************************************** */
  938          void getWord(void) 
  939          {
  940   1          int pnt = 0;
  941   1          while ((inBuf[inpPnt] != ';') && (inBuf[inpPnt] != '\0'))
  942   1          {
  943   2              wrd[pnt++] = inBuf[inpPnt++];
  944   2          }
  945   1          wrd[pnt] = '\0';
  946   1          if (inBuf[inpPnt] == '\0') inpPnt = -1; else inpPnt++;
  947   1      }
  948          /* *********************************************************************************** */
  949          int getVal(void) 
  950          {
  951   1          int val = 0;
  952   1          int pnt = 0;
  953   1          if (wrd[0] == '-')
  954   1          {
  955   2              val = -1*(wrd[1] - '0');
  956   2              pnt = 2;
  957   2              while (wrd[pnt] != '\0')
  958   2              {
  959   3                  val *= 10;
  960   3                  val -= wrd[pnt++] - '0';
  961   3              }
  962   2          }
  963   1          else
  964   1          {
  965   2              val = (wrd[0]- '0');
  966   2              pnt = 1;
  967   2              while (wrd[pnt] != '\0')
  968   2              {
  969   3                  val *= 10;
  970   3                  val += wrd[pnt++] - '0';
  971   3              }
  972   2          }
  973   1          return val;
  974   1      }
  975          /* *********************************************************************************** */
  976          void splitInput(void)                   
  977          {
  978   1          int i;
  979   1          outPnt = 0;
  980   1          if (inBuf[0] == '$')
  981   1          {
  982   2              for (i=0; i < 128; i++)
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 16  

  983   2              {
  984   3                  if (inBuf[i] == ';') inBuf[i] = ' ';
  985   3                  if (inBuf[i] == '$') inBuf[i] = ' ';
  986   3              }
  987   2              sscanf(inBuf,"%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f",
  988   2              &rBuffer[0],&rBuffer[1],&rBuffer[2],&rBuffer[3],&rBuffer[4],&rBuffer[5],&rBuffer[6],&rBuffer[7],
  989   2              &rBuffer[8],&rBuffer[9],&rBuffer[10],&rBuffer[11],&rBuffer[12],&rBuffer[13],&rBuffer[14],
  990   2              &rBuffer[15],&rBuffer[16],&rBuffer[17],&rBuffer[18],&rBuffer[19],&rBuffer[20],&rBuffer[21],
  991   2              &rBuffer[22],&rBuffer[23],&rBuffer[24]);
  992   2              nBuffer[1] = (int) rBuffer[0];
  993   2              if (nBuffer[1] != cmdNNMod)
  994   2              {
  995   3                  outPnt = 2;
  996   3                  for (i=1; i<24; i++) nBuffer[outPnt++] = (int) rBuffer[i];
  997   3              }
  998   2          }
  999   1          nBuffer[0] = outPnt-1;
 1000   1      }
 1001          /* *********************************************************************************** */
 1002          int InitAll()
 1003          {
 1004   1          unsigned char buffer[4];
 1005   1          int n, i;
 1006   1          
 1007   1          LPCinit();
 1008   1          IODIR0  = 0x00008FF0;   // P0.4-P0.11 as output bit 0..7
 1009   1                                  // PO.15 as switch for multiplexer
 1010   1                                  // PO.18-P0.25 as input bit 0..7
 1011   1          IOSET0 |= 0x00000FF0;   // LED off 
 1012   1      
 1013   1          Clock_Init();           // interrupt 0                         
 1014   1          I2C_Init();             // interrupt 1
 1015   1          UART0_Init();           // interrupt 2
 1016   1          ADC_Init();             // interrupt 3, channel 0
 1017   1      
 1018   1          for (n=0; n<4; n++) NNs[n].active = 0;
 1019   1      //  ne: front-low, front-high, back-low, back-high.
 1020   1          for (n=0; n < 2; n++)
 1021   1          {
 1022   2              for (i=0; i < 4; i++)
 1023   2              {
 1024   3                  Leds[n][0][i].data    = 0; 
 1025   3                  Leds[n][0][i].level   = 0;
 1026   3                  Leds[n][1][i].data    = 0; 
 1027   3                  Leds[n][1][i].level   = 0;
 1028   3              }
 1029   2          }
 1030   1          for (i=0; i < 4; i++)
 1031   1          {
 1032   2              Leds[0][0][i].address = 0xF7; // Front 1-15
 1033   2              Leds[0][1][i].address = 0xFB; // Front 16-31
 1034   2              Leds[1][0][i].address = 0xFD; // Back 101-115
 1035   2              Leds[1][1][i].address = 0xFE; // Back 116-129
 1036   2          }
 1037   1      
 1038   1          Sky[ 0].address  = 0x76;  Sky[ 0].data   = 0; Sky[ 0].level   = 0x00;
 1039   1          Sky[ 1].address  = 0x74;  Sky[ 1].data   = 0; Sky[ 1].level   = 0x00;
 1040   1          Sky[ 2].address  = 0x74;  Sky[ 2].data   = 0; Sky[ 2].level   = 0x00;
 1041   1          Sky[ 3].address  = 0x74;  Sky[ 3].data   = 0; Sky[ 3].level   = 0x00;
 1042   1          Sky[ 4].address  = 0x74;  Sky[ 4].data   = 0; Sky[ 4].level   = 0x00;
 1043   1          Sky[ 5].address  = 0x74;  Sky[ 5].data   = 0; Sky[ 5].level   = 0x00;
 1044   1          Sky[ 6].address  = 0x74;  Sky[ 6].data   = 0; Sky[ 6].level   = 0x00;
 1045   1          Sky[ 7].address  = 0x74;  Sky[ 7].data   = 0; Sky[ 7].level   = 0x00;
 1046   1          Sky[ 8].address  = 0x74;  Sky[ 8].data   = 0; Sky[ 8].level   = 0x00;
 1047   1          Sky[ 9].address  = 0x76;  Sky[ 9].data   = 0; Sky[ 9].level   = 0x00;
 1048   1          Sky[10].address  = 0x76;  Sky[10].data   = 0; Sky[10].level   = 0x00;
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 17  

 1049   1          Sky[11].address  = 0x76;  Sky[11].data   = 0; Sky[11].level   = 0x00;
 1050   1          Sky[12].address  = 0x76;  Sky[12].data   = 0; Sky[12].level   = 0x00;
 1051   1          ClearSky();
 1052   1          ClearArc();
 1053   1      
 1054   1          buffer[0] = 0x00;
 1055   1          buffer[1] = 0x76;
 1056   1          buffer[2] = 0x00;                                                          
 1057   1          buffer[3] = 0x00;
 1058   1          I2C_SendByte(0x70, 4, buffer);
 1059   1      
 1060   1          for (i=0; i < 8; i++)
 1061   1          {
 1062   2              buffer[0] = boards[i];
 1063   2              I2C_SendByte(0x4E, 1, buffer);
 1064   2              buffer[0] = 0xFF;
 1065   2              I2C_SendByte(0x42, 1, buffer);
 1066   2              I2C_SendByte(0x44, 1, buffer);
 1067   2              statusBoards[i][0] = 0xFF;  
 1068   2              statusBoards[i][1] = 0xFF;  
 1069   2              statusBoards[i][2] = 0xFF;  
 1070   2          }
 1071   1      
 1072   1          return(0);
 1073   1      }
 1074          /* =================================================================================== */
 1075          /* =                            Driver functions                                     = */
 1076          /* = ------------------------------------------------------------------------------- = */
 1077          /* = PCA 9532 IC's are used for arche and ledsky leds.                               = */
 1078          /* = De PCA 9532 is a 15-bit I2C led dimmer                                          = */
 1079          /* = ------------------------------------------------------------------------------- = */
 1080          /* = clrArc     -> All leds Arche off                                                = */
 1081          /* = clrSky     -> All leds sky off                                                  = */
 1082          /* = LedOnOff   -> 1 Led at the arche on/off                                         = */
 1083          /* = SkyOnOff   -> 1 Led at the sky on/off                                           = */
 1084          /* =================================================================================== */
 1085          void ClearArc(void)
 1086          {
 1087   1          int index;
 1088   1          for (index = 1; index <= 31; index++)
 1089   1              LedOnOff(index, 0, OFF);
 1090   1          for (index = 101; index <=129; index++)
 1091   1              LedOnOff(index, 0, OFF);
 1092   1      }
 1093          /* *********************************************************************************** */
 1094          void ClearSky(void)
 1095          {
 1096   1          int spaak, led;
 1097   1          SkyOnOff(0, 1, 0, OFF);
 1098   1          SkyOnOff(0, 2, 0, OFF);
 1099   1          for (spaak = 1; spaak <= 12; spaak++)
 1100   1          {
 1101   2              for (led = 0; led <= 7; led++)
 1102   2              {
 1103   3                  SkyOnOff(spaak, led, 0, OFF);
 1104   3              }
 1105   2          }
 1106   1      }
 1107          /* *********************************************************************************** */
 1108          void LedOnOff(int index, int level, int OnOff)
 1109          {
 1110   1          int n, ic, led, ls, tmp;
 1111   1          unsigned char buffer[4];
 1112   1          int PWM1 = 0x14;    // (autoincrement (16) + register
 1113   1          int LS0  = 0x06;    
 1114   1          int LS1  = 0x07;    
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 18  

 1115   1          int LS2  = 0x08;    
 1116   1          int LS3  = 0x09;
 1117   1                          //   1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 
             -29 30 31 32}
 1118   1      #ifdef Fart1
                   int ledsIndex[] = { 13,12,11,10, 9, 8, 7, 6, 5, 4, 3, 2, 1,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,
             -17,15,14};
               #endif
 1121   1      
 1122   1      #ifdef Fart2
 1123   1          int ledsIndex[] = { 16,15,14,13,12,11,10, 9, 8, 7, 6, 5, 4, 3, 2, 1,32,31,30,29,28,27,26,25,24,23,22,21,
             -20,19,18,17};
 1124   1      #endif
 1125   1      
 1126   1          // Leds at the front are numbered from 1..32
 1127   1          // Leds at the back are numbered from 101..132
 1128   1          if (index > 100) led = index - 100; else led = index; // Range now 1..32 
 1129   1          led = ledsIndex[led-1];                               // for the electronincs
 1130   1          if (led <= 16) ic = 0; else ic = 1;                   // IC 1..2
 1131   1          led = led - ic*16;                                    // led 1..16
 1132   1          ls = (led-1)/4;                                       // led selector 1..4
 1133   1      
 1134   1          if (index < 100) n = 0; else n = 1;
 1135   1          buffer[0] = Leds[n][ic][ls].address;                  // address led-IC
 1136   1          I2C_SendByte(0x72, 1, buffer);                        // load pre-selection with address
 1137   1      
 1138   1          // set level
 1139   1          buffer[0] = PWM1;               // subaddress
 1140   1          buffer[1] = 0;                  // PSC1
 1141   1          buffer[2] = level & 0xFF;
 1142   1          I2C_SendByte(0xC0, 3, buffer);  // preselection determines the address of C0
 1143   1      
 1144   1          // update data
 1145   1          led = (led-1) % 4;
 1146   1          tmp = (0x03 << (2*(led)));      // 11 = blink at PWM1 rate
 1147   1          if (OnOff == ON)
 1148   1              Leds[n][ic][ls].data |= tmp;
 1149   1          else 
 1150   1              Leds[n][ic][ls].data &= ~tmp;
 1151   1      
 1152   1          switch(ls)
 1153   1          {
 1154   2          case 0: buffer[0] = LS0; break;
 1155   2          case 1: buffer[0] = LS1; break;
 1156   2          case 2: buffer[0] = LS2; break;
 1157   2          case 3: buffer[0] = LS3; break;
 1158   2          }
 1159   1          buffer[1] = Leds[n][ic][ls].data & 0xFF;
 1160   1          I2C_SendByte(0xC0, 2, buffer);
 1161   1      
 1162   1          buffer[0] = 0xFF;
 1163   1          I2C_SendByte(0x72,1,buffer);
 1164   1              
 1165   1      }
 1166          /* *********************************************************************************** */
 1167          void SkyOnOff(int spaak, int led, int level, int OnOff)
 1168          {
 1169   1          int tmp;
 1170   1          unsigned char buffer[4];
 1171   1          int PWM1 = 0x14;    // (autoincrement (16) + register
 1172   1          int LS0  = 0x06;    
 1173   1          int LS1  = 0x07;    
 1174   1      
 1175   1          if (spaak == 0)
 1176   1          {
 1177   2              buffer[0] = 0xEF;
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 19  

 1178   2          }
 1179   1          else
 1180   1          {
 1181   2              if (spaak < 9)
 1182   2                  buffer[0] = ~(1 << (spaak-1)); 
 1183   2              else
 1184   2                  buffer[0] = ~(1 << (spaak-9)); 
 1185   2          }
 1186   1          I2C_SendByte(Sky[spaak].address, 1, buffer);  // laad pre-selectie met spaak-IC
 1187   1          // set level
 1188   1          buffer[0] = PWM1;   // subaddress
 1189   1          buffer[1] = 0;      // PSC1
 1190   1          buffer[2] = level & 0xFF;
 1191   1          I2C_SendByte(0xC0, 3, buffer);
 1192   1          // update data
 1193   1          if (spaak == 0)
 1194   1          {
 1195   2              buffer[0] = LS0;
 1196   2              tmp = (0x03 << (2*(led-1)));
 1197   2              if (OnOff == ON)
 1198   2                  Sky[spaak].data |= tmp;
 1199   2              else 
 1200   2                  Sky[spaak].data &= ~tmp;
 1201   2              buffer[1] = Sky[spaak].data;
 1202   2          }
 1203   1          else
 1204   1          {
 1205   2              tmp = (0x03 << (2*(led-1)));
 1206   2              if (OnOff == ON)
 1207   2                  Sky[spaak].data |= tmp;
 1208   2              else 
 1209   2                  Sky[spaak].data &= ~tmp;
 1210   2              if (led < 5)
 1211   2              {
 1212   3                  buffer[0] = LS0;
 1213   3                  buffer[1] = (Sky[spaak].data & 0xFF);
 1214   3              }
 1215   2              else
 1216   2              {
 1217   3                  buffer[0] = LS1;
 1218   3                  buffer[1] = ((Sky[spaak].data >> 8) & 0xFF);
 1219   3              }
 1220   2          }
 1221   1          I2C_SendByte(0xC0, 2, buffer);
 1222   1          buffer[0] = 0xFF;
 1223   1          I2C_SendByte(Sky[spaak].address, 1, buffer);
 1224   1      }
 1225          /* =================================================================================== */
 1226          /* =                    Functies voor het uitvoeren van een commando                 = */
 1227          /* = ------------------------------------------------------------------------------- = */
 1228          /* = cmdStim        -> execStim         -> Voert een stim uit buiten de FSM om       = */
 1229          /* = cmdInfo        -> getInfo          -> Geeft de string LPC2119->Monkey.........  = */
 1230          /* = cmdClock       -> getClock         -> Geeft de tijd controller in seconds       = */
 1231          /* = cmdState       -> getState         -> Geeft de fase (2..0) van de afzonderlijke = */
 1232          /*                                         stimuli                                   = */
 1233          /* = cmdStateTrial  -> getStateTrial    -> Geeft de fase waar de trial zich bevindt  = */
 1234          /* = cmdNextTrial   -> execNextTrial    -> Start inlezen stimuli van nieuwe trial    = */
 1235          /* = cmdStartTrial  -> execStartTrial   -> Start uitvoeren van een nieuwe trial      = */
 1236          /* =================================================================================== */
 1237          void execStim()
 1238          {
 1239   1          int bit, level, n=0, i;
 1240   1          int value;
 1241   1          int outFlag = 0;
 1242   1          switch (nBuffer[2])
 1243   1          {
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 20  

 1244   2          case stimDin:
 1245   2              value = GetBitsPar();
 1246   2              value = ((parOutp << 8) | value);
 1247   2              //            bitNo
 1248   2              bit = (1 << nBuffer[3]-1);
 1249   2              if ((value & bit) == 0) bit = 0; else bit = 1;
 1250   2              n = sprintf(outBuf,"%d\n",bit);
 1251   2              break;
 1252   2          case stimDout:
 1253   2              //            bitNo 
 1254   2              bit = (1 << nBuffer[3]-1);
 1255   2              level = nBuffer[4];
 1256   2              if (level > 0)
 1257   2              {
 1258   3                  SetBitsPar(bit);
 1259   3                  parOutp |= bit;
 1260   3              }
 1261   2               else
 1262   2              { 
 1263   3                  ClrBitsPar(bit);
 1264   3                  parOutp &= ~bit;
 1265   3              }
 1266   2              n = sprintf(outBuf,"%d\n",curTime);
 1267   2              break;
 1268   2          case stimSky:
 1269   2              //          spoke       ring        int         onoff
 1270   2              SkyOnOff(nBuffer[3], nBuffer[4], nBuffer[5], nBuffer[6]);
 1271   2              n = sprintf(outBuf,"%d\n",curTime);
 1272   2              break;
 1273   2          case stimLed:
 1274   2              //          Y          int         onoff
 1275   2              LedOnOff(nBuffer[4], nBuffer[5], nBuffer[6]);
 1276   2              n = sprintf(outBuf,"%d\n",curTime);
 1277   2              break;
 1278   2          case stimSelADC:
 1279   2              //
 1280   2      //      ADC_Select(nBuffer[3]);
 1281   2              n = sprintf(outBuf,"%d\n",curTime);
 1282   2              break;
 1283   2          case stimADC:
 1284   2              //
 1285   2              getADC();
 1286   2              outFlag = 1;
 1287   2              break;
 1288   2          default:
 1289   2              n = sprintf(outBuf,"%d\n",curTime);
 1290   2              break;
 1291   2          }
 1292   1      
 1293   1          if (outFlag == 0)
 1294   1          {
 1295   2              i = UART0_Str(outBuf, n);
 1296   2              nBuffer[1] = 0;
 1297   2          }
 1298   1      }
 1299          void getInfo()
 1300          {
 1301   1          int n, i;
 1302   1      
 1303   1          n = 0;
 1304   1          while ((n < 80) && (version[n] > 0)) n++;
 1305   1          i = UART0_Str(version, n);
 1306   1          nBuffer[1] = 0;
 1307   1      }
 1308          /* *********************************************************************************** */
 1309          void getClock()
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 21  

 1310          {
 1311   1          int val;
 1312   1          int n, i;
 1313   1          val = Clock_GetSeconds();
 1314   1          n = sprintf(outBuf,"%d\n",val);
 1315   1          i = UART0_Str(outBuf, n);
 1316   1          nBuffer[1] = 0;
 1317   1      }
 1318          /* *********************************************************************************** */
 1319          void getState()
 1320          {
 1321   1          int n, i;
 1322   1          
 1323   1          n = 0;
 1324   1          while ((n < 80) && (state[n] > 0)) n++;
 1325   1          i = UART0_Str(state, n);
 1326   1          nBuffer[1] = 0;
 1327   1      }
 1328          /* *********************************************************************************** */
 1329          void getStateTrial()
 1330          {
 1331   1          int n, i;
 1332   1          
 1333   1          n = sprintf(outBuf,"%d\n",MCS);
 1334   1          i = UART0_Str(outBuf, n);
 1335   1          nBuffer[1] = 0;
 1336   1      }
 1337          /* *********************************************************************************** */
 1338          void execNextTrial()
 1339          {
 1340   1          int n,i;
 1341   1      
 1342   1          nStim   = 0;
 1343   1          MCS     = statNextTrial;        
 1344   1      
 1345   1          n = sprintf(outBuf,"%d\n",curTime);
 1346   1          i = UART0_Str(outBuf, n);
 1347   1          nBuffer[1] = 0;
 1348   1      }
 1349          /* *********************************************************************************** */
 1350          void execStartTrial()
 1351          {
 1352   1          int n,i;
 1353   1      //  while (Clock_GetTicks() < (T_ITI+ITI));
 1354   1          T_start = Clock_GetTicks();
 1355   1          T_ITI   = T_start - T_done;
 1356   1          MCS = statRunTrial;
 1357   1          errFlag = false;
 1358   1          n = sprintf(outBuf,"%d\n",curTime);
 1359   1          i = UART0_Str(outBuf, n);
 1360   1          nBuffer[1] = 0;
 1361   1      }
 1362          /* =================================================================================== */
 1363          /* =                    Functies voor het uitvoeren van een stimulus                 = */
 1364          /* = ------------------------------------------------------------------------------- = */
 1365          /* =                -> execEvent        -> Verwerken van events                      = */
 1366          /* = stimBar        -> execBar          -> Inlezen van toestand drukknop             = */
 1367          /* = stimSky        -> execSky          -> Led op de sky aan/uit                     = */
 1368          /* = stimLed        -> execLed          -> Led op de boog aan/uit                    = */
 1369          /* = stimRec        -> execRec          -> Start RA16 TDT circuit                    = */
 1370          /* =================================================================================== */
 1371          void execEvent(int event)
 1372          {
 1373   1          int i;
 1374   1          int newTime = Clock_GetTicks() - T_start;
 1375   1          if (event == 99)
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 22  

 1376   1          {
 1377   2              execError();
 1378   2          }
 1379   1          else
 1380   1          {
 1381   2              if (event != 0)
 1382   2              {
 1383   3              for (i = 0; i < nStim; i++) 
 1384   3                  {
 1385   4                      if (stim[i].startRef == event)
 1386   4                      {
 1387   5                          stim[i].startRef = 0;
 1388   5                          stim[i].startTime += newTime;
 1389   5                      }
 1390   4                      if (stim[i].stopRef == event)
 1391   4                      {
 1392   5                          stim[i].stopRef = 0;
 1393   5                          stim[i].stopTime += newTime;
 1394   5                      }
 1395   4                  }
 1396   3              }
 1397   2          }
 1398   1      }
 1399          /* *********************************************************************************** */
 1400          int execBar(int index)
 1401          {
 1402   1          int ans = 0;
 1403   1          switch(stim[index].mode)
 1404   1          {
 1405   2          case 0: ans = execBarFlank(index);  break;
 1406   2          case 1: ans = execBarLevel(index);  break;
 1407   2          case 2: ans = execBarCheck(index);  break;
 1408   2          }
 1409   1          return ans;
 1410   1      }
 1411          /* *********************************************************************************** */
 1412          int execBarLevel(int index)
 1413          {
 1414   1          int newTime = Clock_GetTicks() - T_start;
 1415   1          int barBit  = (1 << (stim[index].bitNo-1));
 1416   1          int barEdge = stim[index].edge;
 1417   1          int mode    = stim[index].mode;
 1418   1      
 1419   1          if (stim[index].status == statInit)
 1420   1          {
 1421   2              if (stim[index].startRef == 0)
 1422   2              {
 1423   3                  if(curTime < stim[index].startTime)  // end off start delay ?
 1424   3                      return 2;
 1425   3                  else
 1426   3                  {
 1427   4                      stim[index].startTime = newTime;
 1428   4                      stim[index].status    = statRun;
 1429   4                      return 1;
 1430   4                  }
 1431   3              }
 1432   2              else
 1433   2                  return 2;
 1434   2          }
 1435   1          
 1436   1      
 1437   1          if (stim[index].status == statRun)
 1438   1          {
 1439   2              if (stim[index].stopRef == 0)           // endtime set ?
 1440   2              {                                       // yes
 1441   3                  if (curTime < stim[index].stopTime) // and reached
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 23  

 1442   3                  {                                   // no
 1443   4                      // positive, bit must be set
 1444   4                      // negative, bit must be cleared
 1445   4                      if (((barEdge == 1) && ((parInp & barBit) == 0)) ||
 1446   4                          ((barEdge == 0) && ((parInp & barBit) >  0)))
 1447   4                      {
 1448   5                          stim[index].stopTime = newTime;
 1449   5                          execError();
 1450   5                          return 0;
 1451   5                      }
 1452   4                      return 1;
 1453   4                  }
 1454   3                  else
 1455   3                  {
 1456   4                      stim[index].stopTime = newTime;
 1457   4                      stim[index].status   = statDone;
 1458   4                      execEvent(stim[index].event);
 1459   4                      return 0;                   // exit after executing event
 1460   4                  }
 1461   3              }
 1462   2              else
 1463   2              {                                   // no endtime
 1464   3                  // positive, bit must be set
 1465   3                  // negative, bit must be cleared
 1466   3                  if (((barEdge == 1) && ((parInp & barBit) ==  0)) ||
 1467   3                      ((barEdge == 0) && ((parInp & barBit) >   0)))
 1468   3                  {
 1469   4                      stim[index].stopTime = newTime;
 1470   4                      execError();
 1471   4                      return 0;
 1472   4                  }
 1473   3                  return 1;
 1474   3              }
 1475   2          }
 1476   1      
 1477   1          return 0;
 1478   1      }
 1479          /* *********************************************************************************** */
 1480          int execBarCheck(int index)
 1481          {
 1482   1          int newTime = Clock_GetTicks() - T_start;
 1483   1          int barBit  = (1 << (stim[index].bitNo-1));
 1484   1          int barEdge = stim[index].edge;
 1485   1          int mode    = stim[index].mode;
 1486   1      
 1487   1          if (stim[index].status == statInit)
 1488   1          {
 1489   2              if (stim[index].startRef == 0)
 1490   2              {
 1491   3                  if(curTime < stim[index].startTime)  // end off start delay ?
 1492   3                      return 2;
 1493   3                  else
 1494   3                  {
 1495   4                      stim[index].startTime = newTime;
 1496   4                      stim[index].status    = statRun;
 1497   4                      return 1;
 1498   4                  }
 1499   3              }
 1500   2              else
 1501   2                  return 2;
 1502   2          }
 1503   1          
 1504   1      
 1505   1          if (stim[index].status == statRun)
 1506   1          {
 1507   2              if (stim[index].stopRef == 0)           // endtime set ?
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 24  

 1508   2              {                                       // yes
 1509   3                  if (curTime < stim[index].stopTime) // and reached
 1510   3                  {                                   // no
 1511   4                      // positive, bit must be set
 1512   4                      // negative, bit must be cleared
 1513   4                      if (((barEdge == 1) && ((parInp & barBit) >  0)) ||
 1514   4                          ((barEdge == 0) && ((parInp & barBit) == 0)))
 1515   4                      {
 1516   5                          stim[index].stopTime = newTime;
 1517   5                          stim[index].status   = statDone;
 1518   5                          execEvent(stim[index].event);
 1519   5                          return 0;                   // exit after executing event
 1520   5                      }
 1521   4                      return 1;
 1522   4                  }
 1523   3                  else
 1524   3                  {
 1525   4                      stim[index].stopTime = newTime;
 1526   4                      execError();
 1527   4                      return 0;
 1528   4                  }
 1529   3              }
 1530   2              else
 1531   2              {                                   // no endtime
 1532   3                  // positive, bit must be set
 1533   3                  // negative, bit must be cleared
 1534   3                  if (((barEdge == 1) && ((parInp & barBit) >  0)) ||
 1535   3                      ((barEdge == 0) && ((parInp & barBit) == 0)))
 1536   3                  {
 1537   4                      stim[index].stopTime = newTime;
 1538   4                      stim[index].status   = statDone;
 1539   4                      execEvent(stim[index].event);
 1540   4                      return 0;   // exit after executing event
 1541   4                  }
 1542   3                  return 1;
 1543   3              }
 1544   2          }
 1545   1      
 1546   1          return 0;
 1547   1      }
 1548          /* *********************************************************************************** */
 1549          int execBarFlank(int index)
 1550          {
 1551   1          int newTime = Clock_GetTicks() - T_start;
 1552   1          int barBit  = (1 << (stim[index].bitNo-1));
 1553   1          int barEdge = stim[index].edge;
 1554   1          int mode    = stim[index].mode;
 1555   1      
 1556   1          if (stim[index].status == statInit)
 1557   1          {
 1558   2              if (stim[index].startRef == 0)
 1559   2              {
 1560   3                  if(curTime < stim[index].startTime)  // end off start delay ?
 1561   3                  {                                    // no
 1562   4                      // positive flank, bit must be cleared
 1563   4                      // negative flank, bit must be set
 1564   4                      if (((barEdge == 1) && ((parInp & barBit) == 0)) ||
 1565   4                          ((barEdge == 0) && ((parInp & barBit) >  0)))
 1566   4                      {
 1567   5                          return 2;
 1568   5                      }
 1569   4                      else
 1570   4                      {
 1571   5                          stim[index].startTime = newTime;
 1572   5                          execError();
 1573   5                          return 0;                   // exit with error
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 25  

 1574   5                      }
 1575   4                  }
 1576   3                  else
 1577   3                  {                                   // yes, start run fase
 1578   4                      stim[index].startTime = newTime;
 1579   4                      stim[index].status    = statRun;
 1580   4                      return 1;
 1581   4                  }
 1582   3              }
 1583   2              else
 1584   2                  return 2;
 1585   2          }
 1586   1          
 1587   1      
 1588   1          if (stim[index].status == statRun)
 1589   1          {
 1590   2              if (stim[index].stopRef == 0)           // endtime set ?
 1591   2              {                                       // yes
 1592   3                  if (curTime < stim[index].stopTime) // and reached
 1593   3                  {                                   // no
 1594   4                      // positive flank, bit must be set
 1595   4                      // negative flank, bit must be cleared
 1596   4                      if (((barEdge == 1) && ((parInp & barBit) >  0)) ||
 1597   4                          ((barEdge == 0) && ((parInp & barBit) == 0)))
 1598   4                      {
 1599   5                          stim[index].stopTime = newTime;
 1600   5                          stim[index].status   = statDone;
 1601   5                          execEvent(stim[index].event);
 1602   5                          return 0;                   // exit after executing event
 1603   5                      }
 1604   4                      else
 1605   4                      {
 1606   5                          return 1;
 1607   5                      }
 1608   4                  }
 1609   3                  else
 1610   3                  {
 1611   4                      stim[index].stopTime = newTime;
 1612   4                      execError();
 1613   4                      return 0;
 1614   4                  }
 1615   3              }
 1616   2              else
 1617   2              {                                   // no endtime
 1618   3                  // positive flank, bit must be set
 1619   3                  // negative flank, bit must be cleared
 1620   3                  if (((barEdge == 1) && ((parInp & barBit) >  0)) ||
 1621   3                      ((barEdge == 0) && ((parInp & barBit) == 0)))
 1622   3                  {
 1623   4                          stim[index].stopRef  = 0;
 1624   4                          stim[index].stopTime = newTime;
 1625   4                          stim[index].status   = statDone;
 1626   4                          execEvent(stim[index].event);
 1627   4                          return 0;                   // exit after executing event
 1628   4                  }
 1629   3                  else
 1630   3                  {
 1631   4                      return 1;
 1632   4                  }
 1633   3              }
 1634   2          }
 1635   1      
 1636   1          return 0;
 1637   1      }
 1638          /* *********************************************************************************** */
 1639          int execSky(int index)
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 26  

 1640          {                                                                       
 1641   1          int newTime = Clock_GetTicks() - T_start;
 1642   1          if (stim[index].status == statInit)
 1643   1          {
 1644   2              if ((stim[index].startRef == 0) && (curTime >= stim[index].startTime))
 1645   2                  {
 1646   3                      SkyOnOff(stim[index].posX, stim[index].posY, stim[index].level, ON);
 1647   3                      stim[index].startTime = newTime;
 1648   3                      stim[index].status    = statRun;
 1649   3                      return 1;
 1650   3                  }
 1651   2              
 1652   2              return 2;
 1653   2          }
 1654   1          
 1655   1          if (stim[index].status == statRun)
 1656   1          {
 1657   2              if ((stim[index].stopRef == 0) && (curTime >= stim[index].stopTime))
 1658   2              {
 1659   3                  SkyOnOff(stim[index].posX, stim[index].posY, stim[index].level, OFF);
 1660   3                  stim[index].stopTime = newTime;
 1661   3                  stim[index].status   = statDone;
 1662   3                  execEvent(stim[index].event);
 1663   3                  return 0;
 1664   3              }
 1665   2              return 1;
 1666   2          }
 1667   1          return 0;
 1668   1      }
 1669          /* *********************************************************************************** */
 1670          int execLed(int index)
 1671          { 
 1672   1          int newTime = Clock_GetTicks() - T_start;
 1673   1          if (stim[index].status == statInit)
 1674   1          {
 1675   2              if ((stim[index].startRef == 0) && (curTime >= stim[index].startTime))
 1676   2              {
 1677   3                  LedOnOff(stim[index].posY, stim[index].level, ON);
 1678   3                  stim[index].startTime = newTime;
 1679   3                  stim[index].status = statRun;
 1680   3                  return 1;
 1681   3              }
 1682   2              return 2;
 1683   2          }
 1684   1          
 1685   1          if (stim[index].status == statRun)
 1686   1          {
 1687   2              if ((stim[index].stopRef == 0) && (curTime >= stim[index].stopTime))
 1688   2              {
 1689   3                  LedOnOff(stim[index].posY, stim[index].level, OFF);
 1690   3                  stim[index].stopTime = newTime;
 1691   3                  stim[index].status   = statDone;
 1692   3                  execEvent(stim[index].event);
 1693   3                  return 0;
 1694   3              }
 1695   2              return 1;
 1696   2          }
 1697   1      
 1698   1          return 0;
 1699   1      }
 1700          /* *********************************************************************************** */
 1701          int execRec(int index)
 1702          {
 1703   1          int newTime = Clock_GetTicks() - T_start;
 1704   1      
 1705   1          if (stim[index].status == statInit)
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 27  

 1706   1          {
 1707   2              if ((stim[index].startRef == 0) && (curTime >= stim[index].startTime))
 1708   2              {
 1709   3                  stim[index].startTime = newTime;
 1710   3                  stim[index].status    = statRun;
 1711   3                  SetBitsPar(recBit);   // maak trigger hoog
 1712   3                  parOutp |= recBit;
 1713   3                  return 1;
 1714   3              }
 1715   2              return 2;
 1716   2          }
 1717   1          
 1718   1          if (stim[index].status == statRun)
 1719   1          {
 1720   2              if (curTime > stim[index].startTime+10) // geef circuit tijd om te starten
 1721   2              {
 1722   3                  int parInp  = GetBitsPar();
 1723   3                  if ((parInp & recBit) == 0)         // ready
 1724   3                  {
 1725   4                      parOutp &= ~recBit;             // trigger laag
 1726   4                      ClrBitsPar(recBit);
 1727   4                      stim[index].stopTime = newTime;
 1728   4                      stim[index].status   = statDone;
 1729   4                      execEvent(stim[index].event);
 1730   4                      return 0;
 1731   4                  }
 1732   3              }
 1733   2              if ((stim[index].stopRef == 0) && (curTime >= stim[index].stopTime))
 1734   2              {
 1735   3                  parOutp &= ~recBit;             // trigger laag
 1736   3                  ClrBitsPar(recBit);
 1737   3                  stim[index].stopTime = newTime;
 1738   3                  stim[index].status   = statDone;
 1739   3                  execEvent(stim[index].event);
 1740   3                  return 0;
 1741   3              }
 1742   2              return 1;
 1743   2          }
 1744   1          return 0;
 1745   1      }
 1746          /* *********************************************************************************** */
 1747          int execSnd(int index)
 1748          {
 1749   1          int newTime = Clock_GetTicks() - T_start;
 1750   1      
 1751   1          if (stim[index].status == statInit)
 1752   1          {
 1753   2              if ((stim[index].startRef == 0) && (curTime >= stim[index].startTime))
 1754   2              {
 1755   3                  stim[index].startTime = newTime;
 1756   3                  stim[index].status    = statRun;
 1757   3                  SetBitsPar(sndBit);   
 1758   3                  parOutp |= sndBit;
 1759   3                  return 1;
 1760   3              }
 1761   2              return 2;
 1762   2          }
 1763   1          
 1764   1          if (stim[index].status == statRun)
 1765   1          {
 1766   2              if ((stim[index].stopRef == 0) && (curTime >= stim[index].stopTime))
 1767   2              {
 1768   3                      ClrBitsPar(sndBit);  
 1769   3                      parOutp &= ~sndBit;
 1770   3                      stim[index].stopTime = newTime;
 1771   3                      execError();
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 28  

 1772   3              }
 1773   2              if ((parInp & sndBit) == 0)
 1774   2              {
 1775   3                  if (newTime > (stim[index].startTime+10))
 1776   3                  {
 1777   4                      ClrBitsPar(sndBit);  
 1778   4                      parOutp &= ~sndBit;
 1779   4                      stim[index].stopTime = newTime;
 1780   4                      stim[index].status   = statDone;
 1781   4                      execEvent(stim[index].event);
 1782   4                      return 0;
 1783   4                  }
 1784   3              }
 1785   2              return 1;
 1786   2          }
 1787   1          return 0;
 1788   1      }
 1789          
 1790          void loadNNMod() {
 1791   1          int i, n, pnt;
 1792   1      
 1793   1          pnt = (int) rBuffer[1];
 1794   1          switch (pnt)
 1795   1          {
 1796   2              case 0: NetNum = (int) rBuffer[3];
 1797   2                      NNs[NetNum].active  = 0;
 1798   2                      NNs[NetNum].nInput  = (int) rBuffer[4];
 1799   2                      NNs[NetNum].nHidden = (int) rBuffer[5];
 1800   2                      for (i=0;i<NNs[NetNum].nInput;i++) NNs[NetNum].channels[i] = (int) rBuffer[6+i];
 1801   2                      break;
 1802   2              case 11:for (i=0;i<NNs[NetNum].nHidden;i++) NNs[NetNum].weightsHidden[0][i] = rBuffer[3+i]; 
 1803   2                      break;
 1804   2              case 12:for (i=0;i<NNs[NetNum].nHidden;i++) NNs[NetNum].weightsHidden[1][i] = rBuffer[3+i]; 
 1805   2                      break;
 1806   2              case 13:for (i=0;i<NNs[NetNum].nHidden;i++) NNs[NetNum].weightsHidden[2][i] = rBuffer[3+i]; 
 1807   2                      break;
 1808   2              case 14:for (i=0;i<NNs[NetNum].nHidden;i++) NNs[NetNum].weightsHidden[3][i] = rBuffer[3+i]; 
 1809   2                      break;
 1810   2              case 15:for (i=0;i<NNs[NetNum].nHidden;i++) NNs[NetNum].weightsHidden[4][i] = rBuffer[3+i]; 
 1811   2                      break;
 1812   2              case 16:for (i=0;i<NNs[NetNum].nHidden;i++) NNs[NetNum].weightsHidden[5][i] = rBuffer[3+i]; 
 1813   2                      break;
 1814   2              case 2: for (i=0;i<NNs[NetNum].nHidden;i++) NNs[NetNum].weightsOutput[i]    = rBuffer[3+i]; 
 1815   2                      break;
 1816   2              case 3: for (i=0;i<NNs[NetNum].nHidden;i++) NNs[NetNum].biasHidden[i]       = rBuffer[3+i]; 
 1817   2                      break;
 1818   2              case 4: NNs[NetNum].biasOutput = rBuffer[3];
 1819   2                      n = 4; 
 1820   2                      for (i=0;i<NNs[NetNum].nInput;i++)  NNs[NetNum].scaleInput[i][0]    = rBuffer[n+i];
 1821   2                      n = n + NNs[NetNum].nInput;
 1822   2                      for (i=0;i<NNs[NetNum].nInput;i++)  NNs[NetNum].scaleInput[i][1]    = rBuffer[n+i];
 1823   2                      n = n + NNs[NetNum].nInput;
 1824   2                      NNs[NetNum].scaleOutput[0] = rBuffer[n];
 1825   2                      NNs[NetNum].scaleOutput[1] = rBuffer[n+1];
 1826   2                      NNs[NetNum].active  = 1;
 1827   2                      break;
 1828   2          }
 1829   1          n = sprintf(outBuf,"Loaded net:%d\n",NetNum);
 1830   1          i = UART0_Str(outBuf, n);
 1831   1          nBuffer[1] = 0;
 1832   1      }   
 1833          
 1834          double tansig(double d)
 1835          {
 1836   1          double e = 2.71828;
 1837   1          return (2.0/(1.0+pow(e,-2.0*d))-1.0);
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 29  

 1838   1      }
 1839          
 1840          double simulateNN(int mode)
 1841          {
 1842   1          int i, n, nn, nh, id1=0, id2=0, lp;
 1843   1          double temp, test[6], val, values[4];
 1844   1          double inp[6];
 1845   1          unsigned int t0=Clock_GetTicks();
 1846   1      
 1847   1          int id = mode;
 1848   1          if (mode == -1)id = (int) rBuffer[1];
 1849   1          if (id <  0) {id1 = 0;  id2 = 3;}
 1850   1          if (id > -1) {id1 = id; id2 = id;}
 1851   1          if (id == -1)
 1852   1          {
 1853   2              id1 = 0;
 1854   2              id2 = 3;
 1855   2          }
 1856   1          else
 1857   1          {
 1858   2              id1 = id;
 1859   2              id2 = id;
 1860   2          }
 1861   1      
 1862   1          val = 0;
 1863   1          for (i=0; i<4; i++) values[i] = 0;
 1864   1          for (lp=id1; lp<=id2; lp++)
 1865   1          {
 1866   2              if (NNs[lp].active == 1)
 1867   2              {
 1868   3                  for (nn=0;nn<NNs[lp].nInput;nn++)
 1869   3                  {
 1870   4                      inp[nn]  =  AdcBuffer.data[NNs[lp].channels[nn]-1][0];
 1871   4                      test[nn] =  NNs[lp].scaleInput[nn][0]*inp[nn]+NNs[lp].scaleInput[nn][1];
 1872   4                  }
 1873   3      
 1874   3                  val = 0;
 1875   3                  for (nh=0;nh<NNs[lp].nHidden;nh++)
 1876   3                  {
 1877   4                      temp = 0;
 1878   4                      for (nn=0;nn<NNs[lp].nInput;nn++)
 1879   4                      {
 1880   5                          temp = temp + test[nn]*NNs[lp].weightsHidden[nn][nh];
 1881   5                      }
 1882   4                      val = val + NNs[lp].weightsOutput[nh]*tansig(temp+NNs[lp].biasHidden[nh]);
 1883   4                  }
 1884   3                  val = val + NNs[lp].biasOutput;
 1885   3                  val = NNs[lp].scaleOutput[0]*val+NNs[lp].scaleOutput[1];
 1886   3                  values[lp] = val;
 1887   3              }
 1888   2              else
 1889   2              {
 1890   3                  val = 0;
 1891   3                  values[lp] = val;
 1892   3              }
 1893   2          }
 1894   1          if (mode > -1)
 1895   1          {
 1896   2              return val;
 1897   2          }
 1898   1          t0= Clock_GetTicks() - t0;
 1899   1          n = sprintf(outBuf,"%d ",t0); 
 1900   1          if (id > -1)
 1901   1          {
 1902   2              for (i=0;i<NNs[id].nInput;i++)
 1903   2              {
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 30  

 1904   3                  n += sprintf(outBuf+n," %f",inp[i]);
 1905   3              }
 1906   2              n += sprintf(outBuf+n," %f\n",val);
 1907   2          }
 1908   1          else
 1909   1          {
 1910   2              for (i=0;i<3;i++)
 1911   2              {
 1912   3                  n += sprintf(outBuf+n," %f",values[i]);
 1913   3              }
 1914   2              n += sprintf(outBuf+n," %f\n",values[3]);
 1915   2          }
 1916   1      
 1917   1          i = UART0_Str(outBuf, n);
 1918   1          nBuffer[1] = 0;
 1919   1          return 0;
 1920   1      }
 1921          
 1922          int execFixWnd(int index)
 1923          {
 1924   1          int newTime = Clock_GetTicks() - T_start;
 1925   1          int id = stim[index].index;
 1926   1      
 1927   1          if (stim[index].status == statInit)
 1928   1          {
 1929   2              if ((stim[index].startRef == 0) && (curTime >= stim[index].startTime))
 1930   2              {
 1931   3                  testFixWnd(index);
 1932   3                  stim[index].startTime = newTime;
 1933   3                  stim[index].status    = statRun;
 1934   3                  return 1;
 1935   3              }
 1936   2              fixWindows[id].fix = 0;
 1937   2              return 2;
 1938   2          }
 1939   1      
 1940   1          if (stim[index].status == statRun)
 1941   1          {
 1942   2              if ((stim[index].stopRef == 0) && (curTime >= stim[index].stopTime))
 1943   2              {
 1944   3                  stim[index].stopTime = newTime;
 1945   3                  stim[index].delay    = fixWindows[id].time;
 1946   3                  execError();
 1947   3                  return 0;
 1948   3              }
 1949   2              else
 1950   2              {
 1951   3                  if (testFixWnd(index) == 1)
 1952   3                  {
 1953   4                      stim[index].stopTime = newTime;
 1954   4                      stim[index].status   = statDone;
 1955   4                      stim[index].delay    = fixWindows[id].time;
 1956   4                      execEvent(stim[index].event);
 1957   4                      return 0;
 1958   4                  }
 1959   3                  return 1;
 1960   3              }
 1961   2          }
 1962   1          return 0;
 1963   1      }
 1964          
 1965          int testFixWnd(int index)
 1966          {
 1967   1          int n;
 1968   1      
 1969   1          int time;
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 31  

 1970   1          double Xm    = (double) stim[index].posX;
 1971   1          double Ym    = (double) stim[index].posY;
 1972   1          double Sx    = (double) stim[index].winX;
 1973   1          double Sy    = (double) stim[index].winY;
 1974   1          int id    = stim[index].index;
 1975   1          int fix   = fixWindows[id].fix;
 1976   1          int t0    = fixWindows[id].t0;
 1977   1          int nx    = fixWindows[id].Xnet;
 1978   1          int ny    = fixWindows[id].Ynet;
 1979   1          double Xh = (double) fixWindows[id].Xh/10.0;  // to use integers, the value
 1980   1          double Yh = (double) fixWindows[id].Yh/10.0;  // was multiplied by 10
 1981   1          double x  = simulateNN(nx);
 1982   1          double y  = simulateNN(ny);
 1983   1       
 1984   1          if (fix == 1)
 1985   1          {
 1986   2              if ((x > (Xm-Sx-Xh)) && (x < (Xm+Sx+Xh)) &&
 1987   2                  (y > (Ym-Sy-Yh)) && (y < (Ym+Sy+Yh)))
 1988   2              {
 1989   3                  time = curTime-t0;
 1990   3              }
 1991   2              else
 1992   2              {
 1993   3                  time = 0;
 1994   3                  fix  = 0;
 1995   3              }
 1996   2          }
 1997   1          else
 1998   1          {
 1999   2              time = 0;
 2000   2              if ((x > (Xm-Sx+Xh)) && (x < (Xm+Sx-Xh)) &&
 2001   2                  (y > (Ym-Sy+Yh)) && (y < (Ym+Sy-Yh)))
 2002   2                  {
 2003   3                      fixWindows[id].t0 = curTime;
 2004   3                      fix  = 1;
 2005   3                  }
 2006   2          }
 2007   1      
 2008   1          if (time > fixWindows[id].time)
 2009   1              fixWindows[id].time = time;
 2010   1          fixWindows[id].fix  = fix;
 2011   1      
 2012   1          if (time > stim[index].delay) n = 1; else n = 0;
 2013   1          return n;
 2014   1      }
 2015          /****************************************************************************
 2016          Procedure "execSpeed" is left after:
 2017          1/ The stop time is exceeded.
 2018          2/ The desired speed is reached.
 2019          
 2020          Procedure:
 2021          1/ The average of 10 samples is taken for the AD values,
 2022             (For 8 channels, this gives a sample rate of 5 kHz.),
 2023          2/ A new calculation is started every mSec:
 2024              a/ Netwerk is used for the calculation of the X and Y position 
 2025                 (position in degrees NNx, NNy).
 2026          *****************************************************************************/
 2027          double X[5], Y[5];
 2028          double range[11];
 2029          int execSpeed(int index)
 2030          {
 2031   1          int i, nx, ny;
 2032   1          int newTime = Clock_GetTicks() - T_start;
 2033   1          double NNx, NNy, d1, d2;
 2034   1      
 2035   1          if (stim[index].status == statInit)
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 32  

 2036   1          {
 2037   2              if ((stim[index].startRef == 0) && (curTime >= stim[index].startTime))
 2038   2              {
 2039   3                  stim[index].startTime = newTime;
 2040   3                  stim[index].status    = statRun;
 2041   3                  pntNN = 0;
 2042   3                  speed[0] = 0;
 2043   3                  speed[1] = 0;
 2044   3                  return 1;
 2045   3              }
 2046   2              return 2;
 2047   2          }
 2048   1      
 2049   1          if (stim[index].status == statRun)
 2050   1          {
 2051   2              if ((stim[index].stopRef == 0) && (curTime >= stim[index].stopTime))
 2052   2              {
 2053   3                  stim[index].stopTime = newTime;
 2054   3                  execError();
 2055   3                  return 0;
 2056   3              }
 2057   2              nx = stim[index].mode & 3;
 2058   2              ny = ((stim[index].mode & 12) >> 2);
 2059   2              X[pntNN] = Clock_GetTicks() - T_start;
 2060   2              NNx = simulateNN(nx)-stim[index].posX;
 2061   2              NNy = simulateNN(ny)-stim[index].posY;
 2062   2              NNy = 0;
 2063   2              Y[pntNN] = NNx*NNx+NNy*NNy;
 2064   2              if (Y[pntNN] > 0) Y[pntNN] = sqrt(Y[pntNN]);
 2065   2              pntNN++;
 2066   2              if (pntNN == 5)
 2067   2              {
 2068   3                  calculateSpeed();
 2069   3                  pntNN = 4;
 2070   3                  range[0] = X[0]-X[0];
 2071   3                  range[1] = X[1]-X[0];
 2072   3                  range[2] = X[2]-X[0];
 2073   3                  range[3] = X[3]-X[0];
 2074   3                  range[4] = X[4]-X[0];
 2075   3                  range[5] = Y[0];
 2076   3                  range[6] = Y[1];
 2077   3                  range[7] = Y[2];
 2078   3                  range[8] = Y[3];
 2079   3                  range[9] = Y[4];
 2080   3                  range[10] = X[4]-X[0];
 2081   3                  for (i=1; i<5; i++)
 2082   3                  {
 2083   4                      X[i-1] = X[i];
 2084   4                      Y[i-1] = Y[i];
 2085   4                  }
 2086   3              }
 2087   2              d1 = 1000.0*speed[0]/range[10];
 2088   2              range[10] = d1;
 2089   2              d2 = stim[index].level;
 2090   2              if (d1 < d2)
 2091   2              {
 2092   3                  stim[index].stopTime = newTime;
 2093   3                  stim[index].status   = statDone;
 2094   3                  execEvent(stim[index].event);
 2095   3                  return 0;
 2096   3              }
 2097   2              return 1;
 2098   2          }
 2099   1      
 2100   1          return 0;
 2101   1      }
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 33  

 2102          
 2103          void calculateSpeed(void)
 2104          {
 2105   1          double slope;
 2106   1          double X1[5], sumX, sumY, sumXY, sumXX, meanX, meanY;
 2107   1          int    n;
 2108   1          // FIT
 2109   1          sumX = 0; sumY = 0; sumXY = 0; sumXX = 0;
 2110   1          for (n=0;n<5;n++) 
 2111   1          {
 2112   2              X1[n] = X[n] - X[0];
 2113   2          }
 2114   1          X1[0] = 0;
 2115   1          for (n=0;n<5;n++)
 2116   1          {
 2117   2              sumX  = sumX  + X1[n];
 2118   2              sumY  = sumY  + Y[n]; 
 2119   2              sumXY = sumXY + X1[n]*Y[n];
 2120   2              sumXX = sumXX + X1[n]*X1[n];
 2121   2              meanX = sumX/5.0;
 2122   2              meanY = sumY/5.0;
 2123   2          }                               
 2124   1          slope = (5.0*sumXY-sumX*sumY)/(5.0*sumXX-sumX*sumX);
 2125   1          speed[0] = slope;
 2126   1          speed[1] = meanY -(slope*meanX);
 2127   1          // FIT                
 2128   1      }
 2129          
 2130          void getSpeed()
 2131          {
 2132   1          int i, n;
 2133   1          double slope, offset;
 2134   1      
 2135   1          slope  = speed[0];
 2136   1          offset = speed[1];
 2137   1      
 2138   1          n = sprintf(outBuf,"%f %f %f %f %f %f %f %f %f %f %f %f %f\n",slope,offset,range[0],range[1],range[2],ra
             -nge[3],range[4],range[5],range[6],range[7],range[8],range[9],range[10]);
 2139   1          i = UART0_Str(outBuf, n);
 2140   1          nBuffer[1] = 0;
 2141   1      }
 2142          
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 34  

ASSEMBLY LISTING OF GENERATED OBJECT CODE



*** EXTERNALS:
 EXTERN CODE16 (sprintf?T)
 EXTERN CODE16 (sscanf?T)
 EXTERN CODE16 (sqrt?T)
 EXTERN CODE16 (pow?T)
 EXTERN CODE16 (LPCinit?T)
 EXTERN CODE16 (Clock_Init?T)
 EXTERN CODE16 (Clock_GetTicks?T)
 EXTERN CODE16 (Clock_GetSeconds?T)
 EXTERN CODE16 (Clock_Reset?T)
 EXTERN CODE16 (Clock_GetCountWait?T)
 EXTERN CODE16 (Clock_ClrCountWait?T)
 EXTERN CODE16 (UART0_Init?T)
 EXTERN CODE16 (UART0_RxNumber?T)
 EXTERN CODE16 (UART0_Get?T)
 EXTERN CODE16 (UART0_Str?T)
 EXTERN CODE16 (I2C_Init?T)
 EXTERN CODE16 (I2C_SendByte?T)
 EXTERN CODE32 (?C?FCAST?A)
 EXTERN CODE32 (?C?FPSUB?A)
 EXTERN CODE32 (?C?FPDIV?A)
 EXTERN CODE32 (?C?FPADD?A)
 EXTERN NUMBER (__startup)
 EXTERN CODE16 (?C?SDIV?T)
 EXTERN CODE16 (?C?FCAST?T)
 EXTERN CODE16 (?C?CASTF?T)
 EXTERN CODE16 (?C?FPMUL?T)
 EXTERN CODE16 (?C?FPADD?T)
 EXTERN CODE16 (?C?FPDIV?T)
 EXTERN CODE16 (?C?FPSUB?T)
 EXTERN CODE16 (?C?FPCMP?T)
 EXTERN CODE16 (?C?FCASTU?T)



*** PUBLICS:
 PUBLIC         ADC_irq?A
 PUBLIC         AdcNext?T
 PUBLIC         AdcNext?A
 PUBLIC         ADC_Init?T
 PUBLIC         Delay?T
 PUBLIC         InitAll?T
 PUBLIC         splitInput?T
 PUBLIC         getWord?T
 PUBLIC         getVal?T
 PUBLIC         execStim?T
 PUBLIC         ClearSky?T
 PUBLIC         ClearArc?T
 PUBLIC         LedOnOff?T
 PUBLIC         SkyOnOff?T
 PUBLIC         getPIO?T
 PUBLIC         SetBitsPar?T
 PUBLIC         ClrBitsPar?T
 PUBLIC         ClrAllBitsPar?T
 PUBLIC         GetBitsPar?T
 PUBLIC         TstBitPar?T
 PUBLIC         WaitForEnter?T
 PUBLIC         execInit?T
 PUBLIC         execResults?T
 PUBLIC         execEvent?T
 PUBLIC         execBarFlank?T
 PUBLIC         execBarLevel?T
 PUBLIC         execBarCheck?T
 PUBLIC         execBar?T
 PUBLIC         execSky?T
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 35  

 PUBLIC         execLed?T
 PUBLIC         execRec?T
 PUBLIC         execRew?T
 PUBLIC         execLas?T
 PUBLIC         execSnd?T
 PUBLIC         execFixWnd?T
 PUBLIC         execSpeed?T
 PUBLIC         calculateSpeed?T
 PUBLIC         execError?T
 PUBLIC         getInfo?T
 PUBLIC         getState?T
 PUBLIC         getStateTrial?T
 PUBLIC         getClock?T
 PUBLIC         getTime?T
 PUBLIC         clrTime?T
 PUBLIC         execReset?T
 PUBLIC         execAbort?T
 PUBLIC         execNextTrial?T
 PUBLIC         execStartTrial?T
 PUBLIC         execSaveTrial?T
 PUBLIC         getBarState?T
 PUBLIC         getADC?T
 PUBLIC         getSpeed?T
 PUBLIC         selectADC?T
 PUBLIC         softReset?T
 PUBLIC         setSpeaker?T
 PUBLIC         loadNNMod?T
 PUBLIC         tansig?T
 PUBLIC         simulateNN?T
 PUBLIC         setFixWindow?T
 PUBLIC         testFixWnd?T
 PUBLIC         main
 PUBLIC         execTime?T
 PUBLIC         version
 PUBLIC         AdcBuffer
 PUBLIC         AdcActive
 PUBLIC         inBuf
 PUBLIC         outBuf
 PUBLIC         inpPnt
 PUBLIC         outPnt
 PUBLIC         nBuffer
 PUBLIC         rBuffer
 PUBLIC         wrd
 PUBLIC         startTime
 PUBLIC         curTime
 PUBLIC         ITI
 PUBLIC         errFlag
 PUBLIC         errTime
 PUBLIC         stim
 PUBLIC         nStim
 PUBLIC         NNs
 PUBLIC         NetNum
 PUBLIC         fixWindows
 PUBLIC         speed
 PUBLIC         pntNN
 PUBLIC         seconds
 PUBLIC         ticks
 PUBLIC         MCS
 PUBLIC         Leds
 PUBLIC         Sky
 PUBLIC         boards
 PUBLIC         speakers
 PUBLIC         gain1
 PUBLIC         gain2
 PUBLIC         statusBoards
 PUBLIC         parInp
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 36  

 PUBLIC         parOutp
 PUBLIC         recBit
 PUBLIC         rewBit
 PUBLIC         sndBit
 PUBLIC         lasBit
 PUBLIC         state
 PUBLIC         T_trial
 PUBLIC         T_ITI
 PUBLIC         T_start
 PUBLIC         T_done
 PUBLIC         X
 PUBLIC         Y
 PUBLIC         range



*** DATA SEGMENT '?CON?Fart':
 00000000          ?tpl?0004:
 00000000           BEGIN_INIT
 00000000  00000010  DD          0x10
 00000004  0000000F  DD          0xF
 00000008  0000000E  DD          0xE
 0000000C  0000000D  DD          0xD
 00000010  0000000C  DD          0xC
 00000014  0000000B  DD          0xB
 00000018  0000000A  DD          0xA
 0000001C  00000009  DD          0x9
 00000020  00000008  DD          0x8
 00000024  00000007  DD          0x7
 00000028  00000006  DD          0x6
 0000002C  00000005  DD          0x5
 00000030  00000004  DD          0x4
 00000034  00000003  DD          0x3
 00000038  00000002  DD          0x2
 0000003C  00000001  DD          0x1
 00000040  00000020  DD          0x20
 00000044  0000001F  DD          0x1F
 00000048  0000001E  DD          0x1E
 0000004C  0000001D  DD          0x1D
 00000050  0000001C  DD          0x1C
 00000054  0000001B  DD          0x1B
 00000058  0000001A  DD          0x1A
 0000005C  00000019  DD          0x19
 00000060  00000018  DD          0x18
 00000064  00000017  DD          0x17
 00000068  00000016  DD          0x16
 0000006C  00000015  DD          0x15
 00000070  00000014  DD          0x14
 00000074  00000013  DD          0x13
 00000078  00000012  DD          0x12
 0000007C  00000011  DD          0x11
 00000080           END_INIT
 00000080          ??S_16:
 00000080            DB          '%f %f %f %f %f %f %f %f %f %f %f %f %f'
 000000A6            DB          0x0A,0x00
 000000A8          ??S_15:
 000000A8            DB          ' %f',0x0A,0x00
 000000AD          ??S_14:
 000000AD            DB          ' %f',0x00
 000000B1          ??S_13:
 000000B1            DB          '%d ',0x00
 000000B5          ??S_12:
 000000B5            DB          'Loaded net:%d',0x0A,0x00
 000000C4          ??S_11:
 000000C4            DB          '%f %f %f %f %f %f %f %f %f %f %f %f %f'
 000000EA            DB          ' %f %f %f %f %f %f %f %f %f %f %f %f',0x00
 0000010F          ??S_10:
 0000010F            DB          '%d %f %f %f %f %f %f %f %f',0x0A,0x00
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 37  

 0000012B          ??S_9:
 0000012B            DB          '%d %d %d',0x0A,0x00
 00000135          ??S_8:
 00000135            DB          '-998',0x0A,0x00
 0000013B          ??S_7:
 0000013B            DB          '%d %d %d %d',0x0A,0x00
 00000148          ??S_6:
 00000148            DB          '%d;%d',0x0A,0x00
 0000014F          ??S_5:
 0000014F            DB          '%d',0x0A,0x00
 00000153            ALIGN       4
 00000154          ?tpl?0001:
 00000154           BEGIN_INIT
 00000154            DB          0x0A,0x00
 00000156           END_INIT
 00000156            ALIGN       4
 00000158          ?tpl?0002:
 00000158           BEGIN_INIT
 00000158            DB          ' ',0x00
 0000015A           END_INIT
 0000015A            ALIGN       4
 0000015C          ?tpl?0003:
 0000015C           BEGIN_INIT
 0000015C            DB          '0123456789',0x00
 00000167           END_INIT

*** DATA SEGMENT '?DT0?Fart':
 00000000          AdcBuffer:
 00000000            DS          384
 00000180          AdcActive:
 00000180            DS          4
 00000184          inpPnt:
 00000184            DS          4
 00000188          outPnt:
 00000188            DS          4
 0000018C          nBuffer:
 0000018C            DS          100
 000001F0          rBuffer:
 000001F0            DS          100
 00000254          startTime:
 00000254            DS          4
 00000258          curTime:
 00000258            DS          4
 0000025C          ITI:
 0000025C           BEGIN_INIT
 0000025C  00000000  DD          0x0
 00000260           END_INIT
 00000260          errFlag:
 00000260           BEGIN_INIT
 00000260  00000000  DD          0x0
 00000264           END_INIT
 00000264          errTime:
 00000264           BEGIN_INIT
 00000264  00000000  DD          0x0
 00000268           END_INIT
 00000268          stim:
 00000268            DS          3040
 00000E48          nStim:
 00000E48           BEGIN_INIT
 00000E48  00000000  DD          0x0
 00000E4C           END_INIT
 00000E4C          NNs:
 00000E4C            DS          2960
 000019DC          NetNum:
 000019DC            DS          4
 000019E0          fixWindows:
 000019E0            DS          280
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 38  

 00001AF8          speed:
 00001AF8            DS          8
 00001B00          pntNN:
 00001B00            DS          4
 00001B04          seconds:
 00001B04           BEGIN_INIT
 00001B04  00000000  DD          0x0
 00001B08           END_INIT
 00001B08          ticks:
 00001B08           BEGIN_INIT
 00001B08  00000000  DD          0x0
 00001B0C           END_INIT
 00001B0C          MCS:
 00001B0C           BEGIN_INIT
 00001B0C  00000001  DD          0x1
 00001B10           END_INIT
 00001B10          Leds:
 00001B10            DS          192
 00001BD0          Sky:
 00001BD0            DS          156
 00001C6C          boards:
 00001C6C           BEGIN_INIT
 00001C6C  000000F7  DD          0xF7
 00001C70  000000FB  DD          0xFB
 00001C74  000000FD  DD          0xFD
 00001C78  000000FE  DD          0xFE
 00001C7C  0000007F  DD          0x7F
 00001C80  000000BF  DD          0xBF
 00001C84  000000DF  DD          0xDF
 00001C88  000000EF  DD          0xEF
 00001C8C           END_INIT
 00001C8C          speakers:
 00001C8C           BEGIN_INIT
 00001C8C  00000080  DD          0x80
 00001C90  00000040  DD          0x40
 00001C94  00000020  DD          0x20
 00001C98  00000010  DD          0x10
 00001C9C  00000008  DD          0x8
 00001CA0  00000004  DD          0x4
 00001CA4  00000002  DD          0x2
 00001CA8  00000001  DD          0x1
 00001CAC           END_INIT
 00001CAC          gain1:
 00001CAC           BEGIN_INIT
 00001CAC  0000007F  DD          0x7F
 00001CB0  000000DF  DD          0xDF
 00001CB4  000000F7  DD          0xF7
 00001CB8  000000FD  DD          0xFD
 00001CBC  0000007F  DD          0x7F
 00001CC0  000000DF  DD          0xDF
 00001CC4  000000F7  DD          0xF7
 00001CC8  000000FD  DD          0xFD
 00001CCC           END_INIT
 00001CCC          gain2:
 00001CCC           BEGIN_INIT
 00001CCC  000000BF  DD          0xBF
 00001CD0  000000EF  DD          0xEF
 00001CD4  000000FB  DD          0xFB
 00001CD8  000000FE  DD          0xFE
 00001CDC  000000BF  DD          0xBF
 00001CE0  000000EF  DD          0xEF
 00001CE4  000000FB  DD          0xFB
 00001CE8  000000FE  DD          0xFE
 00001CEC           END_INIT
 00001CEC          statusBoards:
 00001CEC            DS          96
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 39  

 00001D4C          parInp:
 00001D4C           BEGIN_INIT
 00001D4C  00000000  DD          0x0
 00001D50           END_INIT
 00001D50          parOutp:
 00001D50           BEGIN_INIT
 00001D50  00000000  DD          0x0
 00001D54           END_INIT
 00001D54          recBit:
 00001D54           BEGIN_INIT
 00001D54  00000000  DD          0x0
 00001D58           END_INIT
 00001D58          rewBit:
 00001D58           BEGIN_INIT
 00001D58  00000000  DD          0x0
 00001D5C           END_INIT
 00001D5C          sndBit:
 00001D5C           BEGIN_INIT
 00001D5C  00000000  DD          0x0
 00001D60           END_INIT
 00001D60          lasBit:
 00001D60           BEGIN_INIT
 00001D60  00000000  DD          0x0
 00001D64           END_INIT
 00001D64          T_trial:
 00001D64           BEGIN_INIT
 00001D64  00000000  DD          0x0
 00001D68           END_INIT
 00001D68          T_ITI:
 00001D68           BEGIN_INIT
 00001D68  00000000  DD          0x0
 00001D6C           END_INIT
 00001D6C          T_start:
 00001D6C           BEGIN_INIT
 00001D6C  00000000  DD          0x0
 00001D70           END_INIT
 00001D70          T_done:
 00001D70           BEGIN_INIT
 00001D70  00000000  DD          0x0
 00001D74           END_INIT
 00001D74          X:
 00001D74            DS          20
 00001D88          Y:
 00001D88            DS          20
 00001D9C          range:
 00001D9C            DS          44
 00001DC8          version:
 00001DC8           BEGIN_INIT
 00001DC8            DB          'LPC2119->Fart2 1.11 08-Apr-2010',0x0A
 00001DE8            DB          0x00
 00001DE9           END_INIT
 00001DE9          inBuf:
 00001DE9            DS          128
 00001E69          outBuf:
 00001E69            DS          128
 00001EE9          wrd:
 00001EE9            DS          10
 00001EF3          state:
 00001EF3            DS          80



*** CODE SEGMENT '?PR?ADC_Init?T?Fart':
  107: void ADC_Init(void)
 00000000  B410      PUSH        {R4}
  108: {    // Clock AD converter has to be less than 4.5 MHz.  (50 Mhz / (CLKDIV+1))  
 00000002            ; SCOPE-START
  117:     for(i=0; i<8; i++)
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 40  

 00000002  2000      MOV         R0,#0x0
 00000004  ---- Variable 'i' assigned to Register 'R0' ----
  119:         for (n=0; n<11; n++)
 00000004          L_10:
 00000004  2100      MOV         R1,#0x0
 00000006  ---- Variable 'n' assigned to Register 'R1' ----
 00000006          L_9:
  121:             AdcBuffer.data[i][n] = 0;
 00000006  2200      MOV         R2,#0x0
 00000008  008B      LSL         R3,R1,#0x2 ; n
 0000000A  242C      MOV         R4,#0x2C
 0000000C  4344      MUL         R4,R0 ; i
 0000000E  18E4      ADD         R4,R3 ; i
 00000010  4800      LDR         R3,=AdcBuffer ; AdcBuffer
 00000012  511A      STR         R2,[R3,R4]
  122:         }
 00000014  3101      ADD         R1,#0x1
 00000016  290B      CMP         R1,#0xB ; n
 00000018  DBF5      BLT         L_9  ; T=0x00000006
  123:     }
 0000001A  3001      ADD         R0,#0x1
 0000001C  2808      CMP         R0,#0x8 ; i
 0000001E  DBF1      BLT         L_10  ; T=0x00000004
  125:     AdcActive = 0;
 00000020  2100      MOV         R1,#0x0
 00000022  4800      LDR         R0,=AdcActive ; AdcActive
 00000024  6001      STR         R1,[R0,#0x0] ; AdcActive
  126:     channel = (1 << AdcActive);
 00000026  4800      LDR         R0,=AdcActive ; AdcActive
 00000028  6800      LDR         R0,[R0,#0x0] ; AdcActive
 0000002A  2101      MOV         R1,#0x1
 0000002C  4081      LSL         R1,R0
 0000002E  ---- Variable 'channel' assigned to Register 'R1' ----
  127:     PINSEL1 |= 0x55 << 22;              // channels 0,1,2,3
 0000002E  4800      LDR         R3,=0x15400000
 00000030  4800      LDR         R0,=0xE002C004
 00000032  6802      LDR         R2,[R0,#0x0]
 00000034  431A      ORR         R2,R3
 00000036  6002      STR         R2,[R0,#0x0]
  128:     ADCR = channel;
 00000038  4800      LDR         R0,=0xE0034000
 0000003A  6001      STR         R1,[R0,#0x0]
  129:     ADCR |= ((0xFF << 8) | (1 << 21)); 
 0000003C  4800      LDR         R2,=0x20FF00
 0000003E  4800      LDR         R0,=0xE0034000
 00000040  6801      LDR         R1,[R0,#0x0]
 00000042  4311      ORR         R1,R2
 00000044  6001      STR         R1,[R0,#0x0]
  131:     VICVectAddr3 = (unsigned long)ADC_irq;
 00000046  4900      LDR         R1,=ADC_irq?A ; ADC_irq?A
 00000048  4800      LDR         R0,=0xFFFFF10C
 0000004A  6001      STR         R1,[R0,#0x0]
  132:     VICVectCntl3 = 0x20 | 18;       // ADC interrupt (irq enable + number of interrupt)
 0000004C  2132      MOV         R1,#0x32
 0000004E  4800      LDR         R0,=0xFFFFF20C
 00000050  6001      STR         R1,[R0,#0x0]
  133:     VICIntEnable = 1 << 18;         // Enable ADC interrupt
 00000052  4800      LDR         R1,=0x40000
 00000054  4800      LDR         R0,=0xFFFFF010
 00000056  6001      STR         R1,[R0,#0x0]
  135:     ADCR |= (0x001 << 24);
 00000058  4800      LDR         R2,=0x1000000
 0000005A  4800      LDR         R0,=0xE0034000
 0000005C  6801      LDR         R1,[R0,#0x0]
 0000005E  4311      ORR         R1,R2
 00000060  6001      STR         R1,[R0,#0x0]
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 41  

 00000062            ; SCOPE-END
  136: }
 00000062  BC10      POP         {R4}
 00000064  4770      BX          R14
 00000066          ENDP ; 'ADC_Init?T'


*** CODE SEGMENT '?PR?ADC_irq?A?Fart':
  138: void ADC_irq(void) __irq
 00000000  E92D5F7F  STMDB       R13!,{R0-R6,R8-R12,LR}
  139: {
 00000004            ; SCOPE-START
  143:     val  = ((ADDR >>  6) & 0x03FF);     // Get result
 00000004  E5100000  LDR         R0,=0xE0034004
 00000008  E5900000  LDR         R0,[R0,#0x0]
 0000000C  E1A00320  MOV         R0,R0,LSR #6
 00000010  E5101000  LDR         R1,=0x3FF
 00000014  E0000001  AND         R0,R0,R1
 00000018  ---- Variable 'val' assigned to Register 'R0' ----
  144:     chan = ((ADDR >> 24) & 0x0003);     // and channel
 00000018  E5101000  LDR         R1,=0xE0034004
 0000001C  E5914000  LDR         R4,[R1,#0x0]
 00000020  E1A04C24  MOV         R4,R4,LSR #24
 00000024  E2044003  AND         R4,R4,#0x0003
 00000028  ---- Variable 'chan' assigned to Register 'R4' ----
  145:     chan = chan | (AdcActive & 0x04);   // add group (multiplexer)
 00000028  E5101000  LDR         R1,=AdcActive ; AdcActive
 0000002C  E5911000  LDR         R1,[R1,#0x0] ; AdcActive
 00000030  E2011004  AND         R1,R1,#0x0004
 00000034  E1844001  ORR         R4,R4,R1 ; chan
  146:     dVal = val;
 00000038  EBFFFFF0  BL          ?C?FCAST?A  ; Targ=0x0 ; ?C?FCAST?A
 0000003C  E1A03000  MOV         R3,R0 ; dVal
 00000040  ---- Variable 'dVal' assigned to Register 'R3' ----
  151:         dVal = (dVal-559.0)/447;
 00000040  E5101000  LDR         R1,=0x440BC000
 00000044  E1A00003  MOV         R0,R3 ; dVal
 00000048  EBFFFFEC  BL          ?C?FPSUB?A  ; Targ=0x0 ; ?C?FPSUB?A
 0000004C  E5101000  LDR         R1,=0x43DF8000
 00000050  EBFFFFEA  BL          ?C?FPDIV?A  ; Targ=0x0 ; ?C?FPDIV?A
 00000054  E1A03000  MOV         R3,R0 ; dVal
  154:     for (i=1; i<10; i++)
 00000058  E3A05001  MOV         R5,#0x1
 0000005C  ---- Variable 'i' assigned to Register 'R5' ----
 0000005C          L_14:
  156:         AdcBuffer.data[chan][i] = AdcBuffer.data[chan][i+1];
 0000005C  E1A06105  MOV         R6,R5,LSL #2 ; i
 00000060  E3A0102C  MOV         R1,#0x2C
 00000064  E0010194  MUL         R1,R4,R1 ; chan
 00000068  E0816006  ADD         R6,R1,R6 ; chan
 0000006C  E5100000  LDR         R0,=AdcBuffer + 0x4 ; AdcBuffer+4
 00000070  E7900006  LDR         R0,[R0,+R6]
 00000074  E5102000  LDR         R2,=AdcBuffer ; AdcBuffer
 00000078  E7820006  STR         R0,[R2,+R6]
  157:     }
 0000007C  E2855001  ADD         R5,R5,#0x0001 ; i
 00000080  E355000A  CMP         R5,#0x000A ; i
 00000084  BAFFFFF4  BLT         L_14  ; Targ=0x5C
  158:     AdcBuffer.data[chan][10] = dVal;
 00000088  E5100000  LDR         R0,=AdcBuffer + 0x28 ; AdcBuffer+40
 0000008C  E7803001  STR         R3,[R0,+R1] ; dVal
  160:     dVal = 0;
 00000090  E3A03000  MOV         R3,#0x0
  161:     for (i=1; i<11; i++)
 00000094  E3A05001  MOV         R5,#0x1
 00000098          L_19:
  163:         dVal += AdcBuffer.data[chan][i];    
 00000098  E1A01105  MOV         R1,R5,LSL #2 ; i
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 42  

 0000009C  E3A0202C  MOV         R2,#0x2C
 000000A0  E0020294  MUL         R2,R4,R2 ; chan
 000000A4  E0821001  ADD         R1,R2,R1 ; chan
 000000A8  E5100000  LDR         R0,=AdcBuffer ; AdcBuffer
 000000AC  E7901001  LDR         R1,[R0,+R1]
 000000B0  E1A00003  MOV         R0,R3 ; dVal
 000000B4  EBFFFFD1  BL          ?C?FPADD?A  ; Targ=0x0 ; ?C?FPADD?A
 000000B8  E1A03000  MOV         R3,R0 ; dVal
  164:     }
 000000BC  E2855001  ADD         R5,R5,#0x0001 ; i
 000000C0  E355000B  CMP         R5,#0x000B ; i
 000000C4  BAFFFFF3  BLT         L_19  ; Targ=0x98
  165:     AdcBuffer.data[chan][0] = dVal/10.0;
 000000C8  E5101000  LDR         R1,=0x41200000
 000000CC  E1A00003  MOV         R0,R3 ; dVal
 000000D0  EBFFFFCA  BL          ?C?FPDIV?A  ; Targ=0x0 ; ?C?FPDIV?A
 000000D4  E5101000  LDR         R1,=AdcBuffer ; AdcBuffer
 000000D8  E7810002  STR         R0,[R1,+R2]
  166:     AdcActive = AdcNext(AdcActive);
 000000DC  E5100000  LDR         R0,=AdcActive ; AdcActive
 000000E0  E5900000  LDR         R0,[R0,#0x0] ; AdcActive
 000000E4  EBFFFFC5  BL          AdcNext?A  ; Targ=0x0
 000000E8  E5101000  LDR         R1,=AdcActive ; AdcActive
 000000EC  E5810000  STR         R0,[R1,#0x0] ; AdcActive
  167:     if ((AdcActive & 0x04) > 0)             // select group
 000000F0  E5100000  LDR         R0,=AdcActive ; AdcActive
 000000F4  E5900000  LDR         R0,[R0,#0x0] ; AdcActive
 000000F8  E2001004  AND         R1,R0,#0x0004
 000000FC  E3510000  CMP         R1,#0x0000
 00000100  DA000003  BLE         L_21  ; Targ=0x114
  168:         IOCLR0 = 0x8000;
 00000104  E3A02902  MOV         R2,#0x8000
 00000108  E5101000  LDR         R1,=0xE002800C
 0000010C  E5812000  STR         R2,[R1,#0x0]
 00000110  EA000002  B           L_22  ; Targ=0x120
 00000114          L_21:
  170:         IOSET0 = 0x8000;
 00000114  E3A02902  MOV         R2,#0x8000
 00000118  E5101000  LDR         R1,=0xE0028004
 0000011C  E5812000  STR         R2,[R1,#0x0]
 00000120          L_22:
  171:     chan = (1 << (AdcActive & 0x03));       // remove group select
 00000120  E2000003  AND         R0,R0,#0x0003
 00000124  E3A04001  MOV         R4,#0x1
 00000128  E1A04014  MOV         R4,R4,LSL R0
  173:       VICVectAddr = 3;                      // Acknowledge interrupt
 0000012C  E3A01003  MOV         R1,#0x3
 00000130  E5100000  LDR         R0,=0xFFFFF030
 00000134  E5801000  STR         R1,[R0,#0x0]
  175:     ADCR &= ~0xF;
 00000138  E5100000  LDR         R0,=0xE0034000
 0000013C  E5901000  LDR         R1,[R0,#0x0]
 00000140  E3C1100F  BIC         R1,R1,#0x000F
 00000144  E5801000  STR         R1,[R0,#0x0]
  176:     ADCR |= chan;
 00000148  E1A02004  MOV         R2,R4 ; chan
 0000014C  E5100000  LDR         R0,=0xE0034000
 00000150  E5901000  LDR         R1,[R0,#0x0]
 00000154  E1811002  ORR         R1,R1,R2 ; chan
 00000158  E5801000  STR         R1,[R0,#0x0]
  177:     ADCR |= (0x001 << 24);
 0000015C  E5100000  LDR         R0,=0xE0034000
 00000160  E5901000  LDR         R1,[R0,#0x0]
 00000164  E3811401  ORR         R1,R1,#0x1000000
 00000168  E5801000  STR         R1,[R0,#0x0]
 0000016C            ; SCOPE-END
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 43  

  178: }
 0000016C  E8BD5F7F  LDMIA       R13!,{R0-R6,R8-R12,LR}
 00000170  E25EF004  SUBS        R15,R14,#0x0004
 00000174          ENDP ; 'ADC_irq?A'


*** CODE SEGMENT '?PR?AdcNext?T?Fart':
  180: int AdcNext(int current)
 00000000  ---- Variable 'current' assigned to Register 'R0' ----
  181: {
 00000000            ; SCOPE-START
  183:     next = current;
 00000000  ---- Variable 'next' assigned to Register 'R0' ----
  184:     if (++next == 8) next = 0;
 00000000  1C01      MOV         R1,R0 ; next
 00000002  3101      ADD         R1,#0x1
 00000004  1C08      MOV         R0,R1 ; next
 00000006  2908      CMP         R1,#0x8 ; next
 00000008  D100      BNE         L_23  ; T=0x0000000C
 0000000A  2000      MOV         R0,#0x0
 0000000C          L_23:
  185:     return next;
 0000000C            ; SCOPE-END
  186: }
 0000000C  4770      BX          R14
 0000000E          ENDP ; 'AdcNext?T'


*** CODE SEGMENT '?PR?main?Fart':
  189: int main (void)
 00000000  B500      PUSH        {LR}
 00000002  B08A      SUB         R13,#0x28
 00000004  ---- Variable 'm' assigned to Register 'R6' ----
 00000004  ---- Variable 'n' assigned to Register 'R5' ----
 00000004  ---- Variable 'i' assigned to Register 'R4' ----
  190: {
 00000004            ; SCOPE-START
  193:     int num     = 0;
 00000004  2000      MOV         R0,#0x0
 00000006  9001      STR         R0,[R13,#0x4] ; num
  195:     int done  = false;
 00000008  2700      MOV         R7,#0x0
 0000000A  ---- Variable 'done' assigned to Register 'R7' ----
  196:     int EOL   = false;
 0000000A  2000      MOV         R0,#0x0
 0000000C  9002      STR         R0,[R13,#0x8] ; EOL
  197:     int abort = false;
 0000000E  2000      MOV         R0,#0x0
 00000010  9003      STR         R0,[R13,#0xC] ; abort
  198:     int flag  = false;
 00000012  2000      MOV         R0,#0x0
 00000014  9004      STR         R0,[R13,#0x10] ; flag
  199:     char CR[] = "\n";
 00000016  4800      LDR         R1,=?tpl?0001 ; ?tpl?0001
 00000018  A805      ADD         R0,R13,#0x14
 0000001A  2202      MOV         R2,#0x2
 0000001C          L_565:
 0000001C  780B      LDRB        R3,[R1,#0x0]
 0000001E  7003      STRB        R3,[R0,#0x0]
 00000020  1C49      ADD         R1,R1,#0x1
 00000022  1C40      ADD         R0,R0,#0x1
 00000024  1E52      SUB         R2,R2,#0x1
 00000026  D1F9      BNE         L_565  ; T=0x0000001C
  200:     char SP[] = " ";
 00000028  4800      LDR         R1,=?tpl?0002 ; ?tpl?0002
 0000002A  A806      ADD         R0,R13,#0x18
 0000002C  2202      MOV         R2,#0x2
 0000002E          L_566:
 0000002E  780B      LDRB        R3,[R1,#0x0]
 00000030  7003      STRB        R3,[R0,#0x0]
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 44  

 00000032  1C49      ADD         R1,R1,#0x1
 00000034  1C40      ADD         R0,R0,#0x1
 00000036  1E52      SUB         R2,R2,#0x1
 00000038  D1F9      BNE         L_566  ; T=0x0000002E
  201:     char NUMBERS[] = "0123456789";
 0000003A  4800      LDR         R1,=?tpl?0003 ; ?tpl?0003
 0000003C  A807      ADD         R0,R13,#0x1C
 0000003E  220B      MOV         R2,#0xB
 00000040          L_567:
 00000040  780B      LDRB        R3,[R1,#0x0]
 00000042  7003      STRB        R3,[R0,#0x0]
 00000044  1C49      ADD         R1,R1,#0x1
 00000046  1C40      ADD         R0,R0,#0x1
 00000048  1E52      SUB         R2,R2,#0x1
 0000004A  D1F9      BNE         L_567  ; T=0x00000040
  202:     softReset();
 0000004C  F7FF      BL          softReset?T  ; T=0x0001  (1)
 0000004E  FFD8      BL          softReset?T  ; T=0x0001  (2)
  206:         while ((UART0_RxNumber() > 0) && (EOL == false))
 00000050          L_33:
 00000050  E01B      B           L_30  ; T=0x0000008A
 00000052          L_32:
  208:             inChar = UART0_Get();
 00000052  F7FF      BL          UART0_Get?T  ; T=0x0001  (1)
 00000054  FFD5      BL          UART0_Get?T  ; T=0x0001  (2)
 00000056  9000      STR         R0,[R13,#0x0] ; inChar
  209:             if (inChar == ESCAPE) abort = true;
 00000058  9800      LDR         R0,[R13,#0x0] ; inChar
 0000005A  281B      CMP         R0,#0x1B
 0000005C  D101      BNE         L_34  ; T=0x00000062
 0000005E  2101      MOV         R1,#0x1
 00000060  9103      STR         R1,[R13,#0xC] ; abort
 00000062          L_34:
  210:              if ((inChar == LF))
 00000062  280A      CMP         R0,#0xA
 00000064  D107      BNE         L_35  ; T=0x00000076
  212:                 EOL        = true;          // new command
 00000066  2001      MOV         R0,#0x1
 00000068  9002      STR         R0,[R13,#0x8] ; EOL
  213:                 inBuf[num] = 0;
 0000006A  2000      MOV         R0,#0x0
 0000006C  9A01      LDR         R2,[R13,#0x4] ; num
 0000006E  4800      LDR         R1,=inBuf ; inBuf
 00000070  5488      STRB        R0,[R1,R2]
  214:                 splitInput();               // command plus parameters
 00000072  F7FF      BL          splitInput?T  ; T=0x0001  (1)
 00000074  FFC5      BL          splitInput?T  ; T=0x0001  (2)
  215:             }
 00000076          L_35:
  216:             if (EOL == false) inBuf[num++] = (char) inChar;
 00000076  9802      LDR         R0,[R13,#0x8] ; EOL
 00000078  2800      CMP         R0,#0x0
 0000007A  D106      BNE         L_30  ; T=0x0000008A
 0000007C  9800      LDR         R0,[R13,#0x0] ; inChar
 0000007E  9A01      LDR         R2,[R13,#0x4] ; num
 00000080  1C11      MOV         R1,R2
 00000082  3101      ADD         R1,#0x1
 00000084  9101      STR         R1,[R13,#0x4] ; num
 00000086  4800      LDR         R1,=inBuf ; inBuf
 00000088  5488      STRB        R0,[R1,R2]
  217:         }
 0000008A          L_30:
 0000008A  F7FF      BL          UART0_RxNumber?T  ; T=0x0001  (1)
 0000008C  FFB9      BL          UART0_RxNumber?T  ; T=0x0001  (2)
 0000008E  0400      LSL         R0,R0,#0x10 ; UART0_RxNumber?T
 00000090  0C00      LSR         R0,R0,#0x10
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 45  

 00000092  2800      CMP         R0,#0x0
 00000094  D902      BLS         L_31  ; T=0x0000009C
 00000096  9802      LDR         R0,[R13,#0x8] ; EOL
 00000098  2800      CMP         R0,#0x0
 0000009A  D0DA      BEQ         L_32  ; T=0x00000052
 0000009C          L_31:
  219:          curTime = Clock_GetTicks();
 0000009C  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 0000009E  FFB0      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 000000A0  4800      LDR         R1,=curTime ; curTime
 000000A2  6008      STR         R0,[R1,#0x0] ; curTime
  220:         seconds = Clock_GetSeconds();
 000000A4  F7FF      BL          Clock_GetSeconds?T  ; T=0x0001  (1)
 000000A6  FFAC      BL          Clock_GetSeconds?T  ; T=0x0001  (2)
 000000A8  4800      LDR         R1,=seconds ; seconds
 000000AA  6008      STR         R0,[R1,#0x0] ; seconds
  221:         ticks   = curTime;
 000000AC  4800      LDR         R0,=curTime ; curTime
 000000AE  6801      LDR         R1,[R0,#0x0] ; curTime
 000000B0  4800      LDR         R0,=ticks ; ticks
 000000B2  6001      STR         R1,[R0,#0x0] ; ticks
  222:         parInp  = GetBitsPar();
 000000B4  F7FF      BL          GetBitsPar?T  ; T=0x0001  (1)
 000000B6  FFA4      BL          GetBitsPar?T  ; T=0x0001  (2)
 000000B8  4800      LDR         R1,=parInp ; parInp
 000000BA  6008      STR         R0,[R1,#0x0] ; parInp
  225:         if ((MCS == statInit) && (EOL == true))
 000000BC  4800      LDR         R0,=MCS ; MCS
 000000BE  6800      LDR         R0,[R0,#0x0] ; MCS
 000000C0  2801      CMP         R0,#0x1
 000000C2  D171      BNE         L_38  ; T=0x000001A8
 000000C4  9802      LDR         R0,[R13,#0x8] ; EOL
 000000C6  2801      CMP         R0,#0x1
 000000C8  D16E      BNE         L_38  ; T=0x000001A8
  227:             switch(nBuffer[1])
 000000CA  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 000000CC  6800      LDR         R0,[R0,#0x0] ; nBuffer+4
 000000CE  2864      CMP         R0,#0x64
 000000D0  D02A      BEQ         L_40  ; T=0x00000128
 000000D2  2865      CMP         R0,#0x65
 000000D4  D02B      BEQ         L_41  ; T=0x0000012E
 000000D6  2868      CMP         R0,#0x68
 000000D8  D02C      BEQ         L_42  ; T=0x00000134
 000000DA  2869      CMP         R0,#0x69
 000000DC  D033      BEQ         L_43  ; T=0x00000146
 000000DE  286B      CMP         R0,#0x6B
 000000E0  D02B      BEQ         L_44  ; T=0x0000013A
 000000E2  286C      CMP         R0,#0x6C
 000000E4  D03E      BEQ         L_45  ; T=0x00000164
 000000E6  286F      CMP         R0,#0x6F
 000000E8  D02A      BEQ         L_47  ; T=0x00000140
 000000EA  2870      CMP         R0,#0x70
 000000EC  D034      BEQ         L_48  ; T=0x00000158
 000000EE  2871      CMP         R0,#0x71
 000000F0  D02F      BEQ         L_49  ; T=0x00000152
 000000F2  2872      CMP         R0,#0x72
 000000F4  D033      BEQ         L_50  ; T=0x0000015E
 000000F6  2874      CMP         R0,#0x74
 000000F8  D028      BEQ         L_51  ; T=0x0000014C
 000000FA  2875      CMP         R0,#0x75
 000000FC  D035      BEQ         L_52  ; T=0x0000016A
 000000FE  2876      CMP         R0,#0x76
 00000100  D036      BEQ         L_53  ; T=0x00000170
 00000102  2877      CMP         R0,#0x77
 00000104  D037      BEQ         L_54  ; T=0x00000176
 00000106  2878      CMP         R0,#0x78
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 46  

 00000108  D038      BEQ         L_55  ; T=0x0000017C
 0000010A  2879      CMP         R0,#0x79
 0000010C  D039      BEQ         L_56  ; T=0x00000182
 0000010E  287A      CMP         R0,#0x7A
 00000110  D03A      BEQ         L_57  ; T=0x00000188
 00000112  287B      CMP         R0,#0x7B
 00000114  D03B      BEQ         L_58  ; T=0x0000018E
 00000116  287C      CMP         R0,#0x7C
 00000118  D03D      BEQ         L_59  ; T=0x00000196
 0000011A  287D      CMP         R0,#0x7D
 0000011C  D03E      BEQ         L_60  ; T=0x0000019C
 0000011E  286E      CMP         R0,#0x6E
 00000120  D13E      BNE         L_39  ; T=0x000001A0
  229:             case cmdSaveTrial:  execSaveTrial();break;
 00000122          L_46:
 00000122  F7FF      BL          execSaveTrial?T  ; T=0x0001  (1)
 00000124  FF6D      BL          execSaveTrial?T  ; T=0x0001  (2)
 00000126  E03B      B           L_39  ; T=0x000001A0
  230:             case cmdStim:       execStim();     break;
 00000128          L_40:
 00000128  F7FF      BL          execStim?T  ; T=0x0001  (1)
 0000012A  FF6A      BL          execStim?T  ; T=0x0001  (2)
 0000012C  E038      B           L_39  ; T=0x000001A0
  231:             case cmdInit:       execInit();     break;
 0000012E          L_41:
 0000012E  F7FF      BL          execInit?T  ; T=0x0001  (1)
 00000130  FF67      BL          execInit?T  ; T=0x0001  (2)
 00000132  E035      B           L_39  ; T=0x000001A0
  232:             case cmdInfo:       getInfo();      break;
 00000134          L_42:
 00000134  F7FF      BL          getInfo?T  ; T=0x0001  (1)
 00000136  FF64      BL          getInfo?T  ; T=0x0001  (2)
 00000138  E032      B           L_39  ; T=0x000001A0
  233:             case cmdState:      getState();     break;
 0000013A          L_44:
 0000013A  F7FF      BL          getState?T  ; T=0x0001  (1)
 0000013C  FF61      BL          getState?T  ; T=0x0001  (2)
 0000013E  E02F      B           L_39  ; T=0x000001A0
  234:             case cmdStateTrial: getStateTrial();break;
 00000140          L_47:
 00000140  F7FF      BL          getStateTrial?T  ; T=0x0001  (1)
 00000142  FF5E      BL          getStateTrial?T  ; T=0x0001  (2)
 00000144  E02C      B           L_39  ; T=0x000001A0
  235:             case cmdClock:      getClock();     break;
 00000146          L_43:
 00000146  F7FF      BL          getClock?T  ; T=0x0001  (1)
 00000148  FF5B      BL          getClock?T  ; T=0x0001  (2)
 0000014A  E029      B           L_39  ; T=0x000001A0
  236:             case cmdTime:       getTime();      break;
 0000014C          L_51:
 0000014C  F7FF      BL          getTime?T  ; T=0x0001  (1)
 0000014E  FF58      BL          getTime?T  ; T=0x0001  (2)
 00000150  E026      B           L_39  ; T=0x000001A0
  237:             case cmdClrTime:    clrTime();      break;
 00000152          L_49:
 00000152  F7FF      BL          clrTime?T  ; T=0x0001  (1)
 00000154  FF55      BL          clrTime?T  ; T=0x0001  (2)
 00000156  E023      B           L_39  ; T=0x000001A0
  238:             case cmdReset:      execReset();    break;
 00000158          L_48:
 00000158  F7FF      BL          execReset?T  ; T=0x0001  (1)
 0000015A  FF52      BL          execReset?T  ; T=0x0001  (2)
 0000015C  E020      B           L_39  ; T=0x000001A0
  239:             case cmdAbort:      execAbort();    break;
 0000015E          L_50:
 0000015E  F7FF      BL          execAbort?T  ; T=0x0001  (1)
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 47  

 00000160  FF4F      BL          execAbort?T  ; T=0x0001  (2)
 00000162  E01D      B           L_39  ; T=0x000001A0
  240:             case cmdNextTrial:  execNextTrial();break;
 00000164          L_45:
 00000164  F7FF      BL          execNextTrial?T  ; T=0x0001  (1)
 00000166  FF4C      BL          execNextTrial?T  ; T=0x0001  (2)
 00000168  E01A      B           L_39  ; T=0x000001A0
  241:             case cmdBar:        getBarState();  break;
 0000016A          L_52:
 0000016A  F7FF      BL          getBarState?T  ; T=0x0001  (1)
 0000016C  FF49      BL          getBarState?T  ; T=0x0001  (2)
 0000016E  E017      B           L_39  ; T=0x000001A0
  242:             case cmdADC:        getADC();       break;
 00000170          L_53:
 00000170  F7FF      BL          getADC?T  ; T=0x0001  (1)
 00000172  FF46      BL          getADC?T  ; T=0x0001  (2)
 00000174  E014      B           L_39  ; T=0x000001A0
  243:             case cmdSelADC:     selectADC();    break;
 00000176          L_54:
 00000176  F7FF      BL          selectADC?T  ; T=0x0001  (1)
 00000178  FF43      BL          selectADC?T  ; T=0x0001  (2)
 0000017A  E011      B           L_39  ; T=0x000001A0
  244:             case cmdPin:        getPIO();       break;
 0000017C          L_55:
 0000017C  F7FF      BL          getPIO?T  ; T=0x0001  (1)
 0000017E  FF40      BL          getPIO?T  ; T=0x0001  (2)
 00000180  E00E      B           L_39  ; T=0x000001A0
  245:             case cmdSpeaker:    setSpeaker();   break;
 00000182          L_56:
 00000182  F7FF      BL          setSpeaker?T  ; T=0x0001  (1)
 00000184  FF3D      BL          setSpeaker?T  ; T=0x0001  (2)
 00000186  E00B      B           L_39  ; T=0x000001A0
  246:             case cmdNNMod:      loadNNMod();    break;
 00000188          L_57:
 00000188  F7FF      BL          loadNNMod?T  ; T=0x0001  (1)
 0000018A  FF3A      BL          loadNNMod?T  ; T=0x0001  (2)
 0000018C  E008      B           L_39  ; T=0x000001A0
  247:             case cmdNNSim:      simulateNN(-1); break;
 0000018E          L_58:
 0000018E  4800      LDR         R0,=0xFFFFFFFF
 00000190  F7FF      BL          simulateNN?T  ; T=0x0001  (1)
 00000192  FF36      BL          simulateNN?T  ; T=0x0001  (2)
 00000194  E004      B           L_39  ; T=0x000001A0
  248:             case cmdFixWnd:     setFixWindow(); break;
 00000196          L_59:
 00000196  F7FF      BL          setFixWindow?T  ; T=0x0001  (1)
 00000198  FF33      BL          setFixWindow?T  ; T=0x0001  (2)
 0000019A  E001      B           L_39  ; T=0x000001A0
  249:             case cmdSpeed:      getSpeed();     break;
 0000019C          L_60:
 0000019C  F7FF      BL          getSpeed?T  ; T=0x0001  (1)
 0000019E  FF30      BL          getSpeed?T  ; T=0x0001  (2)
  250:             }
 000001A0          L_39:
  251:             EOL = false;
 000001A0  2000      MOV         R0,#0x0
 000001A2  9002      STR         R0,[R13,#0x8] ; EOL
  252:             num = 0;
 000001A4  2000      MOV         R0,#0x0
 000001A6  9001      STR         R0,[R13,#0x4] ; num
  253:         }
 000001A8          L_38:
  255:         if ((MCS == statNextTrial) && (EOL == true))
 000001A8  4800      LDR         R0,=MCS ; MCS
 000001AA  6800      LDR         R0,[R0,#0x0] ; MCS
 000001AC  2802      CMP         R0,#0x2
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 48  

 000001AE  D000      BNE         $+4
 000001B0  E38E      B           L_61  ; T=0x000008D0
 000001B4  9802      LDR         R0,[R13,#0x8] ; EOL
 000001B6  2801      CMP         R0,#0x1
 000001B8  D000      BNE         $+4
 000001BA  E389      B           L_61  ; T=0x000008D0
  257:             flag = true;
 000001BE  2001      MOV         R0,#0x1
 000001C0  9004      STR         R0,[R13,#0x10] ; flag
  258:             switch(nBuffer[1])
 000001C2  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 000001C4  6800      LDR         R0,[R0,#0x0] ; nBuffer+4
 000001C6  286B      CMP         R0,#0x6B
 000001C8  D00A      BEQ         L_63  ; T=0x000001E0
 000001CA  286F      CMP         R0,#0x6F
 000001CC  D00D      BEQ         L_65  ; T=0x000001EA
 000001CE  2872      CMP         R0,#0x72
 000001D0  D015      BEQ         L_66  ; T=0x000001FE
 000001D2  2878      CMP         R0,#0x78
 000001D4  D00E      BEQ         L_67  ; T=0x000001F4
 000001D6  286D      CMP         R0,#0x6D
 000001D8  D115      BNE         L_62  ; T=0x00000206
  260:             case cmdStartTrial: execStartTrial(); flag = false;   break;
 000001DA          L_64:
 000001DA  F7FF      BL          execStartTrial?T  ; T=0x0001  (1)
 000001DC  FF11      BL          execStartTrial?T  ; T=0x0001  (2)
 000001DE  2000      MOV         R0,#0x0
 000001E0  9004      STR         R0,[R13,#0x10] ; flag
 000001E2  E010      B           L_62  ; T=0x00000206
  261:             case cmdState:      getState();       flag = false;   break;
 000001E4          L_63:
 000001E4  F7FF      BL          getState?T  ; T=0x0001  (1)
 000001E6  FF0C      BL          getState?T  ; T=0x0001  (2)
 000001E8  2000      MOV         R0,#0x0
 000001EA  9004      STR         R0,[R13,#0x10] ; flag
 000001EC  E00B      B           L_62  ; T=0x00000206
  262:             case cmdStateTrial: getStateTrial();  flag = false;   break;
 000001EE          L_65:
 000001EE  F7FF      BL          getStateTrial?T  ; T=0x0001  (1)
 000001F0  FF07      BL          getStateTrial?T  ; T=0x0001  (2)
 000001F2  2000      MOV         R0,#0x0
 000001F4  9004      STR         R0,[R13,#0x10] ; flag
 000001F6  E006      B           L_62  ; T=0x00000206
  263:             case cmdPin:        getPIO();         flag = false;   break;
 000001F8          L_67:
 000001F8  F7FF      BL          getPIO?T  ; T=0x0001  (1)
 000001FA  FF02      BL          getPIO?T  ; T=0x0001  (2)
 000001FC  2000      MOV         R0,#0x0
 000001FE  9004      STR         R0,[R13,#0x10] ; flag
 00000200  E001      B           L_62  ; T=0x00000206
  264:             case cmdAbort:      execAbort();      flag = false;   break;
 00000202          L_66:
 00000202  F7FF      BL          execAbort?T  ; T=0x0001  (1)
 00000204  FEFD      BL          execAbort?T  ; T=0x0001  (2)
 00000206  2000      MOV         R0,#0x0
 00000208  9004      STR         R0,[R13,#0x10] ; flag
  265:             }
 0000020A          L_62:
  267:             switch(nBuffer[1])
 0000020A  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 0000020C  6800      LDR         R0,[R0,#0x0] ; nBuffer+4
 0000020E  2804      CMP         R0,#0x4
 00000210  D100      BEQ         $+4
 00000212  E14C      B           L_70  ; T=0x000004AE
 00000216  2805      CMP         R0,#0x5
 00000218  D100      BEQ         $+4
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 49  

 0000021A  E199      B           L_71  ; T=0x00000550
 0000021E  2809      CMP         R0,#0x9
 00000220  D100      BEQ         $+4
 00000222  E0AC      B           L_72  ; T=0x0000037E
 00000226  280A      CMP         R0,#0xA
 00000228  D05D      BEQ         L_73  ; T=0x000002E6
 0000022A  280B      CMP         R0,#0xB
 0000022C  D100      BEQ         $+4
 0000022E  E1E0      B           L_74  ; T=0x000005F2
 00000232  280C      CMP         R0,#0xC
 00000234  D100      BEQ         $+4
 00000236  E228      B           L_75  ; T=0x0000068A
 0000023A  280F      CMP         R0,#0xF
 0000023C  D100      BEQ         $+4
 0000023E  E0EA      B           L_76  ; T=0x00000416
 00000242  2811      CMP         R0,#0x11
 00000244  D100      BEQ         $+4
 00000246  E26C      B           L_77  ; T=0x00000722
 0000024A  2812      CMP         R0,#0x12
 0000024C  D100      BEQ         $+4
 0000024E  E2D1      B           L_78  ; T=0x000007F4
 00000252  2803      CMP         R0,#0x3
 00000254  D000      BNE         $+4
 00000256  E325      B           L_68  ; T=0x000008A4
  269:             case stimBar:   
 0000025A          L_69:
  270:                 stim[nStim].status    = statInit;
 0000025A  2001      MOV         R0,#0x1
 0000025C  4800      LDR         R1,=nStim ; nStim
 0000025E  680A      LDR         R2,[R1,#0x0] ; nStim
 00000260  234C      MOV         R3,#0x4C
 00000262  4353      MUL         R3,R2
 00000264  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000266  50C8      STR         R0,[R1,R3]
  271:                 stim[nStim].kind      = stimBar;
 00000268  2003      MOV         R0,#0x3
 0000026A  214C      MOV         R1,#0x4C
 0000026C  434A      MUL         R2,R1
 0000026E  4800      LDR         R1,=stim + 0x8 ; stim+8
 00000270  5088      STR         R0,[R1,R2]
  272:                 stim[nStim].mode      = nBuffer[2];
 00000272  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 00000274  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 00000276  4800      LDR         R1,=nStim ; nStim
 00000278  680A      LDR         R2,[R1,#0x0] ; nStim
 0000027A  214C      MOV         R1,#0x4C
 0000027C  434A      MUL         R2,R1
 0000027E  4800      LDR         R1,=stim + 0x40 ; stim+64
 00000280  5088      STR         R0,[R1,R2]
  273:                 stim[nStim].edge      = nBuffer[3];
 00000282  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 00000284  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 00000286  4800      LDR         R1,=nStim ; nStim
 00000288  680A      LDR         R2,[R1,#0x0] ; nStim
 0000028A  214C      MOV         R1,#0x4C
 0000028C  434A      MUL         R2,R1
 0000028E  4800      LDR         R1,=stim + 0x10 ; stim+16
 00000290  5088      STR         R0,[R1,R2]
  274:                 stim[nStim].bitNo     = nBuffer[4];
 00000292  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 00000294  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 00000296  4800      LDR         R1,=nStim ; nStim
 00000298  680A      LDR         R2,[R1,#0x0] ; nStim
 0000029A  214C      MOV         R1,#0x4C
 0000029C  434A      MUL         R2,R1
 0000029E  4800      LDR         R1,=stim + 0x14 ; stim+20
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 50  

 000002A0  5088      STR         R0,[R1,R2]
  275:                 stim[nStim].startRef  = nBuffer[5];
 000002A2  4800      LDR         R0,=nBuffer + 0x14 ; nBuffer+20
 000002A4  6800      LDR         R0,[R0,#0x0] ; nBuffer+20
 000002A6  4800      LDR         R1,=nStim ; nStim
 000002A8  680A      LDR         R2,[R1,#0x0] ; nStim
 000002AA  214C      MOV         R1,#0x4C
 000002AC  434A      MUL         R2,R1
 000002AE  4800      LDR         R1,=stim + 0x24 ; stim+36
 000002B0  5088      STR         R0,[R1,R2]
  276:                 stim[nStim].startTime = nBuffer[6];
 000002B2  4800      LDR         R0,=nBuffer + 0x18 ; nBuffer+24
 000002B4  6800      LDR         R0,[R0,#0x0] ; nBuffer+24
 000002B6  4800      LDR         R1,=nStim ; nStim
 000002B8  680A      LDR         R2,[R1,#0x0] ; nStim
 000002BA  214C      MOV         R1,#0x4C
 000002BC  434A      MUL         R2,R1
 000002BE  4800      LDR         R1,=stim + 0x28 ; stim+40
 000002C0  5088      STR         R0,[R1,R2]
  277:                 stim[nStim].stopRef   = nBuffer[7];
 000002C2  4800      LDR         R0,=nBuffer + 0x1C ; nBuffer+28
 000002C4  6800      LDR         R0,[R0,#0x0] ; nBuffer+28
 000002C6  4800      LDR         R1,=nStim ; nStim
 000002C8  680A      LDR         R2,[R1,#0x0] ; nStim
 000002CA  214C      MOV         R1,#0x4C
 000002CC  434A      MUL         R2,R1
 000002CE  4800      LDR         R1,=stim + 0x2C ; stim+44
 000002D0  5088      STR         R0,[R1,R2]
  278:                 stim[nStim].stopTime  = nBuffer[8];
 000002D2  4800      LDR         R0,=nBuffer + 0x20 ; nBuffer+32
 000002D4  6800      LDR         R0,[R0,#0x0] ; nBuffer+32
 000002D6  4800      LDR         R1,=nStim ; nStim
 000002D8  680A      LDR         R2,[R1,#0x0] ; nStim
 000002DA  214C      MOV         R1,#0x4C
 000002DC  434A      MUL         R2,R1
 000002DE  4800      LDR         R1,=stim + 0x30 ; stim+48
 000002E0  5088      STR         R0,[R1,R2]
  279:                 stim[nStim].event     = nBuffer[9];
 000002E2  4800      LDR         R0,=nBuffer + 0x24 ; nBuffer+36
 000002E4  6800      LDR         R0,[R0,#0x0] ; nBuffer+36
 000002E6  4800      LDR         R1,=nStim ; nStim
 000002E8  680A      LDR         R2,[R1,#0x0] ; nStim
 000002EA  214C      MOV         R1,#0x4C
 000002EC  434A      MUL         R2,R1
 000002EE  4800      LDR         R1,=stim + 0x3C ; stim+60
 000002F0  5088      STR         R0,[R1,R2]
  280:                 nStim++;
 000002F2  4800      LDR         R0,=nStim ; nStim
 000002F4  6801      LDR         R1,[R0,#0x0] ; nStim
 000002F6  3101      ADD         R1,#0x1
 000002F8  6001      STR         R1,[R0,#0x0] ; nStim
  281:                 break;
 000002FA  E2D3      B           L_68  ; T=0x000008A4
  282:             case stimRec:
 000002FC          L_73:
  283:                 stim[nStim].status    = statInit;
 000002FC  2001      MOV         R0,#0x1
 000002FE  4800      LDR         R1,=nStim ; nStim
 00000300  680A      LDR         R2,[R1,#0x0] ; nStim
 00000302  234C      MOV         R3,#0x4C
 00000304  4353      MUL         R3,R2
 00000306  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000308  50C8      STR         R0,[R1,R3]
  284:                 stim[nStim].kind      = stimRec;
 0000030A  200A      MOV         R0,#0xA
 0000030C  214C      MOV         R1,#0x4C
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 51  

 0000030E  434A      MUL         R2,R1
 00000310  4800      LDR         R1,=stim + 0x8 ; stim+8
 00000312  5088      STR         R0,[R1,R2]
  285:                 stim[nStim].bitNo     = nBuffer[2];
 00000314  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 00000316  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 00000318  4800      LDR         R1,=nStim ; nStim
 0000031A  680A      LDR         R2,[R1,#0x0] ; nStim
 0000031C  214C      MOV         R1,#0x4C
 0000031E  434A      MUL         R2,R1
 00000320  4800      LDR         R1,=stim + 0x14 ; stim+20
 00000322  5088      STR         R0,[R1,R2]
  286:                 stim[nStim].startRef  = nBuffer[3];
 00000324  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 00000326  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 00000328  4800      LDR         R1,=nStim ; nStim
 0000032A  680A      LDR         R2,[R1,#0x0] ; nStim
 0000032C  214C      MOV         R1,#0x4C
 0000032E  434A      MUL         R2,R1
 00000330  4800      LDR         R1,=stim + 0x24 ; stim+36
 00000332  5088      STR         R0,[R1,R2]
  287:                 stim[nStim].startTime = nBuffer[4];
 00000334  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 00000336  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 00000338  4800      LDR         R1,=nStim ; nStim
 0000033A  680A      LDR         R2,[R1,#0x0] ; nStim
 0000033C  214C      MOV         R1,#0x4C
 0000033E  434A      MUL         R2,R1
 00000340  4800      LDR         R1,=stim + 0x28 ; stim+40
 00000342  5088      STR         R0,[R1,R2]
  288:                 stim[nStim].stopRef   = nBuffer[5];
 00000344  4800      LDR         R0,=nBuffer + 0x14 ; nBuffer+20
 00000346  6800      LDR         R0,[R0,#0x0] ; nBuffer+20
 00000348  4800      LDR         R1,=nStim ; nStim
 0000034A  680A      LDR         R2,[R1,#0x0] ; nStim
 0000034C  214C      MOV         R1,#0x4C
 0000034E  434A      MUL         R2,R1
 00000350  4800      LDR         R1,=stim + 0x2C ; stim+44
 00000352  5088      STR         R0,[R1,R2]
  289:                 stim[nStim].stopTime  = nBuffer[6];
 00000354  4800      LDR         R0,=nBuffer + 0x18 ; nBuffer+24
 00000356  6800      LDR         R0,[R0,#0x0] ; nBuffer+24
 00000358  4800      LDR         R1,=nStim ; nStim
 0000035A  680A      LDR         R2,[R1,#0x0] ; nStim
 0000035C  214C      MOV         R1,#0x4C
 0000035E  434A      MUL         R2,R1
 00000360  4800      LDR         R1,=stim + 0x30 ; stim+48
 00000362  5088      STR         R0,[R1,R2]
  290:                 stim[nStim].event     = nBuffer[7];
 00000364  4800      LDR         R0,=nBuffer + 0x1C ; nBuffer+28
 00000366  6800      LDR         R0,[R0,#0x0] ; nBuffer+28
 00000368  4800      LDR         R1,=nStim ; nStim
 0000036A  680A      LDR         R2,[R1,#0x0] ; nStim
 0000036C  214C      MOV         R1,#0x4C
 0000036E  434A      MUL         R2,R1
 00000370  4800      LDR         R1,=stim + 0x3C ; stim+60
 00000372  5088      STR         R0,[R1,R2]
  291:                 recBit = (1 << (stim[nStim].bitNo-1));
 00000374  4800      LDR         R0,=nStim ; nStim
 00000376  6801      LDR         R1,[R0,#0x0] ; nStim
 00000378  204C      MOV         R0,#0x4C
 0000037A  4341      MUL         R1,R0
 0000037C  4800      LDR         R0,=stim + 0x14 ; stim+20
 0000037E  5840      LDR         R0,[R0,R1]
 00000380  3801      SUB         R0,#0x1
 00000382  2101      MOV         R1,#0x1
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 52  

 00000384  4081      LSL         R1,R0
 00000386  4800      LDR         R0,=recBit ; recBit
 00000388  6001      STR         R1,[R0,#0x0] ; recBit
  292:                 nStim++;
 0000038A  4800      LDR         R0,=nStim ; nStim
 0000038C  6801      LDR         R1,[R0,#0x0] ; nStim
 0000038E  3101      ADD         R1,#0x1
 00000390  6001      STR         R1,[R0,#0x0] ; nStim
  293:                 break;
 00000392  E287      B           L_68  ; T=0x000008A4
  294:             case stimRew:
 00000394          L_72:
  295:                 stim[nStim].status    = statInit;
 00000394  2001      MOV         R0,#0x1
 00000396  4800      LDR         R1,=nStim ; nStim
 00000398  680A      LDR         R2,[R1,#0x0] ; nStim
 0000039A  234C      MOV         R3,#0x4C
 0000039C  4353      MUL         R3,R2
 0000039E  4800      LDR         R1,=stim + 0x4 ; stim+4
 000003A0  50C8      STR         R0,[R1,R3]
  296:                 stim[nStim].kind      = stimRew;
 000003A2  2009      MOV         R0,#0x9
 000003A4  214C      MOV         R1,#0x4C
 000003A6  434A      MUL         R2,R1
 000003A8  4800      LDR         R1,=stim + 0x8 ; stim+8
 000003AA  5088      STR         R0,[R1,R2]
  297:                 stim[nStim].bitNo     = nBuffer[2];
 000003AC  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 000003AE  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 000003B0  4800      LDR         R1,=nStim ; nStim
 000003B2  680A      LDR         R2,[R1,#0x0] ; nStim
 000003B4  214C      MOV         R1,#0x4C
 000003B6  434A      MUL         R2,R1
 000003B8  4800      LDR         R1,=stim + 0x14 ; stim+20
 000003BA  5088      STR         R0,[R1,R2]
  298:                 stim[nStim].startRef  = nBuffer[3];
 000003BC  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 000003BE  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 000003C0  4800      LDR         R1,=nStim ; nStim
 000003C2  680A      LDR         R2,[R1,#0x0] ; nStim
 000003C4  214C      MOV         R1,#0x4C
 000003C6  434A      MUL         R2,R1
 000003C8  4800      LDR         R1,=stim + 0x24 ; stim+36
 000003CA  5088      STR         R0,[R1,R2]
  299:                 stim[nStim].startTime = nBuffer[4];
 000003CC  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 000003CE  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 000003D0  4800      LDR         R1,=nStim ; nStim
 000003D2  680A      LDR         R2,[R1,#0x0] ; nStim
 000003D4  214C      MOV         R1,#0x4C
 000003D6  434A      MUL         R2,R1
 000003D8  4800      LDR         R1,=stim + 0x28 ; stim+40
 000003DA  5088      STR         R0,[R1,R2]
  300:                 stim[nStim].stopRef   = nBuffer[5];
 000003DC  4800      LDR         R0,=nBuffer + 0x14 ; nBuffer+20
 000003DE  6800      LDR         R0,[R0,#0x0] ; nBuffer+20
 000003E0  4800      LDR         R1,=nStim ; nStim
 000003E2  680A      LDR         R2,[R1,#0x0] ; nStim
 000003E4  214C      MOV         R1,#0x4C
 000003E6  434A      MUL         R2,R1
 000003E8  4800      LDR         R1,=stim + 0x2C ; stim+44
 000003EA  5088      STR         R0,[R1,R2]
  301:                 stim[nStim].stopTime  = nBuffer[6];
 000003EC  4800      LDR         R0,=nBuffer + 0x18 ; nBuffer+24
 000003EE  6800      LDR         R0,[R0,#0x0] ; nBuffer+24
 000003F0  4800      LDR         R1,=nStim ; nStim
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 53  

 000003F2  680A      LDR         R2,[R1,#0x0] ; nStim
 000003F4  214C      MOV         R1,#0x4C
 000003F6  434A      MUL         R2,R1
 000003F8  4800      LDR         R1,=stim + 0x30 ; stim+48
 000003FA  5088      STR         R0,[R1,R2]
  302:                 stim[nStim].event     = nBuffer[7];
 000003FC  4800      LDR         R0,=nBuffer + 0x1C ; nBuffer+28
 000003FE  6800      LDR         R0,[R0,#0x0] ; nBuffer+28
 00000400  4800      LDR         R1,=nStim ; nStim
 00000402  680A      LDR         R2,[R1,#0x0] ; nStim
 00000404  214C      MOV         R1,#0x4C
 00000406  434A      MUL         R2,R1
 00000408  4800      LDR         R1,=stim + 0x3C ; stim+60
 0000040A  5088      STR         R0,[R1,R2]
  303:                 rewBit = (1 << (stim[nStim].bitNo-1));
 0000040C  4800      LDR         R0,=nStim ; nStim
 0000040E  6801      LDR         R1,[R0,#0x0] ; nStim
 00000410  204C      MOV         R0,#0x4C
 00000412  4341      MUL         R1,R0
 00000414  4800      LDR         R0,=stim + 0x14 ; stim+20
 00000416  5840      LDR         R0,[R0,R1]
 00000418  3801      SUB         R0,#0x1
 0000041A  2101      MOV         R1,#0x1
 0000041C  4081      LSL         R1,R0
 0000041E  4800      LDR         R0,=rewBit ; rewBit
 00000420  6001      STR         R1,[R0,#0x0] ; rewBit
  304:                 nStim++;
 00000422  4800      LDR         R0,=nStim ; nStim
 00000424  6801      LDR         R1,[R0,#0x0] ; nStim
 00000426  3101      ADD         R1,#0x1
 00000428  6001      STR         R1,[R0,#0x0] ; nStim
  305:                 break;
 0000042A  E23B      B           L_68  ; T=0x000008A4
  306:             case stimLas:
 0000042C          L_76:
  307:                 stim[nStim].status    = statInit;
 0000042C  2001      MOV         R0,#0x1
 0000042E  4800      LDR         R1,=nStim ; nStim
 00000430  680A      LDR         R2,[R1,#0x0] ; nStim
 00000432  234C      MOV         R3,#0x4C
 00000434  4353      MUL         R3,R2
 00000436  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000438  50C8      STR         R0,[R1,R3]
  308:                 stim[nStim].kind      = stimLas;
 0000043A  200F      MOV         R0,#0xF
 0000043C  214C      MOV         R1,#0x4C
 0000043E  434A      MUL         R2,R1
 00000440  4800      LDR         R1,=stim + 0x8 ; stim+8
 00000442  5088      STR         R0,[R1,R2]
  309:                 stim[nStim].bitNo     = nBuffer[2];
 00000444  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 00000446  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 00000448  4800      LDR         R1,=nStim ; nStim
 0000044A  680A      LDR         R2,[R1,#0x0] ; nStim
 0000044C  214C      MOV         R1,#0x4C
 0000044E  434A      MUL         R2,R1
 00000450  4800      LDR         R1,=stim + 0x14 ; stim+20
 00000452  5088      STR         R0,[R1,R2]
  310:                 stim[nStim].startRef  = nBuffer[3];
 00000454  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 00000456  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 00000458  4800      LDR         R1,=nStim ; nStim
 0000045A  680A      LDR         R2,[R1,#0x0] ; nStim
 0000045C  214C      MOV         R1,#0x4C
 0000045E  434A      MUL         R2,R1
 00000460  4800      LDR         R1,=stim + 0x24 ; stim+36
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 54  

 00000462  5088      STR         R0,[R1,R2]
  311:                 stim[nStim].startTime = nBuffer[4];
 00000464  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 00000466  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 00000468  4800      LDR         R1,=nStim ; nStim
 0000046A  680A      LDR         R2,[R1,#0x0] ; nStim
 0000046C  214C      MOV         R1,#0x4C
 0000046E  434A      MUL         R2,R1
 00000470  4800      LDR         R1,=stim + 0x28 ; stim+40
 00000472  5088      STR         R0,[R1,R2]
  312:                 stim[nStim].stopRef   = nBuffer[5];
 00000474  4800      LDR         R0,=nBuffer + 0x14 ; nBuffer+20
 00000476  6800      LDR         R0,[R0,#0x0] ; nBuffer+20
 00000478  4800      LDR         R1,=nStim ; nStim
 0000047A  680A      LDR         R2,[R1,#0x0] ; nStim
 0000047C  214C      MOV         R1,#0x4C
 0000047E  434A      MUL         R2,R1
 00000480  4800      LDR         R1,=stim + 0x2C ; stim+44
 00000482  5088      STR         R0,[R1,R2]
  313:                 stim[nStim].stopTime  = nBuffer[6];
 00000484  4800      LDR         R0,=nBuffer + 0x18 ; nBuffer+24
 00000486  6800      LDR         R0,[R0,#0x0] ; nBuffer+24
 00000488  4800      LDR         R1,=nStim ; nStim
 0000048A  680A      LDR         R2,[R1,#0x0] ; nStim
 0000048C  214C      MOV         R1,#0x4C
 0000048E  434A      MUL         R2,R1
 00000490  4800      LDR         R1,=stim + 0x30 ; stim+48
 00000492  5088      STR         R0,[R1,R2]
  314:                 stim[nStim].event     = nBuffer[7];
 00000494  4800      LDR         R0,=nBuffer + 0x1C ; nBuffer+28
 00000496  6800      LDR         R0,[R0,#0x0] ; nBuffer+28
 00000498  4800      LDR         R1,=nStim ; nStim
 0000049A  680A      LDR         R2,[R1,#0x0] ; nStim
 0000049C  214C      MOV         R1,#0x4C
 0000049E  434A      MUL         R2,R1
 000004A0  4800      LDR         R1,=stim + 0x3C ; stim+60
 000004A2  5088      STR         R0,[R1,R2]
  315:                 lasBit = (1 << (stim[nStim].bitNo-1));
 000004A4  4800      LDR         R0,=nStim ; nStim
 000004A6  6801      LDR         R1,[R0,#0x0] ; nStim
 000004A8  204C      MOV         R0,#0x4C
 000004AA  4341      MUL         R1,R0
 000004AC  4800      LDR         R0,=stim + 0x14 ; stim+20
 000004AE  5840      LDR         R0,[R0,R1]
 000004B0  3801      SUB         R0,#0x1
 000004B2  2101      MOV         R1,#0x1
 000004B4  4081      LSL         R1,R0
 000004B6  4800      LDR         R0,=lasBit ; lasBit
 000004B8  6001      STR         R1,[R0,#0x0] ; lasBit
  316:                 nStim++;
 000004BA  4800      LDR         R0,=nStim ; nStim
 000004BC  6801      LDR         R1,[R0,#0x0] ; nStim
 000004BE  3101      ADD         R1,#0x1
 000004C0  6001      STR         R1,[R0,#0x0] ; nStim
  317:                 break;
 000004C2  E1EF      B           L_68  ; T=0x000008A4
  318:             case stimSky:
 000004C4          L_70:
  319:                 stim[nStim].status    = statInit;
 000004C4  2001      MOV         R0,#0x1
 000004C6  4800      LDR         R1,=nStim ; nStim
 000004C8  680A      LDR         R2,[R1,#0x0] ; nStim
 000004CA  234C      MOV         R3,#0x4C
 000004CC  4353      MUL         R3,R2
 000004CE  4800      LDR         R1,=stim + 0x4 ; stim+4
 000004D0  50C8      STR         R0,[R1,R3]
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 55  

  320:                 stim[nStim].kind      = stimSky;
 000004D2  2004      MOV         R0,#0x4
 000004D4  214C      MOV         R1,#0x4C
 000004D6  434A      MUL         R2,R1
 000004D8  4800      LDR         R1,=stim + 0x8 ; stim+8
 000004DA  5088      STR         R0,[R1,R2]
  321:                 stim[nStim].posX      = nBuffer[2];
 000004DC  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 000004DE  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 000004E0  4800      LDR         R1,=nStim ; nStim
 000004E2  680A      LDR         R2,[R1,#0x0] ; nStim
 000004E4  214C      MOV         R1,#0x4C
 000004E6  434A      MUL         R2,R1
 000004E8  4800      LDR         R1,=stim + 0x18 ; stim+24
 000004EA  5088      STR         R0,[R1,R2]
  322:                 stim[nStim].posY      = nBuffer[3];
 000004EC  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 000004EE  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 000004F0  4800      LDR         R1,=nStim ; nStim
 000004F2  680A      LDR         R2,[R1,#0x0] ; nStim
 000004F4  214C      MOV         R1,#0x4C
 000004F6  434A      MUL         R2,R1
 000004F8  4800      LDR         R1,=stim + 0x1C ; stim+28
 000004FA  5088      STR         R0,[R1,R2]
  323:                 stim[nStim].level     = nBuffer[4];
 000004FC  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 000004FE  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 00000500  4800      LDR         R1,=nStim ; nStim
 00000502  680A      LDR         R2,[R1,#0x0] ; nStim
 00000504  214C      MOV         R1,#0x4C
 00000506  434A      MUL         R2,R1
 00000508  4800      LDR         R1,=stim + 0x20 ; stim+32
 0000050A  5088      STR         R0,[R1,R2]
  324:                 stim[nStim].startRef  = nBuffer[5];
 0000050C  4800      LDR         R0,=nBuffer + 0x14 ; nBuffer+20
 0000050E  6800      LDR         R0,[R0,#0x0] ; nBuffer+20
 00000510  4800      LDR         R1,=nStim ; nStim
 00000512  680A      LDR         R2,[R1,#0x0] ; nStim
 00000514  214C      MOV         R1,#0x4C
 00000516  434A      MUL         R2,R1
 00000518  4800      LDR         R1,=stim + 0x24 ; stim+36
 0000051A  5088      STR         R0,[R1,R2]
  325:                 stim[nStim].startTime = nBuffer[6];
 0000051C  4800      LDR         R0,=nBuffer + 0x18 ; nBuffer+24
 0000051E  6800      LDR         R0,[R0,#0x0] ; nBuffer+24
 00000520  4800      LDR         R1,=nStim ; nStim
 00000522  680A      LDR         R2,[R1,#0x0] ; nStim
 00000524  214C      MOV         R1,#0x4C
 00000526  434A      MUL         R2,R1
 00000528  4800      LDR         R1,=stim + 0x28 ; stim+40
 0000052A  5088      STR         R0,[R1,R2]
  326:                 stim[nStim].stopRef   = nBuffer[7];
 0000052C  4800      LDR         R0,=nBuffer + 0x1C ; nBuffer+28
 0000052E  6800      LDR         R0,[R0,#0x0] ; nBuffer+28
 00000530  4800      LDR         R1,=nStim ; nStim
 00000532  680A      LDR         R2,[R1,#0x0] ; nStim
 00000534  214C      MOV         R1,#0x4C
 00000536  434A      MUL         R2,R1
 00000538  4800      LDR         R1,=stim + 0x2C ; stim+44
 0000053A  5088      STR         R0,[R1,R2]
  327:                 stim[nStim].stopTime  = nBuffer[8];
 0000053C  4800      LDR         R0,=nBuffer + 0x20 ; nBuffer+32
 0000053E  6800      LDR         R0,[R0,#0x0] ; nBuffer+32
 00000540  4800      LDR         R1,=nStim ; nStim
 00000542  680A      LDR         R2,[R1,#0x0] ; nStim
 00000544  214C      MOV         R1,#0x4C
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 56  

 00000546  434A      MUL         R2,R1
 00000548  4800      LDR         R1,=stim + 0x30 ; stim+48
 0000054A  5088      STR         R0,[R1,R2]
  328:                 stim[nStim].event     = nBuffer[9];
 0000054C  4800      LDR         R0,=nBuffer + 0x24 ; nBuffer+36
 0000054E  6800      LDR         R0,[R0,#0x0] ; nBuffer+36
 00000550  4800      LDR         R1,=nStim ; nStim
 00000552  680A      LDR         R2,[R1,#0x0] ; nStim
 00000554  214C      MOV         R1,#0x4C
 00000556  434A      MUL         R2,R1
 00000558  4800      LDR         R1,=stim + 0x3C ; stim+60
 0000055A  5088      STR         R0,[R1,R2]
  329:                 nStim++;
 0000055C  4800      LDR         R0,=nStim ; nStim
 0000055E  6801      LDR         R1,[R0,#0x0] ; nStim
 00000560  3101      ADD         R1,#0x1
 00000562  6001      STR         R1,[R0,#0x0] ; nStim
  330:                 break;                                                     
 00000564  E19E      B           L_68  ; T=0x000008A4
  331:             case stimLed:
 00000566          L_71:
  332:                 stim[nStim].status    = statInit;
 00000566  2001      MOV         R0,#0x1
 00000568  4800      LDR         R1,=nStim ; nStim
 0000056A  680A      LDR         R2,[R1,#0x0] ; nStim
 0000056C  234C      MOV         R3,#0x4C
 0000056E  4353      MUL         R3,R2
 00000570  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000572  50C8      STR         R0,[R1,R3]
  333:                 stim[nStim].kind      = stimLed;
 00000574  2005      MOV         R0,#0x5
 00000576  214C      MOV         R1,#0x4C
 00000578  434A      MUL         R2,R1
 0000057A  4800      LDR         R1,=stim + 0x8 ; stim+8
 0000057C  5088      STR         R0,[R1,R2]
  334:                 stim[nStim].posX      = nBuffer[2];
 0000057E  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 00000580  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 00000582  4800      LDR         R1,=nStim ; nStim
 00000584  680A      LDR         R2,[R1,#0x0] ; nStim
 00000586  214C      MOV         R1,#0x4C
 00000588  434A      MUL         R2,R1
 0000058A  4800      LDR         R1,=stim + 0x18 ; stim+24
 0000058C  5088      STR         R0,[R1,R2]
  335:                 stim[nStim].posY      = nBuffer[3];
 0000058E  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 00000590  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 00000592  4800      LDR         R1,=nStim ; nStim
 00000594  680A      LDR         R2,[R1,#0x0] ; nStim
 00000596  214C      MOV         R1,#0x4C
 00000598  434A      MUL         R2,R1
 0000059A  4800      LDR         R1,=stim + 0x1C ; stim+28
 0000059C  5088      STR         R0,[R1,R2]
  336:                 stim[nStim].level     = nBuffer[4];
 0000059E  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 000005A0  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 000005A2  4800      LDR         R1,=nStim ; nStim
 000005A4  680A      LDR         R2,[R1,#0x0] ; nStim
 000005A6  214C      MOV         R1,#0x4C
 000005A8  434A      MUL         R2,R1
 000005AA  4800      LDR         R1,=stim + 0x20 ; stim+32
 000005AC  5088      STR         R0,[R1,R2]
  337:                 stim[nStim].startRef  = nBuffer[5];
 000005AE  4800      LDR         R0,=nBuffer + 0x14 ; nBuffer+20
 000005B0  6800      LDR         R0,[R0,#0x0] ; nBuffer+20
 000005B2  4800      LDR         R1,=nStim ; nStim
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 57  

 000005B4  680A      LDR         R2,[R1,#0x0] ; nStim
 000005B6  214C      MOV         R1,#0x4C
 000005B8  434A      MUL         R2,R1
 000005BA  4800      LDR         R1,=stim + 0x24 ; stim+36
 000005BC  5088      STR         R0,[R1,R2]
  338:                 stim[nStim].startTime = nBuffer[6];
 000005BE  4800      LDR         R0,=nBuffer + 0x18 ; nBuffer+24
 000005C0  6800      LDR         R0,[R0,#0x0] ; nBuffer+24
 000005C2  4800      LDR         R1,=nStim ; nStim
 000005C4  680A      LDR         R2,[R1,#0x0] ; nStim
 000005C6  214C      MOV         R1,#0x4C
 000005C8  434A      MUL         R2,R1
 000005CA  4800      LDR         R1,=stim + 0x28 ; stim+40
 000005CC  5088      STR         R0,[R1,R2]
  339:                 stim[nStim].stopRef   = nBuffer[7];
 000005CE  4800      LDR         R0,=nBuffer + 0x1C ; nBuffer+28
 000005D0  6800      LDR         R0,[R0,#0x0] ; nBuffer+28
 000005D2  4800      LDR         R1,=nStim ; nStim
 000005D4  680A      LDR         R2,[R1,#0x0] ; nStim
 000005D6  214C      MOV         R1,#0x4C
 000005D8  434A      MUL         R2,R1
 000005DA  4800      LDR         R1,=stim + 0x2C ; stim+44
 000005DC  5088      STR         R0,[R1,R2]
  340:                 stim[nStim].stopTime  = nBuffer[8];
 000005DE  4800      LDR         R0,=nBuffer + 0x20 ; nBuffer+32
 000005E0  6800      LDR         R0,[R0,#0x0] ; nBuffer+32
 000005E2  4800      LDR         R1,=nStim ; nStim
 000005E4  680A      LDR         R2,[R1,#0x0] ; nStim
 000005E6  214C      MOV         R1,#0x4C
 000005E8  434A      MUL         R2,R1
 000005EA  4800      LDR         R1,=stim + 0x30 ; stim+48
 000005EC  5088      STR         R0,[R1,R2]
  341:                 stim[nStim].event     = nBuffer[9];
 000005EE  4800      LDR         R0,=nBuffer + 0x24 ; nBuffer+36
 000005F0  6800      LDR         R0,[R0,#0x0] ; nBuffer+36
 000005F2  4800      LDR         R1,=nStim ; nStim
 000005F4  680A      LDR         R2,[R1,#0x0] ; nStim
 000005F6  214C      MOV         R1,#0x4C
 000005F8  434A      MUL         R2,R1
 000005FA  4800      LDR         R1,=stim + 0x3C ; stim+60
 000005FC  5088      STR         R0,[R1,R2]
  342:                 nStim++;
 000005FE  4800      LDR         R0,=nStim ; nStim
 00000600  6801      LDR         R1,[R0,#0x0] ; nStim
 00000602  3101      ADD         R1,#0x1
 00000604  6001      STR         R1,[R0,#0x0] ; nStim
  343:                 break;
 00000606  E14D      B           L_68  ; T=0x000008A4
  344:             case stimSnd1:  
 00000608          L_74:
  345:                 stim[nStim].status    = statInit;
 00000608  2001      MOV         R0,#0x1
 0000060A  4800      LDR         R1,=nStim ; nStim
 0000060C  680A      LDR         R2,[R1,#0x0] ; nStim
 0000060E  234C      MOV         R3,#0x4C
 00000610  4353      MUL         R3,R2
 00000612  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000614  50C8      STR         R0,[R1,R3]
  346:                 stim[nStim].kind      = stimSnd1;
 00000616  200B      MOV         R0,#0xB
 00000618  214C      MOV         R1,#0x4C
 0000061A  434A      MUL         R2,R1
 0000061C  4800      LDR         R1,=stim + 0x8 ; stim+8
 0000061E  5088      STR         R0,[R1,R2]
  347:                 stim[nStim].bitNo     = nBuffer[2];
 00000620  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 58  

 00000622  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 00000624  4800      LDR         R1,=nStim ; nStim
 00000626  680A      LDR         R2,[R1,#0x0] ; nStim
 00000628  214C      MOV         R1,#0x4C
 0000062A  434A      MUL         R2,R1
 0000062C  4800      LDR         R1,=stim + 0x14 ; stim+20
 0000062E  5088      STR         R0,[R1,R2]
  348:                 stim[nStim].startRef  = nBuffer[3];
 00000630  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 00000632  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 00000634  4800      LDR         R1,=nStim ; nStim
 00000636  680A      LDR         R2,[R1,#0x0] ; nStim
 00000638  214C      MOV         R1,#0x4C
 0000063A  434A      MUL         R2,R1
 0000063C  4800      LDR         R1,=stim + 0x24 ; stim+36
 0000063E  5088      STR         R0,[R1,R2]
  349:                 stim[nStim].startTime = nBuffer[4];
 00000640  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 00000642  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 00000644  4800      LDR         R1,=nStim ; nStim
 00000646  680A      LDR         R2,[R1,#0x0] ; nStim
 00000648  214C      MOV         R1,#0x4C
 0000064A  434A      MUL         R2,R1
 0000064C  4800      LDR         R1,=stim + 0x28 ; stim+40
 0000064E  5088      STR         R0,[R1,R2]
  350:                 stim[nStim].stopRef   = nBuffer[5];
 00000650  4800      LDR         R0,=nBuffer + 0x14 ; nBuffer+20
 00000652  6800      LDR         R0,[R0,#0x0] ; nBuffer+20
 00000654  4800      LDR         R1,=nStim ; nStim
 00000656  680A      LDR         R2,[R1,#0x0] ; nStim
 00000658  214C      MOV         R1,#0x4C
 0000065A  434A      MUL         R2,R1
 0000065C  4800      LDR         R1,=stim + 0x2C ; stim+44
 0000065E  5088      STR         R0,[R1,R2]
  351:                 stim[nStim].stopTime  = nBuffer[6];
 00000660  4800      LDR         R0,=nBuffer + 0x18 ; nBuffer+24
 00000662  6800      LDR         R0,[R0,#0x0] ; nBuffer+24
 00000664  4800      LDR         R1,=nStim ; nStim
 00000666  680A      LDR         R2,[R1,#0x0] ; nStim
 00000668  214C      MOV         R1,#0x4C
 0000066A  434A      MUL         R2,R1
 0000066C  4800      LDR         R1,=stim + 0x30 ; stim+48
 0000066E  5088      STR         R0,[R1,R2]
  352:                 stim[nStim].event     = nBuffer[7];
 00000670  4800      LDR         R0,=nBuffer + 0x1C ; nBuffer+28
 00000672  6800      LDR         R0,[R0,#0x0] ; nBuffer+28
 00000674  4800      LDR         R1,=nStim ; nStim
 00000676  680A      LDR         R2,[R1,#0x0] ; nStim
 00000678  214C      MOV         R1,#0x4C
 0000067A  434A      MUL         R2,R1
 0000067C  4800      LDR         R1,=stim + 0x3C ; stim+60
 0000067E  5088      STR         R0,[R1,R2]
  353:                 sndBit = (1 << (stim[nStim].bitNo-1));
 00000680  4800      LDR         R0,=nStim ; nStim
 00000682  6801      LDR         R1,[R0,#0x0] ; nStim
 00000684  204C      MOV         R0,#0x4C
 00000686  4341      MUL         R1,R0
 00000688  4800      LDR         R0,=stim + 0x14 ; stim+20
 0000068A  5840      LDR         R0,[R0,R1]
 0000068C  3801      SUB         R0,#0x1
 0000068E  2101      MOV         R1,#0x1
 00000690  4081      LSL         R1,R0
 00000692  4800      LDR         R0,=sndBit ; sndBit
 00000694  6001      STR         R1,[R0,#0x0] ; sndBit
  354:                 nStim++;
 00000696  4800      LDR         R0,=nStim ; nStim
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 59  

 00000698  6801      LDR         R1,[R0,#0x0] ; nStim
 0000069A  3101      ADD         R1,#0x1
 0000069C  6001      STR         R1,[R0,#0x0] ; nStim
  355:                 break;
 0000069E  E101      B           L_68  ; T=0x000008A4
  356:             case stimSnd2:  
 000006A0          L_75:
  357:                 stim[nStim].status    = statInit;
 000006A0  2001      MOV         R0,#0x1
 000006A2  4800      LDR         R1,=nStim ; nStim
 000006A4  680A      LDR         R2,[R1,#0x0] ; nStim
 000006A6  234C      MOV         R3,#0x4C
 000006A8  4353      MUL         R3,R2
 000006AA  4800      LDR         R1,=stim + 0x4 ; stim+4
 000006AC  50C8      STR         R0,[R1,R3]
  358:                 stim[nStim].kind      = stimSnd1;
 000006AE  200B      MOV         R0,#0xB
 000006B0  214C      MOV         R1,#0x4C
 000006B2  434A      MUL         R2,R1
 000006B4  4800      LDR         R1,=stim + 0x8 ; stim+8
 000006B6  5088      STR         R0,[R1,R2]
  359:                 stim[nStim].bitNo     = nBuffer[2];
 000006B8  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 000006BA  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 000006BC  4800      LDR         R1,=nStim ; nStim
 000006BE  680A      LDR         R2,[R1,#0x0] ; nStim
 000006C0  214C      MOV         R1,#0x4C
 000006C2  434A      MUL         R2,R1
 000006C4  4800      LDR         R1,=stim + 0x14 ; stim+20
 000006C6  5088      STR         R0,[R1,R2]
  360:                 stim[nStim].startRef  = nBuffer[3];
 000006C8  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 000006CA  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 000006CC  4800      LDR         R1,=nStim ; nStim
 000006CE  680A      LDR         R2,[R1,#0x0] ; nStim
 000006D0  214C      MOV         R1,#0x4C
 000006D2  434A      MUL         R2,R1
 000006D4  4800      LDR         R1,=stim + 0x24 ; stim+36
 000006D6  5088      STR         R0,[R1,R2]
  361:                 stim[nStim].startTime = nBuffer[4];
 000006D8  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 000006DA  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 000006DC  4800      LDR         R1,=nStim ; nStim
 000006DE  680A      LDR         R2,[R1,#0x0] ; nStim
 000006E0  214C      MOV         R1,#0x4C
 000006E2  434A      MUL         R2,R1
 000006E4  4800      LDR         R1,=stim + 0x28 ; stim+40
 000006E6  5088      STR         R0,[R1,R2]
  362:                 stim[nStim].stopRef   = nBuffer[5];
 000006E8  4800      LDR         R0,=nBuffer + 0x14 ; nBuffer+20
 000006EA  6800      LDR         R0,[R0,#0x0] ; nBuffer+20
 000006EC  4800      LDR         R1,=nStim ; nStim
 000006EE  680A      LDR         R2,[R1,#0x0] ; nStim
 000006F0  214C      MOV         R1,#0x4C
 000006F2  434A      MUL         R2,R1
 000006F4  4800      LDR         R1,=stim + 0x2C ; stim+44
 000006F6  5088      STR         R0,[R1,R2]
  363:                 stim[nStim].stopTime  = nBuffer[6];
 000006F8  4800      LDR         R0,=nBuffer + 0x18 ; nBuffer+24
 000006FA  6800      LDR         R0,[R0,#0x0] ; nBuffer+24
 000006FC  4800      LDR         R1,=nStim ; nStim
 000006FE  680A      LDR         R2,[R1,#0x0] ; nStim
 00000700  214C      MOV         R1,#0x4C
 00000702  434A      MUL         R2,R1
 00000704  4800      LDR         R1,=stim + 0x30 ; stim+48
 00000706  5088      STR         R0,[R1,R2]
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 60  

  364:                 stim[nStim].event     = nBuffer[7];
 00000708  4800      LDR         R0,=nBuffer + 0x1C ; nBuffer+28
 0000070A  6800      LDR         R0,[R0,#0x0] ; nBuffer+28
 0000070C  4800      LDR         R1,=nStim ; nStim
 0000070E  680A      LDR         R2,[R1,#0x0] ; nStim
 00000710  214C      MOV         R1,#0x4C
 00000712  434A      MUL         R2,R1
 00000714  4800      LDR         R1,=stim + 0x3C ; stim+60
 00000716  5088      STR         R0,[R1,R2]
  365:                 sndBit = (1 << (stim[nStim].bitNo-1));
 00000718  4800      LDR         R0,=nStim ; nStim
 0000071A  6801      LDR         R1,[R0,#0x0] ; nStim
 0000071C  204C      MOV         R0,#0x4C
 0000071E  4341      MUL         R1,R0
 00000720  4800      LDR         R0,=stim + 0x14 ; stim+20
 00000722  5840      LDR         R0,[R0,R1]
 00000724  3801      SUB         R0,#0x1
 00000726  2101      MOV         R1,#0x1
 00000728  4081      LSL         R1,R0
 0000072A  4800      LDR         R0,=sndBit ; sndBit
 0000072C  6001      STR         R1,[R0,#0x0] ; sndBit
  366:                 nStim++;
 0000072E  4800      LDR         R0,=nStim ; nStim
 00000730  6801      LDR         R1,[R0,#0x0] ; nStim
 00000732  3101      ADD         R1,#0x1
 00000734  6001      STR         R1,[R0,#0x0] ; nStim
  367:                 break;
 00000736  E0B5      B           L_68  ; T=0x000008A4
  368:             case stimFixWnd:
 00000738          L_77:
  369:                 stim[nStim].status    = statInit;
 00000738  2001      MOV         R0,#0x1
 0000073A  4800      LDR         R1,=nStim ; nStim
 0000073C  680A      LDR         R2,[R1,#0x0] ; nStim
 0000073E  234C      MOV         R3,#0x4C
 00000740  4353      MUL         R3,R2
 00000742  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000744  50C8      STR         R0,[R1,R3]
  370:                 stim[nStim].kind      = stimFixWnd;
 00000746  2011      MOV         R0,#0x11
 00000748  214C      MOV         R1,#0x4C
 0000074A  434A      MUL         R2,R1
 0000074C  4800      LDR         R1,=stim + 0x8 ; stim+8
 0000074E  5088      STR         R0,[R1,R2]
  371:                 stim[nStim].index     = nBuffer[ 2];
 00000750  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 00000752  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 00000754  4800      LDR         R1,=nStim ; nStim
 00000756  680A      LDR         R2,[R1,#0x0] ; nStim
 00000758  214C      MOV         R1,#0x4C
 0000075A  434A      MUL         R2,R1
 0000075C  4800      LDR         R1,=stim + 0xC ; stim+12
 0000075E  5088      STR         R0,[R1,R2]
  372:                 stim[nStim].posX      = nBuffer[ 3];
 00000760  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 00000762  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 00000764  4800      LDR         R1,=nStim ; nStim
 00000766  680A      LDR         R2,[R1,#0x0] ; nStim
 00000768  214C      MOV         R1,#0x4C
 0000076A  434A      MUL         R2,R1
 0000076C  4800      LDR         R1,=stim + 0x18 ; stim+24
 0000076E  5088      STR         R0,[R1,R2]
  373:                 stim[nStim].posY      = nBuffer[ 4];        
 00000770  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 00000772  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 00000774  4800      LDR         R1,=nStim ; nStim
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 61  

 00000776  680A      LDR         R2,[R1,#0x0] ; nStim
 00000778  214C      MOV         R1,#0x4C
 0000077A  434A      MUL         R2,R1
 0000077C  4800      LDR         R1,=stim + 0x1C ; stim+28
 0000077E  5088      STR         R0,[R1,R2]
  374:                 stim[nStim].winX      = nBuffer[ 5];
 00000780  4800      LDR         R0,=nBuffer + 0x14 ; nBuffer+20
 00000782  6800      LDR         R0,[R0,#0x0] ; nBuffer+20
 00000784  4800      LDR         R1,=nStim ; nStim
 00000786  680A      LDR         R2,[R1,#0x0] ; nStim
 00000788  214C      MOV         R1,#0x4C
 0000078A  434A      MUL         R2,R1
 0000078C  4800      LDR         R1,=stim + 0x44 ; stim+68
 0000078E  5088      STR         R0,[R1,R2]
  375:                 stim[nStim].winY      = nBuffer[ 6];        
 00000790  4800      LDR         R0,=nBuffer + 0x18 ; nBuffer+24
 00000792  6800      LDR         R0,[R0,#0x0] ; nBuffer+24
 00000794  4800      LDR         R1,=nStim ; nStim
 00000796  680A      LDR         R2,[R1,#0x0] ; nStim
 00000798  214C      MOV         R1,#0x4C
 0000079A  434A      MUL         R2,R1
 0000079C  4800      LDR         R1,=stim + 0x48 ; stim+72
 0000079E  5088      STR         R0,[R1,R2]
  376:                 stim[nStim].startRef  = nBuffer[ 7];
 000007A0  4800      LDR         R0,=nBuffer + 0x1C ; nBuffer+28
 000007A2  6800      LDR         R0,[R0,#0x0] ; nBuffer+28
 000007A4  4800      LDR         R1,=nStim ; nStim
 000007A6  680A      LDR         R2,[R1,#0x0] ; nStim
 000007A8  214C      MOV         R1,#0x4C
 000007AA  434A      MUL         R2,R1
 000007AC  4800      LDR         R1,=stim + 0x24 ; stim+36
 000007AE  5088      STR         R0,[R1,R2]
  377:                 stim[nStim].startTime = nBuffer[ 8];
 000007B0  4800      LDR         R0,=nBuffer + 0x20 ; nBuffer+32
 000007B2  6800      LDR         R0,[R0,#0x0] ; nBuffer+32
 000007B4  4800      LDR         R1,=nStim ; nStim
 000007B6  680A      LDR         R2,[R1,#0x0] ; nStim
 000007B8  214C      MOV         R1,#0x4C
 000007BA  434A      MUL         R2,R1
 000007BC  4800      LDR         R1,=stim + 0x28 ; stim+40
 000007BE  5088      STR         R0,[R1,R2]
  378:                 stim[nStim].stopRef   = nBuffer[ 9];
 000007C0  4800      LDR         R0,=nBuffer + 0x24 ; nBuffer+36
 000007C2  6800      LDR         R0,[R0,#0x0] ; nBuffer+36
 000007C4  4800      LDR         R1,=nStim ; nStim
 000007C6  680A      LDR         R2,[R1,#0x0] ; nStim
 000007C8  214C      MOV         R1,#0x4C
 000007CA  434A      MUL         R2,R1
 000007CC  4800      LDR         R1,=stim + 0x2C ; stim+44
 000007CE  5088      STR         R0,[R1,R2]
  379:                 stim[nStim].stopTime  = nBuffer[10];
 000007D0  4800      LDR         R0,=nBuffer + 0x28 ; nBuffer+40
 000007D2  6800      LDR         R0,[R0,#0x0] ; nBuffer+40
 000007D4  4800      LDR         R1,=nStim ; nStim
 000007D6  680A      LDR         R2,[R1,#0x0] ; nStim
 000007D8  214C      MOV         R1,#0x4C
 000007DA  434A      MUL         R2,R1
 000007DC  4800      LDR         R1,=stim + 0x30 ; stim+48
 000007DE  5088      STR         R0,[R1,R2]
  380:                 stim[nStim].delay     = nBuffer[11];
 000007E0  4800      LDR         R0,=nBuffer + 0x2C ; nBuffer+44
 000007E2  6800      LDR         R0,[R0,#0x0] ; nBuffer+44
 000007E4  4800      LDR         R1,=nStim ; nStim
 000007E6  680A      LDR         R2,[R1,#0x0] ; nStim
 000007E8  214C      MOV         R1,#0x4C
 000007EA  434A      MUL         R2,R1
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 62  

 000007EC  4800      LDR         R1,=stim + 0x38 ; stim+56
 000007EE  5088      STR         R0,[R1,R2]
  381:                 stim[nStim].event     = nBuffer[12]; 
 000007F0  4800      LDR         R0,=nBuffer + 0x30 ; nBuffer+48
 000007F2  6800      LDR         R0,[R0,#0x0] ; nBuffer+48
 000007F4  4800      LDR         R1,=nStim ; nStim
 000007F6  680A      LDR         R2,[R1,#0x0] ; nStim
 000007F8  214C      MOV         R1,#0x4C
 000007FA  434A      MUL         R2,R1
 000007FC  4800      LDR         R1,=stim + 0x3C ; stim+60
 000007FE  5088      STR         R0,[R1,R2]
  382:                 nStim++;                            
 00000800  4800      LDR         R0,=nStim ; nStim
 00000802  6801      LDR         R1,[R0,#0x0] ; nStim
 00000804  3101      ADD         R1,#0x1
 00000806  6001      STR         R1,[R0,#0x0] ; nStim
  383:                 break;
 00000808  E04C      B           L_68  ; T=0x000008A4
  384:             case stimSpeed:
 0000080A          L_78:
  385:                 stim[nStim].status    = statInit;
 0000080A  2001      MOV         R0,#0x1
 0000080C  4800      LDR         R1,=nStim ; nStim
 0000080E  680A      LDR         R2,[R1,#0x0] ; nStim
 00000810  234C      MOV         R3,#0x4C
 00000812  4353      MUL         R3,R2
 00000814  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000816  50C8      STR         R0,[R1,R3]
  386:                 stim[nStim].kind      = stimSpeed;
 00000818  2012      MOV         R0,#0x12
 0000081A  214C      MOV         R1,#0x4C
 0000081C  434A      MUL         R2,R1
 0000081E  4800      LDR         R1,=stim + 0x8 ; stim+8
 00000820  5088      STR         R0,[R1,R2]
  387:                 stim[nStim].mode      = nBuffer[ 2];  // matlab numbering
 00000822  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 00000824  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 00000826  4800      LDR         R1,=nStim ; nStim
 00000828  680A      LDR         R2,[R1,#0x0] ; nStim
 0000082A  214C      MOV         R1,#0x4C
 0000082C  434A      MUL         R2,R1
 0000082E  4800      LDR         R1,=stim + 0x40 ; stim+64
 00000830  5088      STR         R0,[R1,R2]
  391:                 stim[nStim].posX      = nBuffer[ 3];  // target 
 00000832  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 00000834  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 00000836  4800      LDR         R1,=nStim ; nStim
 00000838  680A      LDR         R2,[R1,#0x0] ; nStim
 0000083A  214C      MOV         R1,#0x4C
 0000083C  434A      MUL         R2,R1
 0000083E  4800      LDR         R1,=stim + 0x18 ; stim+24
 00000840  5088      STR         R0,[R1,R2]
  392:                 stim[nStim].posY      = nBuffer[ 4];        
 00000842  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 00000844  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 00000846  4800      LDR         R1,=nStim ; nStim
 00000848  680A      LDR         R2,[R1,#0x0] ; nStim
 0000084A  214C      MOV         R1,#0x4C
 0000084C  434A      MUL         R2,R1
 0000084E  4800      LDR         R1,=stim + 0x1C ; stim+28
 00000850  5088      STR         R0,[R1,R2]
  393:                 stim[nStim].startRef  = nBuffer[ 5];
 00000852  4800      LDR         R0,=nBuffer + 0x14 ; nBuffer+20
 00000854  6800      LDR         R0,[R0,#0x0] ; nBuffer+20
 00000856  4800      LDR         R1,=nStim ; nStim
 00000858  680A      LDR         R2,[R1,#0x0] ; nStim
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 63  

 0000085A  214C      MOV         R1,#0x4C
 0000085C  434A      MUL         R2,R1
 0000085E  4800      LDR         R1,=stim + 0x24 ; stim+36
 00000860  5088      STR         R0,[R1,R2]
  394:                 stim[nStim].startTime = nBuffer[ 6];
 00000862  4800      LDR         R0,=nBuffer + 0x18 ; nBuffer+24
 00000864  6800      LDR         R0,[R0,#0x0] ; nBuffer+24
 00000866  4800      LDR         R1,=nStim ; nStim
 00000868  680A      LDR         R2,[R1,#0x0] ; nStim
 0000086A  214C      MOV         R1,#0x4C
 0000086C  434A      MUL         R2,R1
 0000086E  4800      LDR         R1,=stim + 0x28 ; stim+40
 00000870  5088      STR         R0,[R1,R2]
  395:                 stim[nStim].stopRef   = nBuffer[ 7];
 00000872  4800      LDR         R0,=nBuffer + 0x1C ; nBuffer+28
 00000874  6800      LDR         R0,[R0,#0x0] ; nBuffer+28
 00000876  4800      LDR         R1,=nStim ; nStim
 00000878  680A      LDR         R2,[R1,#0x0] ; nStim
 0000087A  214C      MOV         R1,#0x4C
 0000087C  434A      MUL         R2,R1
 0000087E  4800      LDR         R1,=stim + 0x2C ; stim+44
 00000880  5088      STR         R0,[R1,R2]
  396:                 stim[nStim].stopTime  = nBuffer[ 8];
 00000882  4800      LDR         R0,=nBuffer + 0x20 ; nBuffer+32
 00000884  6800      LDR         R0,[R0,#0x0] ; nBuffer+32
 00000886  4800      LDR         R1,=nStim ; nStim
 00000888  680A      LDR         R2,[R1,#0x0] ; nStim
 0000088A  214C      MOV         R1,#0x4C
 0000088C  434A      MUL         R2,R1
 0000088E  4800      LDR         R1,=stim + 0x30 ; stim+48
 00000890  5088      STR         R0,[R1,R2]
  397:                 stim[nStim].level     = nBuffer[ 9];  // velocity
 00000892  4800      LDR         R0,=nBuffer + 0x24 ; nBuffer+36
 00000894  6800      LDR         R0,[R0,#0x0] ; nBuffer+36
 00000896  4800      LDR         R1,=nStim ; nStim
 00000898  680A      LDR         R2,[R1,#0x0] ; nStim
 0000089A  214C      MOV         R1,#0x4C
 0000089C  434A      MUL         R2,R1
 0000089E  4800      LDR         R1,=stim + 0x20 ; stim+32
 000008A0  5088      STR         R0,[R1,R2]
  398:                 stim[nStim].event     = nBuffer[10];
 000008A2  4800      LDR         R0,=nBuffer + 0x28 ; nBuffer+40
 000008A4  6800      LDR         R0,[R0,#0x0] ; nBuffer+40
 000008A6  4800      LDR         R1,=nStim ; nStim
 000008A8  680A      LDR         R2,[R1,#0x0] ; nStim
 000008AA  214C      MOV         R1,#0x4C
 000008AC  434A      MUL         R2,R1
 000008AE  4800      LDR         R1,=stim + 0x3C ; stim+60
 000008B0  5088      STR         R0,[R1,R2]
  399:                 nStim++;                             
 000008B2  4800      LDR         R0,=nStim ; nStim
 000008B4  6801      LDR         R1,[R0,#0x0] ; nStim
 000008B6  3101      ADD         R1,#0x1
 000008B8  6001      STR         R1,[R0,#0x0] ; nStim
  401:             }
 000008BA          L_68:
  403:             if (flag == true)
 000008BA  9804      LDR         R0,[R13,#0x10] ; flag
 000008BC  2801      CMP         R0,#0x1
 000008BE  D103      BNE         L_79  ; T=0x000008C8
  405:                 n = sprintf(outBuf,"%d\n",curTime);
 000008C0  4800      LDR         R0,=outBuf ; outBuf
 000008C2  4800      LDR         R1,=??S_5 ; ??S_5
 000008C4  4800      LDR         R2,=curTime ; curTime
 000008C6  6812      LDR         R2,[R2,#0x0] ; curTime
 000008C8  F7FF      BL          sprintf?T  ; T=0x0001  (1)
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 64  

 000008CA  FB9A      BL          sprintf?T  ; T=0x0001  (2)
 000008CC  1C05      MOV         R5,R0 ; n
  406:                 i = UART0_Str(outBuf, n);
 000008CE  4800      LDR         R0,=outBuf ; outBuf
 000008D0  1C29      MOV         R1,R5
 000008D2  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 000008D4  FB95      BL          UART0_Str?T  ; T=0x0001  (2)
 000008D6  1C04      MOV         R4,R0 ; i
  407:                 nBuffer[1] = 0;
 000008D8  2100      MOV         R1,#0x0
 000008DA  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 000008DC  6001      STR         R1,[R0,#0x0] ; nBuffer+4
  408:             }
 000008DE          L_79:
  409:             EOL = false;
 000008DE  2000      MOV         R0,#0x0
 000008E0  9002      STR         R0,[R13,#0x8] ; EOL
  410:             num = 0;
 000008E2  2000      MOV         R0,#0x0
 000008E4  9001      STR         R0,[R13,#0x4] ; num
  411:         }
 000008E6          L_61:
  413:         curTime = Clock_GetTicks();
 000008E6  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 000008E8  FB8B      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 000008EA  4800      LDR         R1,=curTime ; curTime
 000008EC  6008      STR         R0,[R1,#0x0] ; curTime
  414:         seconds = Clock_GetSeconds();
 000008EE  F7FF      BL          Clock_GetSeconds?T  ; T=0x0001  (1)
 000008F0  FB87      BL          Clock_GetSeconds?T  ; T=0x0001  (2)
 000008F2  4800      LDR         R1,=seconds ; seconds
 000008F4  6008      STR         R0,[R1,#0x0] ; seconds
  415:         ticks   = curTime;
 000008F6  4800      LDR         R0,=curTime ; curTime
 000008F8  6801      LDR         R1,[R0,#0x0] ; curTime
 000008FA  4800      LDR         R0,=ticks ; ticks
 000008FC  6001      STR         R1,[R0,#0x0] ; ticks
  416:         parInp  = GetBitsPar();
 000008FE  F7FF      BL          GetBitsPar?T  ; T=0x0001  (1)
 00000900  FB7F      BL          GetBitsPar?T  ; T=0x0001  (2)
 00000902  4800      LDR         R1,=parInp ; parInp
 00000904  6008      STR         R0,[R1,#0x0] ; parInp
  418:         if (MCS == statRunTrial)
 00000906  4800      LDR         R0,=MCS ; MCS
 00000908  6800      LDR         R0,[R0,#0x0] ; MCS
 0000090A  2803      CMP         R0,#0x3
 0000090C  D000      BNE         $+4
 0000090E  E10C      B           L_80  ; T=0x00000B2A
  420:             if (EOL == true)
 00000912  9802      LDR         R0,[R13,#0x8] ; EOL
 00000914  2801      CMP         R0,#0x1
 00000916  D12B      BNE         L_81  ; T=0x00000970
  422:                 switch(nBuffer[1])
 00000918  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 0000091A  6800      LDR         R0,[R0,#0x0] ; nBuffer+4
 0000091C  2869      CMP         R0,#0x69
 0000091E  D00E      BEQ         L_83  ; T=0x0000093E
 00000920  286B      CMP         R0,#0x6B
 00000922  D006      BEQ         L_84  ; T=0x00000932
 00000924  286F      CMP         R0,#0x6F
 00000926  D007      BEQ         L_85  ; T=0x00000938
 00000928  2870      CMP         R0,#0x70
 0000092A  D00E      BEQ         L_86  ; T=0x0000094A
 0000092C  2872      CMP         R0,#0x72
 0000092E  D012      BEQ         L_87  ; T=0x00000956
 00000930  2876      CMP         R0,#0x76
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 65  

 00000932  D007      BEQ         L_89  ; T=0x00000944
 00000934  2878      CMP         R0,#0x78
 00000936  D00B      BEQ         L_90  ; T=0x00000950
 00000938  287B      CMP         R0,#0x7B
 0000093A  D012      BEQ         L_91  ; T=0x00000962
 0000093C  287D      CMP         R0,#0x7D
 0000093E  D00D      BEQ         L_92  ; T=0x0000095C
 00000940  2875      CMP         R0,#0x75
 00000942  D111      BNE         L_82  ; T=0x00000968
  424:                 case cmdBar:    getBarState();  break;
 00000944          L_88:
 00000944  F7FF      BL          getBarState?T  ; T=0x0001  (1)
 00000946  FB5C      BL          getBarState?T  ; T=0x0001  (2)
 00000948  E00E      B           L_82  ; T=0x00000968
  425:                 case cmdState:  getState();     break;
 0000094A          L_84:
 0000094A  F7FF      BL          getState?T  ; T=0x0001  (1)
 0000094C  FB59      BL          getState?T  ; T=0x0001  (2)
 0000094E  E00B      B           L_82  ; T=0x00000968
  426:                 case cmdStateTrial: getStateTrial(); break;
 00000950          L_85:
 00000950  F7FF      BL          getStateTrial?T  ; T=0x0001  (1)
 00000952  FB56      BL          getStateTrial?T  ; T=0x0001  (2)
 00000954  E008      B           L_82  ; T=0x00000968
  427:                 case cmdClock:  getClock();     break;
 00000956          L_83:
 00000956  F7FF      BL          getClock?T  ; T=0x0001  (1)
 00000958  FB53      BL          getClock?T  ; T=0x0001  (2)
 0000095A  E005      B           L_82  ; T=0x00000968
  428:                 case cmdADC:    getADC();       break;
 0000095C          L_89:
 0000095C  F7FF      BL          getADC?T  ; T=0x0001  (1)
 0000095E  FB50      BL          getADC?T  ; T=0x0001  (2)
 00000960  E002      B           L_82  ; T=0x00000968
  429:                 case cmdReset:  execReset();    break;
 00000962          L_86:
 00000962  F7FF      BL          execReset?T  ; T=0x0001  (1)
 00000964  FB4D      BL          execReset?T  ; T=0x0001  (2)
 00000966  E7FF      B           L_82  ; T=0x00000968
  430:                 case cmdPin:    getPIO();       break;
 00000968          L_90:
 00000968  F7FF      BL          getPIO?T  ; T=0x0001  (1)
 0000096A  FB4A      BL          getPIO?T  ; T=0x0001  (2)
 0000096C  E7FC      B           L_82  ; T=0x00000968
  431:                 case cmdAbort:  execAbort();    break;
 0000096E          L_87:
 0000096E  F7FF      BL          execAbort?T  ; T=0x0001  (1)
 00000970  FB47      BL          execAbort?T  ; T=0x0001  (2)
 00000972  E7F9      B           L_82  ; T=0x00000968
  432:                 case cmdSpeed:  getSpeed();     break;
 00000974          L_92:
 00000974  F7FF      BL          getSpeed?T  ; T=0x0001  (1)
 00000976  FB44      BL          getSpeed?T  ; T=0x0001  (2)
 00000978  E7F6      B           L_82  ; T=0x00000968
  433:                 case cmdNNSim:  simulateNN(-1); break;
 0000097A          L_91:
 0000097A  4800      LDR         R0,=0xFFFFFFFF
 0000097C  F7FF      BL          simulateNN?T  ; T=0x0001  (1)
 0000097E  FB40      BL          simulateNN?T  ; T=0x0001  (2)
  434:                 }
 00000980          L_82:
  435:                 EOL = false;
 00000980  2000      MOV         R0,#0x0
 00000982  9002      STR         R0,[R13,#0x8] ; EOL
  436:                 num = 0;
 00000984  2000      MOV         R0,#0x0
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 66  

 00000986  9001      STR         R0,[R13,#0x4] ; num
  437:             }
 00000988          L_81:
  438:             done = 0;
 00000988  2700      MOV         R7,#0x0
  439:             n = 0;
 0000098A  2500      MOV         R5,#0x0
  440:             state[n] = CR[0];
 0000098C  A805      ADD         R0,R13,#0x14
 0000098E  7800      LDRB        R0,[R0,#0x0] ; CR
 00000990  4800      LDR         R1,=state ; state
 00000992  5548      STRB        R0,[R1,R5]
  441:             curTime = Clock_GetTicks() - T_start;
 00000994  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000996  FB34      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000998  4800      LDR         R1,=T_start ; T_start
 0000099A  680A      LDR         R2,[R1,#0x0] ; T_start
 0000099C  1A81      SUB         R1,R0,R2 ; Clock_GetTicks?T
 0000099E  4800      LDR         R0,=curTime ; curTime
 000009A0  6001      STR         R1,[R0,#0x0] ; curTime
  442:             for (i = 0; i < nStim; i++)
 000009A2  2400      MOV         R4,#0x0
 000009A4  E08E      B           L_95  ; T=0x00000AC4
 000009A6          L_96:
  444:                 switch(stim[i].kind)
 000009A6  214C      MOV         R1,#0x4C
 000009A8  4361      MUL         R1,R4 ; i
 000009AA  4800      LDR         R0,=stim + 0x8 ; stim+8
 000009AC  5840      LDR         R0,[R0,R1]
 000009AE  2804      CMP         R0,#0x4
 000009B0  D016      BEQ         L_100  ; T=0x000009E0
 000009B2  2805      CMP         R0,#0x5
 000009B4  D020      BEQ         L_101  ; T=0x000009F8
 000009B6  2809      CMP         R0,#0x9
 000009B8  D036      BEQ         L_102  ; T=0x00000A28
 000009BA  280A      CMP         R0,#0xA
 000009BC  D028      BEQ         L_103  ; T=0x00000A10
 000009BE  280B      CMP         R0,#0xB
 000009C0  D100      BEQ         $+4
 000009C2  E049      B           L_104  ; T=0x00000A58
 000009C6  280C      CMP         R0,#0xC
 000009C8  D100      BEQ         $+4
 000009CA  E051      B           L_105  ; T=0x00000A70
 000009CE  280F      CMP         R0,#0xF
 000009D0  D036      BEQ         L_106  ; T=0x00000A40
 000009D2  2811      CMP         R0,#0x11
 000009D4  D100      BEQ         $+4
 000009D6  E057      B           L_107  ; T=0x00000A88
 000009DA  2812      CMP         R0,#0x12
 000009DC  D100      BEQ         $+4
 000009DE  E05F      B           L_108  ; T=0x00000AA0
 000009E2  2803      CMP         R0,#0x3
 000009E4  D000      BNE         $+4
 000009E6  E066      B           L_98  ; T=0x00000AB6
  446:                     case stimBar:    m = execBar(i);    state[n++] = NUMBERS[m]; done += m; break;
 000009EA          L_99:
 000009EA  1C20      MOV         R0,R4
 000009EC  F7FF      BL          execBar?T  ; T=0x0001  (1)
 000009EE  FB08      BL          execBar?T  ; T=0x0001  (2)
 000009F0  1C06      MOV         R6,R0 ; m
 000009F2  A807      ADD         R0,R13,#0x1C
 000009F4  5D80      LDRB        R0,[R0,R6]
 000009F6  1C2A      MOV         R2,R5 ; n
 000009F8  3501      ADD         R5,#0x1
 000009FA  4800      LDR         R1,=state ; state
 000009FC  5488      STRB        R0,[R1,R2]
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 67  

 000009FE  19BF      ADD         R7,R6 ; done
 00000A00  E059      B           L_98  ; T=0x00000AB6
  447:                     case stimSky:    m = execSky(i);    state[n++] = NUMBERS[m]; done += m; break;
 00000A02          L_100:
 00000A02  1C20      MOV         R0,R4
 00000A04  F7FF      BL          execSky?T  ; T=0x0001  (1)
 00000A06  FAFC      BL          execSky?T  ; T=0x0001  (2)
 00000A08  1C06      MOV         R6,R0 ; m
 00000A0A  A807      ADD         R0,R13,#0x1C
 00000A0C  5D80      LDRB        R0,[R0,R6]
 00000A0E  1C2A      MOV         R2,R5 ; n
 00000A10  3501      ADD         R5,#0x1
 00000A12  4800      LDR         R1,=state ; state
 00000A14  5488      STRB        R0,[R1,R2]
 00000A16  19BF      ADD         R7,R6 ; done
 00000A18  E04D      B           L_98  ; T=0x00000AB6
  448:                     case stimLed:    m = execLed(i);    state[n++] = NUMBERS[m]; done += m; break;
 00000A1A          L_101:
 00000A1A  1C20      MOV         R0,R4
 00000A1C  F7FF      BL          execLed?T  ; T=0x0001  (1)
 00000A1E  FAF0      BL          execLed?T  ; T=0x0001  (2)
 00000A20  1C06      MOV         R6,R0 ; m
 00000A22  A807      ADD         R0,R13,#0x1C
 00000A24  5D80      LDRB        R0,[R0,R6]
 00000A26  1C2A      MOV         R2,R5 ; n
 00000A28  3501      ADD         R5,#0x1
 00000A2A  4800      LDR         R1,=state ; state
 00000A2C  5488      STRB        R0,[R1,R2]
 00000A2E  19BF      ADD         R7,R6 ; done
 00000A30  E041      B           L_98  ; T=0x00000AB6
  449:                     case stimRec:    m = execRec(i);    state[n++] = NUMBERS[m]; done += m; break;
 00000A32          L_103:
 00000A32  1C20      MOV         R0,R4
 00000A34  F7FF      BL          execRec?T  ; T=0x0001  (1)
 00000A36  FAE4      BL          execRec?T  ; T=0x0001  (2)
 00000A38  1C06      MOV         R6,R0 ; m
 00000A3A  A807      ADD         R0,R13,#0x1C
 00000A3C  5D80      LDRB        R0,[R0,R6]
 00000A3E  1C2A      MOV         R2,R5 ; n
 00000A40  3501      ADD         R5,#0x1
 00000A42  4800      LDR         R1,=state ; state
 00000A44  5488      STRB        R0,[R1,R2]
 00000A46  19BF      ADD         R7,R6 ; done
 00000A48  E035      B           L_98  ; T=0x00000AB6
  450:                     case stimRew:    m = execRew(i);    state[n++] = NUMBERS[m]; done += m; break; 
 00000A4A          L_102:
 00000A4A  1C20      MOV         R0,R4
 00000A4C  F7FF      BL          execRew?T  ; T=0x0001  (1)
 00000A4E  FAD8      BL          execRew?T  ; T=0x0001  (2)
 00000A50  1C06      MOV         R6,R0 ; m
 00000A52  A807      ADD         R0,R13,#0x1C
 00000A54  5D80      LDRB        R0,[R0,R6]
 00000A56  1C2A      MOV         R2,R5 ; n
 00000A58  3501      ADD         R5,#0x1
 00000A5A  4800      LDR         R1,=state ; state
 00000A5C  5488      STRB        R0,[R1,R2]
 00000A5E  19BF      ADD         R7,R6 ; done
 00000A60  E029      B           L_98  ; T=0x00000AB6
  451:                     case stimLas:    m = execLas(i);    state[n++] = NUMBERS[m]; done += m; break; 
 00000A62          L_106:
 00000A62  1C20      MOV         R0,R4
 00000A64  F7FF      BL          execLas?T  ; T=0x0001  (1)
 00000A66  FACC      BL          execLas?T  ; T=0x0001  (2)
 00000A68  1C06      MOV         R6,R0 ; m
 00000A6A  A807      ADD         R0,R13,#0x1C
 00000A6C  5D80      LDRB        R0,[R0,R6]
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 68  

 00000A6E  1C2A      MOV         R2,R5 ; n
 00000A70  3501      ADD         R5,#0x1
 00000A72  4800      LDR         R1,=state ; state
 00000A74  5488      STRB        R0,[R1,R2]
 00000A76  19BF      ADD         R7,R6 ; done
 00000A78  E01D      B           L_98  ; T=0x00000AB6
  452:                     case stimSnd1:   m = execSnd(i);    state[n++] = NUMBERS[m]; done += m; break; 
 00000A7A          L_104:
 00000A7A  1C20      MOV         R0,R4
 00000A7C  F7FF      BL          execSnd?T  ; T=0x0001  (1)
 00000A7E  FAC0      BL          execSnd?T  ; T=0x0001  (2)
 00000A80  1C06      MOV         R6,R0 ; m
 00000A82  A807      ADD         R0,R13,#0x1C
 00000A84  5D80      LDRB        R0,[R0,R6]
 00000A86  1C2A      MOV         R2,R5 ; n
 00000A88  3501      ADD         R5,#0x1
 00000A8A  4800      LDR         R1,=state ; state
 00000A8C  5488      STRB        R0,[R1,R2]
 00000A8E  19BF      ADD         R7,R6 ; done
 00000A90  E011      B           L_98  ; T=0x00000AB6
  453:                     case stimSnd2:   m = execSnd(i);    state[n++] = NUMBERS[m]; done += m; break; 
 00000A92          L_105:
 00000A92  1C20      MOV         R0,R4
 00000A94  F7FF      BL          execSnd?T  ; T=0x0001  (1)
 00000A96  FAB4      BL          execSnd?T  ; T=0x0001  (2)
 00000A98  1C06      MOV         R6,R0 ; m
 00000A9A  A807      ADD         R0,R13,#0x1C
 00000A9C  5D80      LDRB        R0,[R0,R6]
 00000A9E  1C2A      MOV         R2,R5 ; n
 00000AA0  3501      ADD         R5,#0x1
 00000AA2  4800      LDR         R1,=state ; state
 00000AA4  5488      STRB        R0,[R1,R2]
 00000AA6  19BF      ADD         R7,R6 ; done
 00000AA8  E005      B           L_98  ; T=0x00000AB6
  454:                     case stimFixWnd: m = execFixWnd(i); state[n++] = NUMBERS[m]; done += m; break; 
 00000AAA          L_107:
 00000AAA  1C20      MOV         R0,R4
 00000AAC  F7FF      BL          execFixWnd?T  ; T=0x0001  (1)
 00000AAE  FAA8      BL          execFixWnd?T  ; T=0x0001  (2)
 00000AB0  1C06      MOV         R6,R0 ; m
 00000AB2  A807      ADD         R0,R13,#0x1C
 00000AB4  5D80      LDRB        R0,[R0,R6]
 00000AB6  1C2A      MOV         R2,R5 ; n
 00000AB8  3501      ADD         R5,#0x1
 00000ABA  4800      LDR         R1,=state ; state
 00000ABC  5488      STRB        R0,[R1,R2]
 00000ABE  19BF      ADD         R7,R6 ; done
 00000AC0  E7F9      B           L_98  ; T=0x00000AB6
  455:                     case stimSpeed:  m = execSpeed(i);  state[n++] = NUMBERS[m]; done += m; break; 
 00000AC2          L_108:
 00000AC2  1C20      MOV         R0,R4
 00000AC4  F7FF      BL          execSpeed?T  ; T=0x0001  (1)
 00000AC6  FA9C      BL          execSpeed?T  ; T=0x0001  (2)
 00000AC8  1C06      MOV         R6,R0 ; m
 00000ACA  A807      ADD         R0,R13,#0x1C
 00000ACC  5D80      LDRB        R0,[R0,R6]
 00000ACE  1C2A      MOV         R2,R5 ; n
 00000AD0  3501      ADD         R5,#0x1
 00000AD2  4800      LDR         R1,=state ; state
 00000AD4  5488      STRB        R0,[R1,R2]
 00000AD6  19BF      ADD         R7,R6 ; done
  456:                 }
 00000AD8          L_98:
  457:                 state[n++] = SP[0];
 00000AD8  A806      ADD         R0,R13,#0x18
 00000ADA  7800      LDRB        R0,[R0,#0x0] ; SP
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 69  

 00000ADC  1C2A      MOV         R2,R5 ; n
 00000ADE  3501      ADD         R5,#0x1
 00000AE0  4800      LDR         R1,=state ; state
 00000AE2  5488      STRB        R0,[R1,R2]
  458:             }
 00000AE4  3401      ADD         R4,#0x1
 00000AE6          L_95:
 00000AE6  4800      LDR         R0,=nStim ; nStim
 00000AE8  6800      LDR         R0,[R0,#0x0] ; nStim
 00000AEA  4284      CMP         R4,R0 ; i
 00000AEC  DA00      BLT         $+4
 00000AEE  E75A      B           L_96  ; T=0x000009A6
  459:             state[n++] = CR[0]; 
 00000AF2  A805      ADD         R0,R13,#0x14
 00000AF4  7800      LDRB        R0,[R0,#0x0] ; CR
 00000AF6  1C2A      MOV         R2,R5 ; n
 00000AF8  3501      ADD         R5,#0x1
 00000AFA  4800      LDR         R1,=state ; state
 00000AFC  5488      STRB        R0,[R1,R2]
  460:             state[n] = 0;
 00000AFE  2000      MOV         R0,#0x0
 00000B00  4800      LDR         R1,=state ; state
 00000B02  5548      STRB        R0,[R1,R5]
  461:             if (done == 0)
 00000B04  2F00      CMP         R7,#0x0 ; done
 00000B06  D110      BNE         L_80  ; T=0x00000B2A
  463:                 if (errFlag == false)
 00000B08  4800      LDR         R0,=errFlag ; errFlag
 00000B0A  6800      LDR         R0,[R0,#0x0] ; errFlag
 00000B0C  2800      CMP         R0,#0x0
 00000B0E  D1FC      BNE         L_110  ; T=0x00000B0A
  465:                     MCS = statDoneTrial;
 00000B10  2104      MOV         R1,#0x4
 00000B12  4800      LDR         R0,=MCS ; MCS
 00000B14  6001      STR         R1,[R0,#0x0] ; MCS
  466:                     T_done  = Clock_GetTicks();
 00000B16  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000B18  FA73      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000B1A  4800      LDR         R1,=T_done ; T_done
 00000B1C  6008      STR         R0,[R1,#0x0] ; T_done
  467:                     T_trial = T_done - T_start;
 00000B1E  4800      LDR         R0,=T_start ; T_start
 00000B20  6800      LDR         R0,[R0,#0x0] ; T_start
 00000B22  4800      LDR         R1,=T_done ; T_done
 00000B24  6809      LDR         R1,[R1,#0x0] ; T_done
 00000B26  1A09      SUB         R1,R0
 00000B28  4800      LDR         R0,=T_trial ; T_trial
 00000B2A  6001      STR         R1,[R0,#0x0] ; T_trial
  468:                 }
 00000B2C  E7FD      B           L_80  ; T=0x00000B2A
 00000B2E          L_110:
  471:                     MCS = statDoneTrial;
 00000B2E  2104      MOV         R1,#0x4
 00000B30  4800      LDR         R0,=MCS ; MCS
 00000B32  6001      STR         R1,[R0,#0x0] ; MCS
  472:                     T_done  = Clock_GetTicks();
 00000B34  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000B36  FA64      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000B38  4800      LDR         R1,=T_done ; T_done
 00000B3A  6008      STR         R0,[R1,#0x0] ; T_done
  473:                     T_trial = -1*(T_done - T_start);
 00000B3C  4800      LDR         R0,=T_start ; T_start
 00000B3E  6800      LDR         R0,[R0,#0x0] ; T_start
 00000B40  4800      LDR         R1,=T_done ; T_done
 00000B42  6809      LDR         R1,[R1,#0x0] ; T_done
 00000B44  1A09      SUB         R1,R0
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 70  

 00000B46  4800      LDR         R0,=0xFFFFFFFF
 00000B48  4341      MUL         R1,R0
 00000B4A  4800      LDR         R0,=T_trial ; T_trial
 00000B4C  6001      STR         R1,[R0,#0x0] ; T_trial
  477:         }
 00000B4E          L_80:
  479:         if (MCS == statDoneTrial)
 00000B4E  4800      LDR         R0,=MCS ; MCS
 00000B50  6800      LDR         R0,[R0,#0x0] ; MCS
 00000B52  2804      CMP         R0,#0x4
 00000B54  D000      BNE         $+4
 00000B56  E028      B           L_112  ; T=0x00000BAA
  481:             if (EOL == true)
 00000B5A  9802      LDR         R0,[R13,#0x8] ; EOL
 00000B5C  2801      CMP         R0,#0x1
 00000B5E  D000      BNE         $+4
 00000B60  E023      B           L_112  ; T=0x00000BAA
  483:                 switch(nBuffer[1])
 00000B64  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 00000B66  6800      LDR         R0,[R0,#0x0] ; nBuffer+4
 00000B68  2869      CMP         R0,#0x69
 00000B6A  D009      BEQ         L_116  ; T=0x00000B80
 00000B6C  286B      CMP         R0,#0x6B
 00000B6E  D0FE      BEQ         L_117  ; T=0x00000B6E
 00000B70  286E      CMP         R0,#0x6E
 00000B72  D008      BEQ         L_118  ; T=0x00000B86
 00000B74  286F      CMP         R0,#0x6F
 00000B76  D0FD      BEQ         L_119  ; T=0x00000B74
 00000B78  2870      CMP         R0,#0x70
 00000B7A  D00A      BEQ         L_120  ; T=0x00000B92
 00000B7C  2872      CMP         R0,#0x72
 00000B7E  D00E      BEQ         L_121  ; T=0x00000B9E
 00000B80  2875      CMP         R0,#0x75
 00000B82  D0FA      BEQ         L_122  ; T=0x00000B7A
 00000B84  2876      CMP         R0,#0x76
 00000B86  D001      BEQ         L_123  ; T=0x00000B8C
 00000B88  2878      CMP         R0,#0x78
 00000B8A  D005      BEQ         L_124  ; T=0x00000B98
 00000B8C  2865      CMP         R0,#0x65
 00000B8E  D108      BNE         L_114  ; T=0x00000BA2
  485:                 case cmdInit:   execInit();     break;
 00000B90          L_115:
 00000B90  F7FF      BL          execInit?T  ; T=0x0001  (1)
 00000B92  FA36      BL          execInit?T  ; T=0x0001  (2)
 00000B94  E005      B           L_114  ; T=0x00000BA2
  486:                 case cmdState:  getState();     break;
 00000B96          L_117:
 00000B96  F7FF      BL          getState?T  ; T=0x0001  (1)
 00000B98  FA33      BL          getState?T  ; T=0x0001  (2)
 00000B9A  E002      B           L_114  ; T=0x00000BA2
  487:                 case cmdStateTrial: getStateTrial();break;
 00000B9C          L_119:
 00000B9C  F7FF      BL          getStateTrial?T  ; T=0x0001  (1)
 00000B9E  FA30      BL          getStateTrial?T  ; T=0x0001  (2)
 00000BA0  E7FF      B           L_114  ; T=0x00000BA2
  488:                 case cmdBar:    getBarState();  break;
 00000BA2          L_122:
 00000BA2  F7FF      BL          getBarState?T  ; T=0x0001  (1)
 00000BA4  FA2D      BL          getBarState?T  ; T=0x0001  (2)
 00000BA6  E7FC      B           L_114  ; T=0x00000BA2
  489:                 case cmdClock:  getClock();     break;
 00000BA8          L_116:
 00000BA8  F7FF      BL          getClock?T  ; T=0x0001  (1)
 00000BAA  FA2A      BL          getClock?T  ; T=0x0001  (2)
 00000BAC  E7F9      B           L_114  ; T=0x00000BA2
  490:                 case cmdSaveTrial:  execSaveTrial();break;
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 71  

 00000BAE          L_118:
 00000BAE  F7FF      BL          execSaveTrial?T  ; T=0x0001  (1)
 00000BB0  FA27      BL          execSaveTrial?T  ; T=0x0001  (2)
 00000BB2  E7F6      B           L_114  ; T=0x00000BA2
  491:                 case cmdADC:    getADC();       break;      
 00000BB4          L_123:
 00000BB4  F7FF      BL          getADC?T  ; T=0x0001  (1)
 00000BB6  FA24      BL          getADC?T  ; T=0x0001  (2)
 00000BB8  E7F3      B           L_114  ; T=0x00000BA2
  492:                 case cmdReset:  execReset();    break;
 00000BBA          L_120:
 00000BBA  F7FF      BL          execReset?T  ; T=0x0001  (1)
 00000BBC  FA21      BL          execReset?T  ; T=0x0001  (2)
 00000BBE  E7F0      B           L_114  ; T=0x00000BA2
  493:                 case cmdPin:    getPIO();       break;
 00000BC0          L_124:
 00000BC0  F7FF      BL          getPIO?T  ; T=0x0001  (1)
 00000BC2  FA1E      BL          getPIO?T  ; T=0x0001  (2)
 00000BC4  E7ED      B           L_114  ; T=0x00000BA2
  494:                 case cmdAbort:  execAbort();    break;
 00000BC6          L_121:
 00000BC6  F7FF      BL          execAbort?T  ; T=0x0001  (1)
 00000BC8  FA1B      BL          execAbort?T  ; T=0x0001  (2)
  495:                 }
 00000BCA          L_114:
  496:                 EOL = false;
 00000BCA  2000      MOV         R0,#0x0
 00000BCC  9002      STR         R0,[R13,#0x8] ; EOL
  497:                 num = 0;
 00000BCE  2000      MOV         R0,#0x0
 00000BD0  9001      STR         R0,[R13,#0x4] ; num
  499:         }
 00000BD2          L_112:
  501:         if ((seconds & 0x01) > 0) ClrBitsPar(0x01); else SetBitsPar(0x01);
 00000BD2  4800      LDR         R0,=seconds ; seconds
 00000BD4  6800      LDR         R0,[R0,#0x0] ; seconds
 00000BD6  2101      MOV         R1,#0x1
 00000BD8  4008      AND         R0,R1
 00000BDA  2800      CMP         R0,#0x0
 00000BDC  DDEF      BLE         L_125  ; T=0x00000BBE
 00000BDE  2001      MOV         R0,#0x1
 00000BE0  F7FF      BL          ClrBitsPar?T  ; T=0x0001  (1)
 00000BE2  FA0E      BL          ClrBitsPar?T  ; T=0x0001  (2)
 00000BE4  E234      B           L_33  ; T=0x00001050
 00000BE6          L_125:
 00000BE6  2001      MOV         R0,#0x1
 00000BE8  F7FF      BL          SetBitsPar?T  ; T=0x0001  (1)
 00000BEA  FA0A      BL          SetBitsPar?T  ; T=0x0001  (2)
  502:     }
 00000BEC  E230      B           L_33  ; T=0x00001050
 00000BEE            ; SCOPE-END
 00000BEE  B00A      ADD         R13,#0x28
 00000BF0  BC08      POP         {R3}
 00000BF2  4718      BX          R3
 00000BF4          ENDP ; 'main'


*** CODE SEGMENT '?PR?getPIO?T?Fart':
  507: void getPIO(void)
 00000000  B500      PUSH        {LR}
  508: {
 00000002            ; SCOPE-START
  511:     val = GetBitsPar();
 00000002  F7FF      BL          GetBitsPar?T  ; T=0x0001  (1)
 00000004  FFFD      BL          GetBitsPar?T  ; T=0x0001  (2)
 00000006  1C02      MOV         R2,R0 ; val
 00000008  ---- Variable 'val' assigned to Register 'R2' ----
  512:     val = ((parOutp << 8) | val);
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 72  

 00000008  4800      LDR         R0,=parOutp ; parOutp
 0000000A  6800      LDR         R0,[R0,#0x0] ; parOutp
 0000000C  0200      LSL         R0,R0,#0x8
 0000000E  4302      ORR         R2,R0
  513:     n = sprintf(outBuf,"%d\n",val);
 00000010  4800      LDR         R0,=outBuf ; outBuf
 00000012  4800      LDR         R1,=??S_5 ; ??S_5
 00000014  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000016  FFF4      BL          sprintf?T  ; T=0x0001  (2)
 00000018  1C01      MOV         R1,R0 ; n
 0000001A  ---- Variable 'n' assigned to Register 'R1' ----
  514:     i = UART0_Str(outBuf, n);
 0000001A  4800      LDR         R0,=outBuf ; outBuf
 0000001C  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 0000001E  FFF0      BL          UART0_Str?T  ; T=0x0001  (2)
  515:     nBuffer[1] = 0;
 00000020  2100      MOV         R1,#0x0
 00000022  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 00000024  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 00000026            ; SCOPE-END
  516: }
 00000026  BC08      POP         {R3}
 00000028  4718      BX          R3
 0000002A          ENDP ; 'getPIO?T'


*** CODE SEGMENT '?PR?SetBitsPar?T?Fart':
  518: void SetBitsPar(int i)
 00000000  ---- Variable 'i' assigned to Register 'R0' ----
  520:     IOSET0 = (i & 0xFF) << 4;          
 00000000  21FF      MOV         R1,#0xFF
 00000002  4001      AND         R1,R0 ; i
 00000004  0109      LSL         R1,R1,#0x4
 00000006  4800      LDR         R0,=0xE0028004
 00000008  6001      STR         R1,[R0,#0x0]
  521: }
 0000000A  4770      BX          R14
 0000000C          ENDP ; 'SetBitsPar?T'


*** CODE SEGMENT '?PR?ClrBitsPar?T?Fart':
  524: void ClrBitsPar(int i)
 00000000  ---- Variable 'i' assigned to Register 'R0' ----
  526:     IOCLR0 = (i & 0xFF) << 4;
 00000000  21FF      MOV         R1,#0xFF
 00000002  4001      AND         R1,R0 ; i
 00000004  0109      LSL         R1,R1,#0x4
 00000006  4800      LDR         R0,=0xE002800C
 00000008  6001      STR         R1,[R0,#0x0]
  527: }
 0000000A  4770      BX          R14
 0000000C          ENDP ; 'ClrBitsPar?T'


*** CODE SEGMENT '?PR?ClrAllBitsPar?T?Fart':
  531:     IOCLR0 = 0xFF << 4;
 00000000  4800      LDR         R1,=0xFF0
 00000002  4800      LDR         R0,=0xE002800C
 00000004  6001      STR         R1,[R0,#0x0]
  532: }
 00000006  4770      BX          R14
 00000008          ENDP ; 'ClrAllBitsPar?T'


*** CODE SEGMENT '?PR?GetBitsPar?T?Fart':
  535: {
 00000000            ; SCOPE-START
  542:     i = (IOPIN0 >> 18) & 0x00FF;  // small arche
 00000000  4800      LDR         R0,=0xE0028000
 00000002  6800      LDR         R0,[R0,#0x0]
 00000004  0C80      LSR         R0,R0,#0x12
 00000006  21FF      MOV         R1,#0xFF
 00000008  4008      AND         R0,R1
 0000000A  ---- Variable 'i' assigned to Register 'R0' ----
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 73  

  544:     return i;
 0000000A            ; SCOPE-END
  545: }
 0000000A  4770      BX          R14
 0000000C          ENDP ; 'GetBitsPar?T'


*** CODE SEGMENT '?PR?TstBitPar?T?Fart':
  547: int TstBitPar(int bit)
 00000000  B510      PUSH        {R4,LR}
 00000002  1C04      MOV         R4,R0 ; bit
 00000004  ---- Variable 'bit' assigned to Register 'R4' ----
  548: {
 00000004            ; SCOPE-START
  550:     i = GetBitsPar();
 00000004  F7FF      BL          GetBitsPar?T  ; T=0x0001  (1)
 00000006  FFFC      BL          GetBitsPar?T  ; T=0x0001  (2)
 00000008  1C01      MOV         R1,R0 ; i
 0000000A  ---- Variable 'i' assigned to Register 'R1' ----
  551:     i = (i & bit);
 0000000A  4021      AND         R1,R4 ; bit
  553:     return i;
 0000000C  1C08      MOV         R0,R1 ; i
 0000000E            ; SCOPE-END
  554: }
 0000000E  BC10      POP         {R4}
 00000010  BC08      POP         {R3}
 00000012  4718      BX          R3
 00000014          ENDP ; 'TstBitPar?T'


*** CODE SEGMENT '?PR?execResults?T?Fart':
  557: void execResults()
 00000000  B500      PUSH        {LR}
  558: {
 00000002            ; SCOPE-START
  560:     n = sprintf(outBuf,"%d;%d\n",startTime, nStim);
 00000002  4800      LDR         R0,=outBuf ; outBuf
 00000004  4800      LDR         R1,=??S_6 ; ??S_6
 00000006  4800      LDR         R2,=startTime ; startTime
 00000008  6812      LDR         R2,[R2,#0x0] ; startTime
 0000000A  4800      LDR         R3,=nStim ; nStim
 0000000C  681B      LDR         R3,[R3,#0x0] ; nStim
 0000000E  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000010  FFF7      BL          sprintf?T  ; T=0x0001  (2)
 00000012  1C01      MOV         R1,R0 ; n
 00000014  ---- Variable 'n' assigned to Register 'R1' ----
  561:     i = UART0_Str(outBuf, n);
 00000014  4800      LDR         R0,=outBuf ; outBuf
 00000016  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000018  FFF3      BL          UART0_Str?T  ; T=0x0001  (2)
  562:     nBuffer[1] = 0;
 0000001A  2100      MOV         R1,#0x0
 0000001C  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 0000001E  6001      STR         R1,[R0,#0x0] ; nBuffer+4
  563:     MCS = statInit;
 00000020  2101      MOV         R1,#0x1
 00000022  4800      LDR         R0,=MCS ; MCS
 00000024  6001      STR         R1,[R0,#0x0] ; MCS
 00000026            ; SCOPE-END
  564: }
 00000026  BC08      POP         {R3}
 00000028  4718      BX          R3
 0000002A          ENDP ; 'execResults?T'


*** CODE SEGMENT '?PR?execTime?T?Fart':
  566: void execTime()
 00000000  B500      PUSH        {LR}
  567: {
 00000002            ; SCOPE-START
  570:     n = sprintf(outBuf,"%d\n",Clock_GetTicks());
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 74  

 00000002  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000004  FFFD      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000006  1C02      MOV         R2,R0
 00000008  4800      LDR         R0,=outBuf ; outBuf
 0000000A  4800      LDR         R1,=??S_5 ; ??S_5
 0000000C  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 0000000E  FFF8      BL          sprintf?T  ; T=0x0001  (2)
 00000010  1C01      MOV         R1,R0 ; n
 00000012  ---- Variable 'n' assigned to Register 'R1' ----
  571:     i = UART0_Str(outBuf, n);
 00000012  4800      LDR         R0,=outBuf ; outBuf
 00000014  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000016  FFF4      BL          UART0_Str?T  ; T=0x0001  (2)
  572:     nBuffer[1] = 0;
 00000018  2100      MOV         R1,#0x0
 0000001A  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 0000001C  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 0000001E            ; SCOPE-END
  573: }
 0000001E  BC08      POP         {R3}
 00000020  4718      BX          R3
 00000022          ENDP ; 'execTime?T'


*** CODE SEGMENT '?PR?execError?T?Fart':
  575: void execError(void)
 00000000  B500      PUSH        {LR}
  576: {
 00000002            ; SCOPE-START
  578:     for (i = 0; i < nStim; i++)
 00000002  2000      MOV         R0,#0x0
 00000004  ---- Variable 'i' assigned to Register 'R0' ----
 00000004  E009      B           L_132  ; T=0x0000001A
 00000006          L_133:
  580:         if (stim[i].status != statDone)
 00000006  234C      MOV         R3,#0x4C
 00000008  4343      MUL         R3,R0 ; i
 0000000A  4800      LDR         R1,=stim + 0x4 ; stim+4
 0000000C  58C9      LDR         R1,[R1,R3]
 0000000E  2905      CMP         R1,#0x5
 00000010  D002      BEQ         L_130  ; T=0x00000018
  581:             stim[i].status = statError;
 00000012  2106      MOV         R1,#0x6
 00000014  4800      LDR         R2,=stim + 0x4 ; stim+4
 00000016  50D1      STR         R1,[R2,R3]
  582:     }
 00000018          L_130:
 00000018  3001      ADD         R0,#0x1
 0000001A          L_132:
 0000001A  4800      LDR         R1,=nStim ; nStim
 0000001C  6809      LDR         R1,[R1,#0x0] ; nStim
 0000001E  4288      CMP         R0,R1 ; i
 00000020  DBF1      BLT         L_133  ; T=0x00000006
  583:     if (sndBit > 0)
 00000022  4800      LDR         R0,=sndBit ; sndBit
 00000024  6800      LDR         R0,[R0,#0x0] ; sndBit
 00000026  2800      CMP         R0,#0x0
 00000028  DD08      BLE         L_136  ; T=0x0000003C
  585:         ClrBitsPar(sndBit);
 0000002A  F7FF      BL          ClrBitsPar?T  ; T=0x0001  (1)
 0000002C  FFE9      BL          ClrBitsPar?T  ; T=0x0001  (2)
  586:         parOutp &= ~sndBit;
 0000002E  4800      LDR         R0,=sndBit ; sndBit
 00000030  6800      LDR         R0,[R0,#0x0] ; sndBit
 00000032  4800      LDR         R1,=parOutp ; parOutp
 00000034  6809      LDR         R1,[R1,#0x0] ; parOutp
 00000036  4381      BIC         R1,R0
 00000038  4800      LDR         R0,=parOutp ; parOutp
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 75  

 0000003A  6001      STR         R1,[R0,#0x0] ; parOutp
  587:     }
 0000003C          L_136:
  588:     if (rewBit > 0)
 0000003C  4800      LDR         R0,=rewBit ; rewBit
 0000003E  6800      LDR         R0,[R0,#0x0] ; rewBit
 00000040  2800      CMP         R0,#0x0
 00000042  DD08      BLE         L_137  ; T=0x00000056
  590:         ClrBitsPar(rewBit);
 00000044  F7FF      BL          ClrBitsPar?T  ; T=0x0001  (1)
 00000046  FFDC      BL          ClrBitsPar?T  ; T=0x0001  (2)
  591:         parOutp &= ~rewBit;
 00000048  4800      LDR         R0,=rewBit ; rewBit
 0000004A  6800      LDR         R0,[R0,#0x0] ; rewBit
 0000004C  4800      LDR         R1,=parOutp ; parOutp
 0000004E  6809      LDR         R1,[R1,#0x0] ; parOutp
 00000050  4381      BIC         R1,R0
 00000052  4800      LDR         R0,=parOutp ; parOutp
 00000054  6001      STR         R1,[R0,#0x0] ; parOutp
  592:     }
 00000056          L_137:
  593:     if (recBit > 0)
 00000056  4800      LDR         R0,=recBit ; recBit
 00000058  6800      LDR         R0,[R0,#0x0] ; recBit
 0000005A  2800      CMP         R0,#0x0
 0000005C  DD08      BLE         L_138  ; T=0x00000070
  595:         ClrBitsPar(recBit);
 0000005E  F7FF      BL          ClrBitsPar?T  ; T=0x0001  (1)
 00000060  FFCF      BL          ClrBitsPar?T  ; T=0x0001  (2)
  596:         parOutp &= ~recBit;
 00000062  4800      LDR         R0,=recBit ; recBit
 00000064  6800      LDR         R0,[R0,#0x0] ; recBit
 00000066  4800      LDR         R1,=parOutp ; parOutp
 00000068  6809      LDR         R1,[R1,#0x0] ; parOutp
 0000006A  4381      BIC         R1,R0
 0000006C  4800      LDR         R0,=parOutp ; parOutp
 0000006E  6001      STR         R1,[R0,#0x0] ; parOutp
  597:     }
 00000070          L_138:
  598:     if (lasBit > 0)
 00000070  4800      LDR         R0,=lasBit ; lasBit
 00000072  6800      LDR         R0,[R0,#0x0] ; lasBit
 00000074  2800      CMP         R0,#0x0
 00000076  DD08      BLE         L_139  ; T=0x0000008A
  600:         ClrBitsPar(lasBit);
 00000078  F7FF      BL          ClrBitsPar?T  ; T=0x0001  (1)
 0000007A  FFC2      BL          ClrBitsPar?T  ; T=0x0001  (2)
  601:         parOutp &= ~lasBit;
 0000007C  4800      LDR         R0,=lasBit ; lasBit
 0000007E  6800      LDR         R0,[R0,#0x0] ; lasBit
 00000080  4800      LDR         R1,=parOutp ; parOutp
 00000082  6809      LDR         R1,[R1,#0x0] ; parOutp
 00000084  4381      BIC         R1,R0
 00000086  4800      LDR         R0,=parOutp ; parOutp
 00000088  6001      STR         R1,[R0,#0x0] ; parOutp
  602:     }
 0000008A          L_139:
  603:     ClearSky();
 0000008A  F7FF      BL          ClearSky?T  ; T=0x0001  (1)
 0000008C  FFB9      BL          ClearSky?T  ; T=0x0001  (2)
  604:     errFlag = true;
 0000008E  2101      MOV         R1,#0x1
 00000090  4800      LDR         R0,=errFlag ; errFlag
 00000092  6001      STR         R1,[R0,#0x0] ; errFlag
  605:     errTime = Clock_GetTicks();
 00000094  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 76  

 00000096  FFB4      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000098  4800      LDR         R1,=errTime ; errTime
 0000009A  6008      STR         R0,[R1,#0x0] ; errTime
 0000009C            ; SCOPE-END
  606: }
 0000009C  BC08      POP         {R3}
 0000009E  4718      BX          R3
 000000A0          ENDP ; 'execError?T'


*** CODE SEGMENT '?PR?WaitForEnter?T?Fart':
  608: void WaitForEnter(void)
 00000000  B510      PUSH        {R4,LR}
  609: {
 00000002            ; SCOPE-START
  611:     inChar = -1;
 00000002  4800      LDR         R4,=0xFFFFFFFF
 00000004  ---- Variable 'inChar' assigned to Register 'R4' ----
  613:     Clock_ClrCountWait();
 00000004  F7FF      BL          Clock_ClrCountWait?T  ; T=0x0001  (1)
 00000006  FFFC      BL          Clock_ClrCountWait?T  ; T=0x0001  (2)
  615:     while (inChar != LF)
 00000008          L_142:
  617:         if (UART0_RxNumber() > 0)
 00000008  F7FF      BL          UART0_RxNumber?T  ; T=0x0001  (1)
 0000000A  FFFA      BL          UART0_RxNumber?T  ; T=0x0001  (2)
 0000000C  0400      LSL         R0,R0,#0x10 ; UART0_RxNumber?T
 0000000E  0C00      LSR         R0,R0,#0x10
 00000010  2800      CMP         R0,#0x0
 00000012  D903      BLS         L_144  ; T=0x0000001C
  619:             inChar = UART0_Get();
 00000014  F7FF      BL          UART0_Get?T  ; T=0x0001  (1)
 00000016  FFF4      BL          UART0_Get?T  ; T=0x0001  (2)
 00000018  1C04      MOV         R4,R0 ; inChar
  620:         }
 0000001A  E004      B           L_140  ; T=0x00000026
 0000001C          L_144:
  623:             if (Clock_GetCountWait() == 100) inChar = LF;
 0000001C  F7FF      BL          Clock_GetCountWait?T  ; T=0x0001  (1)
 0000001E  FFF0      BL          Clock_GetCountWait?T  ; T=0x0001  (2)
 00000020  2864      CMP         R0,#0x64 ; Clock_GetCountWait?T
 00000022  D100      BNE         L_140  ; T=0x00000026
 00000024  240A      MOV         R4,#0xA
  625:     }
 00000026          L_140:
 00000026  2C0A      CMP         R4,#0xA ; inChar
 00000028  D1EE      BNE         L_142  ; T=0x00000008
 0000002A            ; SCOPE-END
  626: }
 0000002A  BC10      POP         {R4}
 0000002C  BC08      POP         {R3}
 0000002E  4718      BX          R3
 00000030          ENDP ; 'WaitForEnter?T'


*** CODE SEGMENT '?PR?setSpeaker?T?Fart':
  628: void setSpeaker(void)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  B084      SUB         R13,#0x10
 00000004  ---- Variable 'tmp' assigned to Register 'R5' ----
 00000004  ---- Variable 'board' assigned to Register 'R4' ----
  629: {
 00000004            ; SCOPE-START
  632:     int OnOff   = nBuffer[4];
 00000004  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 00000006  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 00000008  9002      STR         R0,[R13,#0x8] ; OnOff
  633:     int channel = nBuffer[3];
 0000000A  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 0000000C  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 77  

 0000000E  9003      STR         R0,[R13,#0xC] ; channel
  642:     n = nBuffer[2] - 1;
 00000010  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 00000012  6806      LDR         R6,[R0,#0x0] ; nBuffer+8
 00000014  3E01      SUB         R6,#0x1
 00000016  ---- Variable 'n' assigned to Register 'R6' ----
  645:     if (n < 100) board = n / 8; else board = ((n - 100) / 8) + 4;
 00000016  2E64      CMP         R6,#0x64 ; n
 00000018  DA06      BGE         L_147  ; T=0x00000028
 0000001A  2108      MOV         R1,#0x8
 0000001C  1C30      MOV         R0,R6 ; n
 0000001E  F7FF      BL          ?C?SDIV?T  ; T=0x0001  (1) ; ?C?SDIV?T
 00000020  FFEF      BL          ?C?SDIV?T  ; T=0x0001  (2) ; ?C?SDIV?T
 00000022  1C08      MOV         R0,R1
 00000024  1C04      MOV         R4,R0 ; board
 00000026  E007      B           L_148  ; T=0x00000038
 00000028          L_147:
 00000028  1C30      MOV         R0,R6 ; n
 0000002A  3864      SUB         R0,#0x64
 0000002C  2108      MOV         R1,#0x8
 0000002E  F7FF      BL          ?C?SDIV?T  ; T=0x0001  (1) ; ?C?SDIV?T
 00000030  FFE7      BL          ?C?SDIV?T  ; T=0x0001  (2) ; ?C?SDIV?T
 00000032  1C08      MOV         R0,R1
 00000034  1C04      MOV         R4,R0
 00000036  3404      ADD         R4,#0x4
 00000038          L_148:
  646:     if (n >= 100) n = n - 100 + 32;  // correction front/back and board 4=board 0
 00000038  2E64      CMP         R6,#0x64 ; n
 0000003A  DB00      BLT         L_149  ; T=0x0000003E
 0000003C  3E44      SUB         R6,#0x44
 0000003E          L_149:
  647:     speaker = n - 8*board;
 0000003E  00E0      LSL         R0,R4,#0x3 ; board
 00000040  1A37      SUB         R7,R6,R0 ; n
 00000042  ---- Variable 'speaker' assigned to Register 'R7' ----
  648:     address   = 0x4E;
 00000042  204E      MOV         R0,#0x4E
 00000044  9000      STR         R0,[R13,#0x0] ; address
  650:     buffer[0] = boards[board]; 
 00000046  00A1      LSL         R1,R4,#0x2 ; board
 00000048  4800      LDR         R0,=boards ; boards
 0000004A  5841      LDR         R1,[R0,R1]
 0000004C  A801      ADD         R0,R13,#0x4
 0000004E  7001      STRB        R1,[R0,#0x0] ; buffer
  651:     I2C_SendByte(address, 1, buffer);
 00000050  9800      LDR         R0,[R13,#0x0] ; address
 00000052  AA01      ADD         R2,R13,#0x4
 00000054  2101      MOV         R1,#0x1
 00000056  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 00000058  FFD3      BL          I2C_SendByte?T  ; T=0x0001  (2)
  653:     if (OnOff == 1)
 0000005A  9802      LDR         R0,[R13,#0x8] ; OnOff
 0000005C  2801      CMP         R0,#0x1
 0000005E  D11B      BNE         L_150  ; T=0x00000098
  655:         tmp = statusBoards[board][0];
 00000060  210C      MOV         R1,#0xC
 00000062  4361      MUL         R1,R4 ; board
 00000064  4800      LDR         R0,=statusBoards ; statusBoards
 00000066  5845      LDR         R5,[R0,R1]
  656:         if (channel == stimSnd1) 
 00000068  9803      LDR         R0,[R13,#0xC] ; channel
 0000006A  280B      CMP         R0,#0xB
 0000006C  D104      BNE         L_151  ; T=0x00000078
  657:             tmp |= speakers[speaker];       // set speakerbit
 0000006E  00BA      LSL         R2,R7,#0x2 ; speaker
 00000070  4800      LDR         R0,=speakers ; speakers
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 78  

 00000072  5880      LDR         R0,[R0,R2]
 00000074  4305      ORR         R5,R0
 00000076  E003      B           L_152  ; T=0x00000080
 00000078          L_151:
  659:             tmp &= ~speakers[speaker];      // clr speakerbit 
 00000078  00BA      LSL         R2,R7,#0x2 ; speaker
 0000007A  4800      LDR         R0,=speakers ; speakers
 0000007C  5880      LDR         R0,[R0,R2]
 0000007E  4385      BIC         R5,R0
 00000080          L_152:
  661:         statusBoards[board][0] = tmp;
 00000080  4800      LDR         R0,=statusBoards ; statusBoards
 00000082  5045      STR         R5,[R0,R1] ; tmp
  662:         buffer[0] = tmp;
 00000084  1C29      MOV         R1,R5 ; tmp
 00000086  A801      ADD         R0,R13,#0x4
 00000088  7001      STRB        R1,[R0,#0x0] ; buffer
  663:         address   = 0x40;
 0000008A  2040      MOV         R0,#0x40
 0000008C  9000      STR         R0,[R13,#0x0] ; address
  664:         I2C_SendByte(address, 1, buffer);
 0000008E  9800      LDR         R0,[R13,#0x0] ; address
 00000090  AA01      ADD         R2,R13,#0x4
 00000092  2101      MOV         R1,#0x1
 00000094  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 00000096  FFB4      BL          I2C_SendByte?T  ; T=0x0001  (2)
  665:     }
 00000098          L_150:
  667:     if (OnOff == 1)
 00000098  9802      LDR         R0,[R13,#0x8] ; OnOff
 0000009A  2801      CMP         R0,#0x1
 0000009C  D12B      BNE         L_153  ; T=0x000000F6
  669:         if (speaker < 4)
 0000009E  2F04      CMP         R7,#0x4 ; speaker
 000000A0  DA14      BGE         L_154  ; T=0x000000CC
  671:             address  = 0x44;
 000000A2  2044      MOV         R0,#0x44
 000000A4  9000      STR         R0,[R13,#0x0] ; address
  672:             tmp = statusBoards[board][1];
 000000A6  210C      MOV         R1,#0xC
 000000A8  4361      MUL         R1,R4 ; board
 000000AA  4800      LDR         R0,=statusBoards + 0x4 ; statusBoards+4
 000000AC  5845      LDR         R5,[R0,R1]
  673:             if (channel == stimSnd1)
 000000AE  9803      LDR         R0,[R13,#0xC] ; channel
 000000B0  280B      CMP         R0,#0xB
 000000B2  D104      BNE         L_155  ; T=0x000000BE
  674:                 tmp &= gain1[speaker];
 000000B4  00BA      LSL         R2,R7,#0x2 ; speaker
 000000B6  4800      LDR         R0,=gain1 ; gain1
 000000B8  5880      LDR         R0,[R0,R2]
 000000BA  4005      AND         R5,R0
 000000BC  E003      B           L_156  ; T=0x000000C6
 000000BE          L_155:
  676:                 tmp &= gain2[speaker];
 000000BE  00BA      LSL         R2,R7,#0x2 ; speaker
 000000C0  4800      LDR         R0,=gain2 ; gain2
 000000C2  5880      LDR         R0,[R0,R2]
 000000C4  4005      AND         R5,R0
 000000C6          L_156:
  677:             statusBoards[board][1] = tmp;
 000000C6  4800      LDR         R0,=statusBoards + 0x4 ; statusBoards+4
 000000C8  5045      STR         R5,[R0,R1] ; tmp
  678:         }
 000000CA  E043      B           L_160  ; T=0x00000154
 000000CC          L_154:
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 79  

  681:             address  = 0x42;
 000000CC  2042      MOV         R0,#0x42
 000000CE  9000      STR         R0,[R13,#0x0] ; address
  682:             tmp = statusBoards[board][2];
 000000D0  210C      MOV         R1,#0xC
 000000D2  4361      MUL         R1,R4 ; board
 000000D4  4800      LDR         R0,=statusBoards + 0x8 ; statusBoards+8
 000000D6  5845      LDR         R5,[R0,R1]
  683:             if (channel == stimSnd1)
 000000D8  9803      LDR         R0,[R13,#0xC] ; channel
 000000DA  280B      CMP         R0,#0xB
 000000DC  D104      BNE         L_158  ; T=0x000000E8
  684:                 tmp &= gain1[speaker];
 000000DE  00BA      LSL         R2,R7,#0x2 ; speaker
 000000E0  4800      LDR         R0,=gain1 ; gain1
 000000E2  5880      LDR         R0,[R0,R2]
 000000E4  4005      AND         R5,R0
 000000E6  E003      B           L_159  ; T=0x000000F0
 000000E8          L_158:
  686:                 tmp &= gain2[speaker];
 000000E8  00BA      LSL         R2,R7,#0x2 ; speaker
 000000EA  4800      LDR         R0,=gain2 ; gain2
 000000EC  5880      LDR         R0,[R0,R2]
 000000EE  4005      AND         R5,R0
 000000F0          L_159:
  687:             statusBoards[board][2] = tmp;
 000000F0  4800      LDR         R0,=statusBoards + 0x8 ; statusBoards+8
 000000F2  5045      STR         R5,[R0,R1] ; tmp
  689:     }
 000000F4  E02E      B           L_160  ; T=0x00000154
 000000F6          L_153:
  692:         if (speaker < 4)
 000000F6  2F04      CMP         R7,#0x4 ; speaker
 000000F8  DA16      BGE         L_161  ; T=0x00000128
  694:             address  = 0x44;
 000000FA  2044      MOV         R0,#0x44
 000000FC  9000      STR         R0,[R13,#0x0] ; address
  695:             tmp = statusBoards[board][1];
 000000FE  210C      MOV         R1,#0xC
 00000100  4361      MUL         R1,R4 ; board
 00000102  4800      LDR         R0,=statusBoards + 0x4 ; statusBoards+4
 00000104  5845      LDR         R5,[R0,R1]
  696:             if (channel == stimSnd1)
 00000106  9803      LDR         R0,[R13,#0xC] ; channel
 00000108  280B      CMP         R0,#0xB
 0000010A  D105      BNE         L_162  ; T=0x00000118
  697:                 tmp |= ~gain1[speaker];
 0000010C  00BA      LSL         R2,R7,#0x2 ; speaker
 0000010E  4800      LDR         R0,=gain1 ; gain1
 00000110  5880      LDR         R0,[R0,R2]
 00000112  43C0      MVN         R0,R0
 00000114  4305      ORR         R5,R0
 00000116  E004      B           L_163  ; T=0x00000122
 00000118          L_162:
  699:                 tmp |= ~gain2[speaker];
 00000118  00BA      LSL         R2,R7,#0x2 ; speaker
 0000011A  4800      LDR         R0,=gain2 ; gain2
 0000011C  5880      LDR         R0,[R0,R2]
 0000011E  43C0      MVN         R0,R0
 00000120  4305      ORR         R5,R0
 00000122          L_163:
  700:             statusBoards[board][1] = tmp;
 00000122  4800      LDR         R0,=statusBoards + 0x4 ; statusBoards+4
 00000124  5045      STR         R5,[R0,R1] ; tmp
  701:         }
 00000126  E015      B           L_160  ; T=0x00000154
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 80  

 00000128          L_161:
  704:             address  = 0x42;
 00000128  2042      MOV         R0,#0x42
 0000012A  9000      STR         R0,[R13,#0x0] ; address
  705:             tmp = statusBoards[board][2];
 0000012C  210C      MOV         R1,#0xC
 0000012E  4361      MUL         R1,R4 ; board
 00000130  4800      LDR         R0,=statusBoards + 0x8 ; statusBoards+8
 00000132  5845      LDR         R5,[R0,R1]
  706:             if (channel == stimSnd1)
 00000134  9803      LDR         R0,[R13,#0xC] ; channel
 00000136  280B      CMP         R0,#0xB
 00000138  D105      BNE         L_165  ; T=0x00000146
  707:                 tmp |= ~gain1[speaker];
 0000013A  00BA      LSL         R2,R7,#0x2 ; speaker
 0000013C  4800      LDR         R0,=gain1 ; gain1
 0000013E  5880      LDR         R0,[R0,R2]
 00000140  43C0      MVN         R0,R0
 00000142  4305      ORR         R5,R0
 00000144  E004      B           L_166  ; T=0x00000150
 00000146          L_165:
  709:                 tmp |= ~gain2[speaker];
 00000146  00BA      LSL         R2,R7,#0x2 ; speaker
 00000148  4800      LDR         R0,=gain2 ; gain2
 0000014A  5880      LDR         R0,[R0,R2]
 0000014C  43C0      MVN         R0,R0
 0000014E  4305      ORR         R5,R0
 00000150          L_166:
  710:             statusBoards[board][2] = tmp;
 00000150  4800      LDR         R0,=statusBoards + 0x8 ; statusBoards+8
 00000152  5045      STR         R5,[R0,R1] ; tmp
  712:     }
 00000154          L_160:
  713:     buffer[0] = tmp;
 00000154  1C29      MOV         R1,R5 ; tmp
 00000156  A801      ADD         R0,R13,#0x4
 00000158  7001      STRB        R1,[R0,#0x0] ; buffer
  714:     I2C_SendByte(address, 1, buffer);
 0000015A  9800      LDR         R0,[R13,#0x0] ; address
 0000015C  AA01      ADD         R2,R13,#0x4
 0000015E  2101      MOV         R1,#0x1
 00000160  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 00000162  FF4E      BL          I2C_SendByte?T  ; T=0x0001  (2)
  716:     n = sprintf(outBuf,"%d\n",tmp);
 00000164  4800      LDR         R0,=outBuf ; outBuf
 00000166  4800      LDR         R1,=??S_5 ; ??S_5
 00000168  1C2A      MOV         R2,R5
 0000016A  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 0000016C  FF49      BL          sprintf?T  ; T=0x0001  (2)
 0000016E  1C06      MOV         R6,R0 ; n
  717:     i = UART0_Str(outBuf, n);
 00000170  4800      LDR         R0,=outBuf ; outBuf
 00000172  1C31      MOV         R1,R6
 00000174  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000176  FF44      BL          UART0_Str?T  ; T=0x0001  (2)
  719:     nBuffer[1] = 0;
 00000178  2100      MOV         R1,#0x0
 0000017A  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 0000017C  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 0000017E            ; SCOPE-END
  720: }
 0000017E  B004      ADD         R13,#0x10
 00000180  BCF0      POP         {R4-R7}
 00000182  BC08      POP         {R3}
 00000184  4718      BX          R3
 00000186          ENDP ; 'setSpeaker?T'

ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 81  


*** CODE SEGMENT '?PR?setFixWindow?T?Fart':
  722: void setFixWindow()
 00000000  B500      PUSH        {LR}
  723: {
 00000002            ; SCOPE-START
  725:     int id = nBuffer[2];
 00000002  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 00000004  6803      LDR         R3,[R0,#0x0] ; nBuffer+8
 00000006  ---- Variable 'id' assigned to Register 'R3' ----
  726:     fixWindows[id].fix  = 0;
 00000006  2000      MOV         R0,#0x0
 00000008  211C      MOV         R1,#0x1C
 0000000A  4359      MUL         R1,R3 ; id
 0000000C  4800      LDR         R2,=fixWindows ; fixWindows
 0000000E  5050      STR         R0,[R2,R1]
  727:     fixWindows[id].Xnet = nBuffer[3];
 00000010  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 00000012  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 00000014  4800      LDR         R2,=fixWindows + 0x8 ; fixWindows+8
 00000016  5050      STR         R0,[R2,R1]
  728:     fixWindows[id].Ynet = nBuffer[4];
 00000018  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 0000001A  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 0000001C  4800      LDR         R2,=fixWindows + 0xC ; fixWindows+12
 0000001E  5050      STR         R0,[R2,R1]
  729:     fixWindows[id].Xh   = nBuffer[5]; ///10.0;
 00000020  4800      LDR         R0,=nBuffer + 0x14 ; nBuffer+20
 00000022  6800      LDR         R0,[R0,#0x0] ; nBuffer+20
 00000024  F7FF      BL          ?C?FCAST?T  ; T=0x0001  (1) ; ?C?FCAST?T
 00000026  FFEC      BL          ?C?FCAST?T  ; T=0x0001  (2) ; ?C?FCAST?T
 00000028  4800      LDR         R2,=fixWindows + 0x10 ; fixWindows+16
 0000002A  5050      STR         R0,[R2,R1]
  730:     fixWindows[id].Yh   = nBuffer[6]; ///10.0;
 0000002C  4800      LDR         R0,=nBuffer + 0x18 ; nBuffer+24
 0000002E  6800      LDR         R0,[R0,#0x0] ; nBuffer+24
 00000030  F7FF      BL          ?C?FCAST?T  ; T=0x0001  (1) ; ?C?FCAST?T
 00000032  FFE6      BL          ?C?FCAST?T  ; T=0x0001  (2) ; ?C?FCAST?T
 00000034  4800      LDR         R2,=fixWindows + 0x14 ; fixWindows+20
 00000036  5050      STR         R0,[R2,R1]
  731:     fixWindows[id].time = 0;
 00000038  2000      MOV         R0,#0x0
 0000003A  4800      LDR         R2,=fixWindows + 0x18 ; fixWindows+24
 0000003C  5050      STR         R0,[R2,R1]
  737:         (int) fixWindows[id].Yh);
 0000003E  4800      LDR         R0,=fixWindows + 0x14 ; fixWindows+20
 00000040  5840      LDR         R0,[R0,R1]
 00000042  F7FF      BL          ?C?CASTF?T  ; T=0x0001  (1) ; ?C?CASTF?T
 00000044  FFDD      BL          ?C?CASTF?T  ; T=0x0001  (2) ; ?C?CASTF?T
 00000046  B401      PUSH        {R0}
 00000048  4800      LDR         R0,=fixWindows + 0x10 ; fixWindows+16
 0000004A  5840      LDR         R0,[R0,R1]
 0000004C  F7FF      BL          ?C?CASTF?T  ; T=0x0001  (1) ; ?C?CASTF?T
 0000004E  FFD8      BL          ?C?CASTF?T  ; T=0x0001  (2) ; ?C?CASTF?T
 00000050  B401      PUSH        {R0}
 00000052  4800      LDR         R0,=fixWindows + 0x8 ; fixWindows+8
 00000054  5842      LDR         R2,[R0,R1]
 00000056  4800      LDR         R0,=fixWindows + 0xC ; fixWindows+12
 00000058  5843      LDR         R3,[R0,R1]
 0000005A  4800      LDR         R0,=outBuf ; outBuf
 0000005C  4800      LDR         R1,=??S_7 ; ??S_7
 0000005E  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000060  FFCF      BL          sprintf?T  ; T=0x0001  (2)
 00000062  B002      ADD         R13,#0x8
 00000064  1C01      MOV         R1,R0 ; n
 00000066  ---- Variable 'n' assigned to Register 'R1' ----
  738:     i = UART0_Str(outBuf, n);
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 82  

 00000066  4800      LDR         R0,=outBuf ; outBuf
 00000068  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 0000006A  FFCA      BL          UART0_Str?T  ; T=0x0001  (2)
  740:     nBuffer[1] = 0;
 0000006C  2100      MOV         R1,#0x0
 0000006E  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 00000070  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 00000072            ; SCOPE-END
  741: }
 00000072  BC08      POP         {R3}
 00000074  4718      BX          R3
 00000076          ENDP ; 'setFixWindow?T'


*** CODE SEGMENT '?PR?execInit?T?Fart':
  744: void execInit()
 00000000  B500      PUSH        {LR}
  745: {
 00000002            ; SCOPE-START
  747:     MCS   = statInit;
 00000002  2101      MOV         R1,#0x1
 00000004  4800      LDR         R0,=MCS ; MCS
 00000006  6001      STR         R1,[R0,#0x0] ; MCS
  748:     nStim = 0;
 00000008  2100      MOV         R1,#0x0
 0000000A  4800      LDR         R0,=nStim ; nStim
 0000000C  6001      STR         R1,[R0,#0x0] ; nStim
  749:     n = sprintf(outBuf,"%d\n",curTime);
 0000000E  4800      LDR         R0,=outBuf ; outBuf
 00000010  4800      LDR         R1,=??S_5 ; ??S_5
 00000012  4800      LDR         R2,=curTime ; curTime
 00000014  6812      LDR         R2,[R2,#0x0] ; curTime
 00000016  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000018  FFF3      BL          sprintf?T  ; T=0x0001  (2)
 0000001A  1C01      MOV         R1,R0 ; n
 0000001C  ---- Variable 'n' assigned to Register 'R1' ----
  750:     i = UART0_Str(outBuf, n);
 0000001C  4800      LDR         R0,=outBuf ; outBuf
 0000001E  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000020  FFEF      BL          UART0_Str?T  ; T=0x0001  (2)
  752:     nBuffer[1] = 0;
 00000022  2100      MOV         R1,#0x0
 00000024  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 00000026  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 00000028            ; SCOPE-END
  753: }
 00000028  BC08      POP         {R3}
 0000002A  4718      BX          R3
 0000002C          ENDP ; 'execInit?T'


*** CODE SEGMENT '?PR?getTime?T?Fart':
  755: void getTime()
 00000000  B500      PUSH        {LR}
  756: {
 00000002            ; SCOPE-START
  759:     val = Clock_GetTicks();
 00000002  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000004  FFFD      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000006  1C02      MOV         R2,R0 ; val
 00000008  ---- Variable 'val' assigned to Register 'R2' ----
  760:     n = sprintf(outBuf,"%d\n",val);
 00000008  4800      LDR         R0,=outBuf ; outBuf
 0000000A  4800      LDR         R1,=??S_5 ; ??S_5
 0000000C  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 0000000E  FFF8      BL          sprintf?T  ; T=0x0001  (2)
 00000010  1C01      MOV         R1,R0 ; n
 00000012  ---- Variable 'n' assigned to Register 'R1' ----
  761:     i = UART0_Str(outBuf, n);
 00000012  4800      LDR         R0,=outBuf ; outBuf
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 83  

 00000014  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000016  FFF4      BL          UART0_Str?T  ; T=0x0001  (2)
  762:     nBuffer[1] = 0;
 00000018  2100      MOV         R1,#0x0
 0000001A  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 0000001C  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 0000001E            ; SCOPE-END
  763: }
 0000001E  BC08      POP         {R3}
 00000020  4718      BX          R3
 00000022          ENDP ; 'getTime?T'


*** CODE SEGMENT '?PR?clrTime?T?Fart':
  765: void clrTime()
 00000000  B500      PUSH        {LR}
  767:     Clock_Reset();
 00000002  F7FF      BL          Clock_Reset?T  ; T=0x0001  (1)
 00000004  FFFD      BL          Clock_Reset?T  ; T=0x0001  (2)
  768:     getTime();
 00000006  F7FF      BL          getTime?T  ; T=0x0001  (1)
 00000008  FFFB      BL          getTime?T  ; T=0x0001  (2)
  769:     nBuffer[1] = 0;
 0000000A  2100      MOV         R1,#0x0
 0000000C  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 0000000E  6001      STR         R1,[R0,#0x0] ; nBuffer+4
  770: }
 00000010  BC08      POP         {R3}
 00000012  4718      BX          R3
 00000014          ENDP ; 'clrTime?T'


*** CODE SEGMENT '?PR?execReset?T?Fart':
  772: void execReset()
 00000000  B500      PUSH        {LR}
  773: {
 00000002            ; SCOPE-START
  777:     softReset();
 00000002  F7FF      BL          softReset?T  ; T=0x0001  (1)
 00000004  FFFD      BL          softReset?T  ; T=0x0001  (2)
  778:     n = sprintf(outBuf,"%d\n",curTime);
 00000006  4800      LDR         R0,=outBuf ; outBuf
 00000008  4800      LDR         R1,=??S_5 ; ??S_5
 0000000A  4800      LDR         R2,=curTime ; curTime
 0000000C  6812      LDR         R2,[R2,#0x0] ; curTime
 0000000E  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000010  FFF7      BL          sprintf?T  ; T=0x0001  (2)
 00000012  1C01      MOV         R1,R0 ; n
 00000014  ---- Variable 'n' assigned to Register 'R1' ----
  779:     i = UART0_Str(outBuf, n);
 00000014  4800      LDR         R0,=outBuf ; outBuf
 00000016  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000018  FFF3      BL          UART0_Str?T  ; T=0x0001  (2)
  780:     nBuffer[1] = 0;
 0000001A  2100      MOV         R1,#0x0
 0000001C  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 0000001E  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 00000020            ; SCOPE-END
  781: }
 00000020  BC08      POP         {R3}
 00000022  4718      BX          R3
 00000024          ENDP ; 'execReset?T'


*** CODE SEGMENT '?PR?execAbort?T?Fart':
  783: void execAbort()
 00000000  B500      PUSH        {LR}
  784: {
 00000002            ; SCOPE-START
  787:     execError();
 00000002  F7FF      BL          execError?T  ; T=0x0001  (1)
 00000004  FFFD      BL          execError?T  ; T=0x0001  (2)
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 84  

  788:     n = sprintf(outBuf,"-998\n");
 00000006  4800      LDR         R0,=outBuf ; outBuf
 00000008  4800      LDR         R1,=??S_8 ; ??S_8
 0000000A  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          sprintf?T  ; T=0x0001  (2)
 0000000E  1C01      MOV         R1,R0 ; n
 00000010  ---- Variable 'n' assigned to Register 'R1' ----
  789:     i = UART0_Str(outBuf, n);
 00000010  4800      LDR         R0,=outBuf ; outBuf
 00000012  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000014  FFF5      BL          UART0_Str?T  ; T=0x0001  (2)
  790:     MCS   = statInit;
 00000016  2101      MOV         R1,#0x1
 00000018  4800      LDR         R0,=MCS ; MCS
 0000001A  6001      STR         R1,[R0,#0x0] ; MCS
  791:     nStim = 0;
 0000001C  2100      MOV         R1,#0x0
 0000001E  4800      LDR         R0,=nStim ; nStim
 00000020  6001      STR         R1,[R0,#0x0] ; nStim
  792:     nBuffer[1] = 0;
 00000022  2100      MOV         R1,#0x0
 00000024  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 00000026  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 00000028            ; SCOPE-END
  793: }
 00000028  BC08      POP         {R3}
 0000002A  4718      BX          R3
 0000002C          ENDP ; 'execAbort?T'


*** CODE SEGMENT '?PR?execSaveTrial?T?Fart':
  795: void execSaveTrial()
 00000000  B570      PUSH        {R4-R6,LR}
  796: {
 00000002            ; SCOPE-START
  799:     n = sprintf(outBuf,"%d %d %d\n",nStim, T_ITI, T_trial);
 00000002  4800      LDR         R0,=T_trial ; T_trial
 00000004  6800      LDR         R0,[R0,#0x0] ; T_trial
 00000006  B401      PUSH        {R0}
 00000008  4800      LDR         R0,=outBuf ; outBuf
 0000000A  4800      LDR         R1,=??S_9 ; ??S_9
 0000000C  4800      LDR         R2,=nStim ; nStim
 0000000E  6812      LDR         R2,[R2,#0x0] ; nStim
 00000010  4800      LDR         R3,=T_ITI ; T_ITI
 00000012  681B      LDR         R3,[R3,#0x0] ; T_ITI
 00000014  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000016  FFF4      BL          sprintf?T  ; T=0x0001  (2)
 00000018  B001      ADD         R13,#0x4
 0000001A  1C06      MOV         R6,R0 ; n
 0000001C  ---- Variable 'n' assigned to Register 'R6' ----
  800:     i = UART0_Str(outBuf, n);
 0000001C  4800      LDR         R0,=outBuf ; outBuf
 0000001E  1C31      MOV         R1,R6
 00000020  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000022  FFEE      BL          UART0_Str?T  ; T=0x0001  (2)
 00000024  1C05      MOV         R5,R0 ; i
 00000026  ---- Variable 'i' assigned to Register 'R5' ----
  801:     for (lp = 0; lp < nStim; lp++)
 00000026  2400      MOV         R4,#0x0
 00000028  ---- Variable 'lp' assigned to Register 'R4' ----
 00000028  E019      B           L_169  ; T=0x0000005E
 0000002A          L_170:
  803:         WaitForEnter();
 0000002A  F7FF      BL          WaitForEnter?T  ; T=0x0001  (1)
 0000002C  FFE9      BL          WaitForEnter?T  ; T=0x0001  (2)
  804:         n = sprintf(outBuf,"%d %d %d %d\n",
 0000002E  214C      MOV         R1,#0x4C
 00000030  4361      MUL         R1,R4 ; lp
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 85  

 00000032  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000034  5840      LDR         R0,[R0,R1]
 00000036  B401      PUSH        {R0}
 00000038  4800      LDR         R0,=stim + 0x28 ; stim+40
 0000003A  5840      LDR         R0,[R0,R1]
 0000003C  B401      PUSH        {R0}
 0000003E  4800      LDR         R0,=stim + 0x8 ; stim+8
 00000040  5842      LDR         R2,[R0,R1]
 00000042  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000044  5843      LDR         R3,[R0,R1]
 00000046  4800      LDR         R0,=outBuf ; outBuf
 00000048  4800      LDR         R1,=??S_7 ; ??S_7
 0000004A  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 0000004C  FFD9      BL          sprintf?T  ; T=0x0001  (2)
 0000004E  B002      ADD         R13,#0x8
 00000050  1C06      MOV         R6,R0 ; n
  806:         i = UART0_Str(outBuf, n);
 00000052  4800      LDR         R0,=outBuf ; outBuf
 00000054  1C31      MOV         R1,R6
 00000056  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000058  FFD3      BL          UART0_Str?T  ; T=0x0001  (2)
 0000005A  1C05      MOV         R5,R0 ; i
  807:     }
 0000005C  3401      ADD         R4,#0x1
 0000005E          L_169:
 0000005E  4800      LDR         R0,=nStim ; nStim
 00000060  6800      LDR         R0,[R0,#0x0] ; nStim
 00000062  4284      CMP         R4,R0 ; lp
 00000064  DBE1      BLT         L_170  ; T=0x0000002A
  808:     MCS = statInit;
 00000066  2101      MOV         R1,#0x1
 00000068  4800      LDR         R0,=MCS ; MCS
 0000006A  6001      STR         R1,[R0,#0x0] ; MCS
  809:     nBuffer[1] = 0;
 0000006C  2100      MOV         R1,#0x0
 0000006E  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 00000070  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 00000072            ; SCOPE-END
  810: }
 00000072  BC70      POP         {R4-R6}
 00000074  BC08      POP         {R3}
 00000076  4718      BX          R3
 00000078          ENDP ; 'execSaveTrial?T'


*** CODE SEGMENT '?PR?execRew?T?Fart':
  812: int execRew(int index)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C05      MOV         R5,R0 ; index
 00000004  ---- Variable 'index' assigned to Register 'R5' ----
  813: {
 00000004            ; SCOPE-START
  814:     int newTime = Clock_GetTicks() - T_start;
 00000004  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000006  FFFC      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000008  4800      LDR         R1,=T_start ; T_start
 0000000A  6809      LDR         R1,[R1,#0x0] ; T_start
 0000000C  1A44      SUB         R4,R0,R1 ; Clock_GetTicks?T
 0000000E  ---- Variable 'newTime' assigned to Register 'R4' ----
  816:     if (stim[index].status == statInit)
 0000000E  274C      MOV         R7,#0x4C
 00000010  436F      MUL         R7,R5 ; index
 00000012  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000014  59C6      LDR         R6,[R0,R7]
 00000016  2E01      CMP         R6,#0x1
 00000018  D11D      BNE         L_172  ; T=0x00000056
  818:         if ((stim[index].startRef == 0) && (curTime >= stim[index].startTime))
 0000001A  4800      LDR         R0,=stim + 0x24 ; stim+36
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 86  

 0000001C  59C0      LDR         R0,[R0,R7]
 0000001E  2800      CMP         R0,#0x0
 00000020  D117      BNE         L_173  ; T=0x00000052
 00000022  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000024  59C1      LDR         R1,[R0,R7]
 00000026  4800      LDR         R0,=curTime ; curTime
 00000028  6800      LDR         R0,[R0,#0x0] ; curTime
 0000002A  4288      CMP         R0,R1
 0000002C  D311      BCC         L_173  ; T=0x00000052
  820:             stim[index].startTime = newTime;
 0000002E  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000030  51C4      STR         R4,[R0,R7] ; newTime
  821:             stim[index].status    = statRun;
 00000032  200A      MOV         R0,#0xA
 00000034  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000036  51C8      STR         R0,[R1,R7]
  822:             SetBitsPar(rewBit);   // Trigger high
 00000038  4800      LDR         R0,=rewBit ; rewBit
 0000003A  6800      LDR         R0,[R0,#0x0] ; rewBit
 0000003C  F7FF      BL          SetBitsPar?T  ; T=0x0001  (1)
 0000003E  FFE0      BL          SetBitsPar?T  ; T=0x0001  (2)
  823:             parOutp |= rewBit;
 00000040  4800      LDR         R0,=rewBit ; rewBit
 00000042  6800      LDR         R0,[R0,#0x0] ; rewBit
 00000044  4800      LDR         R1,=parOutp ; parOutp
 00000046  6809      LDR         R1,[R1,#0x0] ; parOutp
 00000048  4301      ORR         R1,R0
 0000004A  4800      LDR         R0,=parOutp ; parOutp
 0000004C  6001      STR         R1,[R0,#0x0] ; parOutp
  824:             return 1;
 0000004E  2001      MOV         R0,#0x1
 00000050  E025      B           L_174  ; T=0x0000009E
  825:         }
 00000052          L_173:
  826:         return 2;
 00000052  2002      MOV         R0,#0x2
 00000054  E023      B           L_174  ; T=0x0000009E
  827:     }
 00000056          L_172:
  829:     if (stim[index].status == statRun)
 00000056  2E0A      CMP         R6,#0xA
 00000058  D120      BNE         L_175  ; T=0x0000009C
  831:         if ((stim[index].stopRef == 0) && (curTime >= stim[index].stopTime))
 0000005A  214C      MOV         R1,#0x4C
 0000005C  4369      MUL         R1,R5 ; index
 0000005E  4800      LDR         R0,=stim + 0x2C ; stim+44
 00000060  5840      LDR         R0,[R0,R1]
 00000062  2800      CMP         R0,#0x0
 00000064  D118      BNE         L_176  ; T=0x00000098
 00000066  214C      MOV         R1,#0x4C
 00000068  4369      MUL         R1,R5 ; index
 0000006A  4800      LDR         R0,=stim + 0x30 ; stim+48
 0000006C  5841      LDR         R1,[R0,R1]
 0000006E  4800      LDR         R0,=curTime ; curTime
 00000070  6800      LDR         R0,[R0,#0x0] ; curTime
 00000072  4288      CMP         R0,R1
 00000074  D310      BCC         L_176  ; T=0x00000098
  833:             ClrBitsPar(rewBit);
 00000076  4800      LDR         R0,=rewBit ; rewBit
 00000078  6800      LDR         R0,[R0,#0x0] ; rewBit
 0000007A  F7FF      BL          ClrBitsPar?T  ; T=0x0001  (1)
 0000007C  FFC1      BL          ClrBitsPar?T  ; T=0x0001  (2)
  834:             stim[index].stopTime = newTime;
 0000007E  214C      MOV         R1,#0x4C
 00000080  4369      MUL         R1,R5 ; index
 00000082  4800      LDR         R0,=stim + 0x30 ; stim+48
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 87  

 00000084  5044      STR         R4,[R0,R1] ; newTime
  835:             stim[index].status   = statDone;
 00000086  2005      MOV         R0,#0x5
 00000088  4800      LDR         R2,=stim + 0x4 ; stim+4
 0000008A  5050      STR         R0,[R2,R1]
  836:             execEvent(stim[index].event);
 0000008C  4800      LDR         R0,=stim + 0x3C ; stim+60
 0000008E  5840      LDR         R0,[R0,R1]
 00000090  F7FF      BL          execEvent?T  ; T=0x0001  (1)
 00000092  FFB6      BL          execEvent?T  ; T=0x0001  (2)
  837:             return 0;
 00000094  2000      MOV         R0,#0x0
 00000096  E002      B           L_174  ; T=0x0000009E
  838:         }
 00000098          L_176:
  839:         return 1;
 00000098  2001      MOV         R0,#0x1
 0000009A  E000      B           L_174  ; T=0x0000009E
  840:     }
 0000009C          L_175:
  841:     return 0;
 0000009C  2000      MOV         R0,#0x0
 0000009E            ; SCOPE-END
  842: }
 0000009E          L_174:
 0000009E  BCF0      POP         {R4-R7}
 000000A0  BC08      POP         {R3}
 000000A2  4718      BX          R3
 000000A4          ENDP ; 'execRew?T'


*** CODE SEGMENT '?PR?execLas?T?Fart':
  844: int execLas(int index)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C05      MOV         R5,R0 ; index
 00000004  ---- Variable 'index' assigned to Register 'R5' ----
  845: {
 00000004            ; SCOPE-START
  846:     int newTime = Clock_GetTicks() - T_start;
 00000004  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000006  FFFC      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000008  4800      LDR         R1,=T_start ; T_start
 0000000A  6809      LDR         R1,[R1,#0x0] ; T_start
 0000000C  1A44      SUB         R4,R0,R1 ; Clock_GetTicks?T
 0000000E  ---- Variable 'newTime' assigned to Register 'R4' ----
  848:     if (stim[index].status == statInit)
 0000000E  274C      MOV         R7,#0x4C
 00000010  436F      MUL         R7,R5 ; index
 00000012  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000014  59C6      LDR         R6,[R0,R7]
 00000016  2E01      CMP         R6,#0x1
 00000018  D11D      BNE         L_177  ; T=0x00000056
  850:         if ((stim[index].startRef == 0) && (curTime >= stim[index].startTime))
 0000001A  4800      LDR         R0,=stim + 0x24 ; stim+36
 0000001C  59C0      LDR         R0,[R0,R7]
 0000001E  2800      CMP         R0,#0x0
 00000020  D117      BNE         L_178  ; T=0x00000052
 00000022  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000024  59C1      LDR         R1,[R0,R7]
 00000026  4800      LDR         R0,=curTime ; curTime
 00000028  6800      LDR         R0,[R0,#0x0] ; curTime
 0000002A  4288      CMP         R0,R1
 0000002C  D311      BCC         L_178  ; T=0x00000052
  852:             stim[index].startTime = newTime;
 0000002E  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000030  51C4      STR         R4,[R0,R7] ; newTime
  853:             stim[index].status    = statRun;
 00000032  200A      MOV         R0,#0xA
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 88  

 00000034  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000036  51C8      STR         R0,[R1,R7]
  854:             SetBitsPar(lasBit);   // Trigger high
 00000038  4800      LDR         R0,=lasBit ; lasBit
 0000003A  6800      LDR         R0,[R0,#0x0] ; lasBit
 0000003C  F7FF      BL          SetBitsPar?T  ; T=0x0001  (1)
 0000003E  FFE0      BL          SetBitsPar?T  ; T=0x0001  (2)
  855:             parOutp |= lasBit;
 00000040  4800      LDR         R0,=lasBit ; lasBit
 00000042  6800      LDR         R0,[R0,#0x0] ; lasBit
 00000044  4800      LDR         R1,=parOutp ; parOutp
 00000046  6809      LDR         R1,[R1,#0x0] ; parOutp
 00000048  4301      ORR         R1,R0
 0000004A  4800      LDR         R0,=parOutp ; parOutp
 0000004C  6001      STR         R1,[R0,#0x0] ; parOutp
  856:             return 1;
 0000004E  2001      MOV         R0,#0x1
 00000050  E025      B           L_179  ; T=0x0000009E
  857:         }
 00000052          L_178:
  858:         return 2;
 00000052  2002      MOV         R0,#0x2
 00000054  E023      B           L_179  ; T=0x0000009E
  859:     }
 00000056          L_177:
  861:     if (stim[index].status == statRun)
 00000056  2E0A      CMP         R6,#0xA
 00000058  D120      BNE         L_180  ; T=0x0000009C
  863:         if ((stim[index].stopRef == 0) && (curTime >= stim[index].stopTime))
 0000005A  214C      MOV         R1,#0x4C
 0000005C  4369      MUL         R1,R5 ; index
 0000005E  4800      LDR         R0,=stim + 0x2C ; stim+44
 00000060  5840      LDR         R0,[R0,R1]
 00000062  2800      CMP         R0,#0x0
 00000064  D118      BNE         L_181  ; T=0x00000098
 00000066  214C      MOV         R1,#0x4C
 00000068  4369      MUL         R1,R5 ; index
 0000006A  4800      LDR         R0,=stim + 0x30 ; stim+48
 0000006C  5841      LDR         R1,[R0,R1]
 0000006E  4800      LDR         R0,=curTime ; curTime
 00000070  6800      LDR         R0,[R0,#0x0] ; curTime
 00000072  4288      CMP         R0,R1
 00000074  D310      BCC         L_181  ; T=0x00000098
  865:             ClrBitsPar(lasBit);
 00000076  4800      LDR         R0,=lasBit ; lasBit
 00000078  6800      LDR         R0,[R0,#0x0] ; lasBit
 0000007A  F7FF      BL          ClrBitsPar?T  ; T=0x0001  (1)
 0000007C  FFC1      BL          ClrBitsPar?T  ; T=0x0001  (2)
  866:             stim[index].stopTime = newTime;
 0000007E  214C      MOV         R1,#0x4C
 00000080  4369      MUL         R1,R5 ; index
 00000082  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000084  5044      STR         R4,[R0,R1] ; newTime
  867:             stim[index].status   = statDone;
 00000086  2005      MOV         R0,#0x5
 00000088  4800      LDR         R2,=stim + 0x4 ; stim+4
 0000008A  5050      STR         R0,[R2,R1]
  868:             execEvent(stim[index].event);
 0000008C  4800      LDR         R0,=stim + 0x3C ; stim+60
 0000008E  5840      LDR         R0,[R0,R1]
 00000090  F7FF      BL          execEvent?T  ; T=0x0001  (1)
 00000092  FFB6      BL          execEvent?T  ; T=0x0001  (2)
  869:             return 0;
 00000094  2000      MOV         R0,#0x0
 00000096  E002      B           L_179  ; T=0x0000009E
  870:         }
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 89  

 00000098          L_181:
  871:         return 1;
 00000098  2001      MOV         R0,#0x1
 0000009A  E000      B           L_179  ; T=0x0000009E
  872:     }
 0000009C          L_180:
  873:     return 0;
 0000009C  2000      MOV         R0,#0x0
 0000009E            ; SCOPE-END
  874: }
 0000009E          L_179:
 0000009E  BCF0      POP         {R4-R7}
 000000A0  BC08      POP         {R3}
 000000A2  4718      BX          R3
 000000A4          ENDP ; 'execLas?T'


*** CODE SEGMENT '?PR?getBarState?T?Fart':
  876: void getBarState()
 00000000  B500      PUSH        {LR}
  877: {
 00000002            ; SCOPE-START
  879:     n = sprintf(outBuf,"%d\n",curTime);
 00000002  4800      LDR         R0,=outBuf ; outBuf
 00000004  4800      LDR         R1,=??S_5 ; ??S_5
 00000006  4800      LDR         R2,=curTime ; curTime
 00000008  6812      LDR         R2,[R2,#0x0] ; curTime
 0000000A  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          sprintf?T  ; T=0x0001  (2)
 0000000E  1C01      MOV         R1,R0 ; n
 00000010  ---- Variable 'n' assigned to Register 'R1' ----
  880:     i = UART0_Str(outBuf, n);
 00000010  4800      LDR         R0,=outBuf ; outBuf
 00000012  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000014  FFF5      BL          UART0_Str?T  ; T=0x0001  (2)
  881:     nBuffer[1] = 0;
 00000016  2100      MOV         R1,#0x0
 00000018  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 0000001A  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 0000001C            ; SCOPE-END
  882: }
 0000001C  BC08      POP         {R3}
 0000001E  4718      BX          R3
 00000020          ENDP ; 'getBarState?T'


*** CODE SEGMENT '?PR?getADC?T?Fart':
  884: void getADC()
 00000000  B570      PUSH        {R4-R6,LR}
 00000002  B081      SUB         R13,#0x4
  885: {
 00000004            ; SCOPE-START
  891:     val0 = AdcBuffer.data[0][0];
 00000004  4800      LDR         R0,=AdcBuffer ; AdcBuffer
 00000006  6800      LDR         R0,[R0,#0x0] ; AdcBuffer
 00000008  9000      STR         R0,[R13,#0x0] ; val0
  892:     val1 = AdcBuffer.data[1][0];
 0000000A  4800      LDR         R0,=AdcBuffer + 0x2C ; AdcBuffer+44
 0000000C  6800      LDR         R0,[R0,#0x0] ; AdcBuffer+44
 0000000E  ---- Variable 'val1' assigned to Register 'R0' ----
  893:     val2 = AdcBuffer.data[2][0];
 0000000E  4800      LDR         R1,=AdcBuffer + 0x58 ; AdcBuffer+88
 00000010  6809      LDR         R1,[R1,#0x0] ; AdcBuffer+88
 00000012  ---- Variable 'val2' assigned to Register 'R1' ----
  894:     val3 = AdcBuffer.data[3][0];
 00000012  4800      LDR         R2,=AdcBuffer + 0x84 ; AdcBuffer+132
 00000014  6812      LDR         R2,[R2,#0x0] ; AdcBuffer+132
 00000016  ---- Variable 'val3' assigned to Register 'R2' ----
  895:     val4 = AdcBuffer.data[4][0];
 00000016  4800      LDR         R3,=AdcBuffer + 0xB0 ; AdcBuffer+176
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 90  

 00000018  681B      LDR         R3,[R3,#0x0] ; AdcBuffer+176
 0000001A  ---- Variable 'val4' assigned to Register 'R3' ----
  896:     val5 = AdcBuffer.data[5][0];
 0000001A  4800      LDR         R4,=AdcBuffer + 0xDC ; AdcBuffer+220
 0000001C  6824      LDR         R4,[R4,#0x0] ; AdcBuffer+220
 0000001E  ---- Variable 'val5' assigned to Register 'R4' ----
  897:     val6 = AdcBuffer.data[6][0];
 0000001E  4800      LDR         R5,=AdcBuffer + 0x108 ; AdcBuffer+264
 00000020  682D      LDR         R5,[R5,#0x0] ; AdcBuffer+264
 00000022  ---- Variable 'val6' assigned to Register 'R5' ----
  898:     val7 = AdcBuffer.data[7][0];
 00000022  4800      LDR         R6,=AdcBuffer + 0x134 ; AdcBuffer+308
 00000024  6836      LDR         R6,[R6,#0x0] ; AdcBuffer+308
 00000026  ---- Variable 'val7' assigned to Register 'R6' ----
  900:     n = sprintf(outBuf,"%d %f %f %f %f %f %f %f %f\n",Clock_GetTicks(),val0,val1,val2,val3,val4,val5,val6,val7);
 00000026  B440      PUSH        {R6}
 00000028  B420      PUSH        {R5}
 0000002A  B410      PUSH        {R4}
 0000002C  B408      PUSH        {R3}
 0000002E  B404      PUSH        {R2}
 00000030  B402      PUSH        {R1}
 00000032  B401      PUSH        {R0}
 00000034  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000036  FFE4      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000038  1C02      MOV         R2,R0
 0000003A  4800      LDR         R0,=outBuf ; outBuf
 0000003C  4800      LDR         R1,=??S_10 ; ??S_10
 0000003E  9B07      LDR         R3,[R13,#0x1C] ; val0
 00000040  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000042  FFDE      BL          sprintf?T  ; T=0x0001  (2)
 00000044  B007      ADD         R13,#0x1C
 00000046  1C01      MOV         R1,R0 ; n
 00000048  ---- Variable 'n' assigned to Register 'R1' ----
  901:     i = UART0_Str(outBuf, n);
 00000048  4800      LDR         R0,=outBuf ; outBuf
 0000004A  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 0000004C  FFD9      BL          UART0_Str?T  ; T=0x0001  (2)
  902:     nBuffer[1] = 0;
 0000004E  2100      MOV         R1,#0x0
 00000050  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 00000052  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 00000054            ; SCOPE-END
  903: }
 00000054  B001      ADD         R13,#0x4
 00000056  BC70      POP         {R4-R6}
 00000058  BC08      POP         {R3}
 0000005A  4718      BX          R3
 0000005C          ENDP ; 'getADC?T'


*** CODE SEGMENT '?PR?selectADC?T?Fart':
  904: void selectADC()
 00000000  B500      PUSH        {LR}
  905: {
 00000002            ; SCOPE-START
  909:     n = sprintf(outBuf,"%d\n",curTime);
 00000002  4800      LDR         R0,=outBuf ; outBuf
 00000004  4800      LDR         R1,=??S_5 ; ??S_5
 00000006  4800      LDR         R2,=curTime ; curTime
 00000008  6812      LDR         R2,[R2,#0x0] ; curTime
 0000000A  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          sprintf?T  ; T=0x0001  (2)
 0000000E  1C01      MOV         R1,R0 ; n
 00000010  ---- Variable 'n' assigned to Register 'R1' ----
  910:     i = UART0_Str(outBuf, n);
 00000010  4800      LDR         R0,=outBuf ; outBuf
 00000012  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000014  FFF5      BL          UART0_Str?T  ; T=0x0001  (2)
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 91  

  911:     nBuffer[1] = 0;
 00000016  2100      MOV         R1,#0x0
 00000018  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 0000001A  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 0000001C            ; SCOPE-END
  912: }
 0000001C  BC08      POP         {R3}
 0000001E  4718      BX          R3
 00000020          ENDP ; 'selectADC?T'


*** CODE SEGMENT '?PR?softReset?T?Fart':
  913: int softReset()
 00000000  B500      PUSH        {LR}
  915:     if (InitAll()  != 0)
 00000002  F7FF      BL          InitAll?T  ; T=0x0001  (1)
 00000004  FFFD      BL          InitAll?T  ; T=0x0001  (2)
 00000006  2800      CMP         R0,#0x0 ; InitAll?T
 00000008  D001      BEQ         L_182  ; T=0x0000000E
  916:         return -1;
 0000000A  4800      LDR         R0,=0xFFFFFFFF
 0000000C  E00A      B           L_183  ; T=0x00000024
 0000000E          L_182:
  917:     ClrAllBitsPar();
 0000000E  F7FF      BL          ClrAllBitsPar?T  ; T=0x0001  (1)
 00000010  FFF7      BL          ClrAllBitsPar?T  ; T=0x0001  (2)
  918:     Clock_Reset();
 00000012  F7FF      BL          Clock_Reset?T  ; T=0x0001  (1)
 00000014  FFF5      BL          Clock_Reset?T  ; T=0x0001  (2)
  920:     MCS = statInit;
 00000016  2101      MOV         R1,#0x1
 00000018  4800      LDR         R0,=MCS ; MCS
 0000001A  6001      STR         R1,[R0,#0x0] ; MCS
  921:     nStim = 0;
 0000001C  2100      MOV         R1,#0x0
 0000001E  4800      LDR         R0,=nStim ; nStim
 00000020  6001      STR         R1,[R0,#0x0] ; nStim
  922:     return 0;
 00000022  2000      MOV         R0,#0x0
  923: }
 00000024          L_183:
 00000024  BC08      POP         {R3}
 00000026  4718      BX          R3
 00000028          ENDP ; 'softReset?T'


*** CODE SEGMENT '?PR?Delay?T?Fart':
  933: void Delay (unsigned long a)
 00000000  ---- Variable 'a' assigned to Register 'R0' ----
  935:     while (--a != 0);
 00000000          L_184:
 00000000  1C01      MOV         R1,R0 ; a
 00000002  3901      SUB         R1,#0x1
 00000004  1C08      MOV         R0,R1 ; a
 00000006  2900      CMP         R1,#0x0 ; a
 00000008  D1FA      BNE         L_184  ; T=0x00000000
  936: }
 0000000A  4770      BX          R14
 0000000C          ENDP ; 'Delay?T'


*** CODE SEGMENT '?PR?getWord?T?Fart':
  938: void getWord(void) 
 00000000  B410      PUSH        {R4}
  939: {
 00000002            ; SCOPE-START
  940:     int pnt = 0;
 00000002  2400      MOV         R4,#0x0
 00000004  ---- Variable 'pnt' assigned to Register 'R4' ----
  941:     while ((inBuf[inpPnt] != ';') && (inBuf[inpPnt] != '\0'))
 00000004  E00A      B           L_188  ; T=0x0000001C
 00000006          L_190:
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 92  

  943:         wrd[pnt++] = inBuf[inpPnt++];
 00000006  4800      LDR         R0,=inpPnt ; inpPnt
 00000008  6801      LDR         R1,[R0,#0x0] ; inpPnt
 0000000A  1C0A      MOV         R2,R1
 0000000C  3201      ADD         R2,#0x1
 0000000E  6002      STR         R2,[R0,#0x0] ; inpPnt
 00000010  4800      LDR         R0,=inBuf ; inBuf
 00000012  5C40      LDRB        R0,[R0,R1]
 00000014  1C22      MOV         R2,R4 ; pnt
 00000016  3401      ADD         R4,#0x1
 00000018  4800      LDR         R1,=wrd ; wrd
 0000001A  5488      STRB        R0,[R1,R2]
  944:     }
 0000001C          L_188:
 0000001C  4800      LDR         R0,=inpPnt ; inpPnt
 0000001E  6801      LDR         R1,[R0,#0x0] ; inpPnt
 00000020  4800      LDR         R0,=inBuf ; inBuf
 00000022  5C40      LDRB        R0,[R0,R1]
 00000024  283B      CMP         R0,#0x3B
 00000026  D001      BEQ         L_189  ; T=0x0000002C
 00000028  2800      CMP         R0,#0x0
 0000002A  D1EC      BNE         L_190  ; T=0x00000006
 0000002C          L_189:
  945:     wrd[pnt] = '\0';
 0000002C  2200      MOV         R2,#0x0
 0000002E  4800      LDR         R3,=wrd ; wrd
 00000030  551A      STRB        R2,[R3,R4]
  946:     if (inBuf[inpPnt] == '\0') inpPnt = -1; else inpPnt++;
 00000032  2800      CMP         R0,#0x0
 00000034  D103      BNE         L_193  ; T=0x0000003E
 00000036  4800      LDR         R2,=0xFFFFFFFF
 00000038  4800      LDR         R0,=inpPnt ; inpPnt
 0000003A  6002      STR         R2,[R0,#0x0] ; inpPnt
 0000003C  E002      B           L_194  ; T=0x00000044
 0000003E          L_193:
 0000003E  4800      LDR         R0,=inpPnt ; inpPnt
 00000040  3101      ADD         R1,#0x1
 00000042  6001      STR         R1,[R0,#0x0] ; inpPnt
 00000044          L_194:
 00000044            ; SCOPE-END
  947: }
 00000044  BC10      POP         {R4}
 00000046  4770      BX          R14
 00000048          ENDP ; 'getWord?T'


*** CODE SEGMENT '?PR?getVal?T?Fart':
  949: int getVal(void) 
 00000000  B410      PUSH        {R4}
  950: {
 00000002            ; SCOPE-START
  951:     int val = 0;
 00000002  2000      MOV         R0,#0x0
 00000004  ---- Variable 'val' assigned to Register 'R0' ----
  952:     int pnt = 0;
 00000004  2100      MOV         R1,#0x0
 00000006  ---- Variable 'pnt' assigned to Register 'R1' ----
  953:     if (wrd[0] == '-')
 00000006  4800      LDR         R2,=wrd ; wrd
 00000008  7812      LDRB        R2,[R2,#0x0] ; wrd
 0000000A  2A2D      CMP         R2,#0x2D
 0000000C  D113      BNE         L_195  ; T=0x00000036
  955:         val = -1*(wrd[1] - '0');
 0000000E  4800      LDR         R0,=wrd + 0x1 ; wrd+1
 00000010  7800      LDRB        R0,[R0,#0x0] ; wrd+1
 00000012  3830      SUB         R0,#0x30
 00000014  4800      LDR         R1,=0xFFFFFFFF
 00000016  4348      MUL         R0,R1
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 93  

  956:         pnt = 2;
 00000018  2102      MOV         R1,#0x2
  957:         while (wrd[pnt] != '\0')
 0000001A  E007      B           L_196  ; T=0x0000002C
 0000001C          L_198:
  959:             val *= 10;
 0000001C  230A      MOV         R3,#0xA
 0000001E  4358      MUL         R0,R3
  960:             val -= wrd[pnt++] - '0';
 00000020  1C0C      MOV         R4,R1 ; pnt
 00000022  3101      ADD         R1,#0x1
 00000024  4800      LDR         R3,=wrd ; wrd
 00000026  5D1B      LDRB        R3,[R3,R4]
 00000028  3B30      SUB         R3,#0x30
 0000002A  1AC0      SUB         R0,R3 ; val
  961:         }
 0000002C          L_196:
 0000002C  4800      LDR         R3,=wrd ; wrd
 0000002E  5C5B      LDRB        R3,[R3,R1]
 00000030  2B00      CMP         R3,#0x0
 00000032  D1F3      BNE         L_198  ; T=0x0000001C
  962:     }
 00000034  E00F      B           L_200  ; T=0x00000056
 00000036          L_195:
  965:         val = (wrd[0]- '0');
 00000036  1C10      MOV         R0,R2
 00000038  3830      SUB         R0,#0x30
  966:         pnt = 1;
 0000003A  2101      MOV         R1,#0x1
  967:         while (wrd[pnt] != '\0')
 0000003C  E007      B           L_201  ; T=0x0000004E
 0000003E          L_203:
  969:             val *= 10;
 0000003E  220A      MOV         R2,#0xA
 00000040  4350      MUL         R0,R2
  970:             val += wrd[pnt++] - '0';
 00000042  1C0B      MOV         R3,R1 ; pnt
 00000044  3101      ADD         R1,#0x1
 00000046  4800      LDR         R2,=wrd ; wrd
 00000048  5CD2      LDRB        R2,[R2,R3]
 0000004A  3A30      SUB         R2,#0x30
 0000004C  1880      ADD         R0,R2 ; val
  971:         }
 0000004E          L_201:
 0000004E  4800      LDR         R2,=wrd ; wrd
 00000050  5C52      LDRB        R2,[R2,R1]
 00000052  2A00      CMP         R2,#0x0
 00000054  D1F3      BNE         L_203  ; T=0x0000003E
  972:     }
 00000056          L_200:
  973:     return val;
 00000056            ; SCOPE-END
  974: }
 00000056  BC10      POP         {R4}
 00000058  4770      BX          R14
 0000005A          ENDP ; 'getVal?T'


*** CODE SEGMENT '?PR?splitInput?T?Fart':
  976: void splitInput(void)                   
 00000000  B510      PUSH        {R4,LR}
 00000002  ---- Variable 'i' assigned to Register 'R4' ----
  977: {
 00000002            ; SCOPE-START
  979:     outPnt = 0;
 00000002  2100      MOV         R1,#0x0
 00000004  4800      LDR         R0,=outPnt ; outPnt
 00000006  6001      STR         R1,[R0,#0x0] ; outPnt
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 94  

  980:     if (inBuf[0] == '$')
 00000008  4800      LDR         R0,=inBuf ; inBuf
 0000000A  7800      LDRB        R0,[R0,#0x0] ; inBuf
 0000000C  2824      CMP         R0,#0x24
 0000000E  D164      BNE         L_206  ; T=0x000000DA
  982:         for (i=0; i < 128; i++)
 00000010  2400      MOV         R4,#0x0
 00000012          L_210:
  984:             if (inBuf[i] == ';') inBuf[i] = ' ';
 00000012  4800      LDR         R0,=inBuf ; inBuf
 00000014  5D00      LDRB        R0,[R0,R4]
 00000016  283B      CMP         R0,#0x3B
 00000018  D102      BNE         L_212  ; T=0x00000020
 0000001A  2020      MOV         R0,#0x20
 0000001C  4800      LDR         R1,=inBuf ; inBuf
 0000001E  5508      STRB        R0,[R1,R4]
 00000020          L_212:
  985:             if (inBuf[i] == '$') inBuf[i] = ' ';
 00000020  4800      LDR         R0,=inBuf ; inBuf
 00000022  5D00      LDRB        R0,[R0,R4]
 00000024  2824      CMP         R0,#0x24
 00000026  D102      BNE         L_207  ; T=0x0000002E
 00000028  2020      MOV         R0,#0x20
 0000002A  4800      LDR         R1,=inBuf ; inBuf
 0000002C  5508      STRB        R0,[R1,R4]
  986:         }
 0000002E          L_207:
 0000002E  3401      ADD         R4,#0x1
 00000030  2C80      CMP         R4,#0x80 ; i
 00000032  DBEE      BLT         L_210  ; T=0x00000012
  987:         sscanf(inBuf,"%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f",
 00000034  4800      LDR         R0,=rBuffer + 0x60 ; rBuffer+96
 00000036  B401      PUSH        {R0}
 00000038  4800      LDR         R0,=rBuffer + 0x5C ; rBuffer+92
 0000003A  B401      PUSH        {R0}
 0000003C  4800      LDR         R0,=rBuffer + 0x58 ; rBuffer+88
 0000003E  B401      PUSH        {R0}
 00000040  4800      LDR         R0,=rBuffer + 0x54 ; rBuffer+84
 00000042  B401      PUSH        {R0}
 00000044  4800      LDR         R0,=rBuffer + 0x50 ; rBuffer+80
 00000046  B401      PUSH        {R0}
 00000048  4800      LDR         R0,=rBuffer + 0x4C ; rBuffer+76
 0000004A  B401      PUSH        {R0}
 0000004C  4800      LDR         R0,=rBuffer + 0x48 ; rBuffer+72
 0000004E  B401      PUSH        {R0}
 00000050  4800      LDR         R0,=rBuffer + 0x44 ; rBuffer+68
 00000052  B401      PUSH        {R0}
 00000054  4800      LDR         R0,=rBuffer + 0x40 ; rBuffer+64
 00000056  B401      PUSH        {R0}
 00000058  4800      LDR         R0,=rBuffer + 0x3C ; rBuffer+60
 0000005A  B401      PUSH        {R0}
 0000005C  4800      LDR         R0,=rBuffer + 0x38 ; rBuffer+56
 0000005E  B401      PUSH        {R0}
 00000060  4800      LDR         R0,=rBuffer + 0x34 ; rBuffer+52
 00000062  B401      PUSH        {R0}
 00000064  4800      LDR         R0,=rBuffer + 0x30 ; rBuffer+48
 00000066  B401      PUSH        {R0}
 00000068  4800      LDR         R0,=rBuffer + 0x2C ; rBuffer+44
 0000006A  B401      PUSH        {R0}
 0000006C  4800      LDR         R0,=rBuffer + 0x28 ; rBuffer+40
 0000006E  B401      PUSH        {R0}
 00000070  4800      LDR         R0,=rBuffer + 0x24 ; rBuffer+36
 00000072  B401      PUSH        {R0}
 00000074  4800      LDR         R0,=rBuffer + 0x20 ; rBuffer+32
 00000076  B401      PUSH        {R0}
 00000078  4800      LDR         R0,=rBuffer + 0x1C ; rBuffer+28
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 95  

 0000007A  B401      PUSH        {R0}
 0000007C  4800      LDR         R0,=rBuffer + 0x18 ; rBuffer+24
 0000007E  B401      PUSH        {R0}
 00000080  4800      LDR         R0,=rBuffer + 0x14 ; rBuffer+20
 00000082  B401      PUSH        {R0}
 00000084  4800      LDR         R0,=rBuffer + 0x10 ; rBuffer+16
 00000086  B401      PUSH        {R0}
 00000088  4800      LDR         R0,=rBuffer + 0xC ; rBuffer+12
 0000008A  B401      PUSH        {R0}
 0000008C  4800      LDR         R0,=rBuffer + 0x8 ; rBuffer+8
 0000008E  B401      PUSH        {R0}
 00000090  4800      LDR         R0,=inBuf ; inBuf
 00000092  4800      LDR         R1,=??S_11 ; ??S_11
 00000094  4800      LDR         R2,=rBuffer ; rBuffer
 00000096  4800      LDR         R3,=rBuffer + 0x4 ; rBuffer+4
 00000098  F7FF      BL          sscanf?T  ; T=0x0001  (1)
 0000009A  FFB2      BL          sscanf?T  ; T=0x0001  (2)
 0000009C  B017      ADD         R13,#0x5C
  992:         nBuffer[1] = (int) rBuffer[0];
 0000009E  4800      LDR         R0,=rBuffer ; rBuffer
 000000A0  6800      LDR         R0,[R0,#0x0] ; rBuffer
 000000A2  F7FF      BL          ?C?CASTF?T  ; T=0x0001  (1) ; ?C?CASTF?T
 000000A4  FFAD      BL          ?C?CASTF?T  ; T=0x0001  (2) ; ?C?CASTF?T
 000000A6  4800      LDR         R1,=nBuffer + 0x4 ; nBuffer+4
 000000A8  6008      STR         R0,[R1,#0x0] ; nBuffer+4
  993:         if (nBuffer[1] != cmdNNMod)
 000000AA  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 000000AC  6800      LDR         R0,[R0,#0x0] ; nBuffer+4
 000000AE  287A      CMP         R0,#0x7A
 000000B0  D013      BEQ         L_206  ; T=0x000000DA
  995:             outPnt = 2;
 000000B2  2102      MOV         R1,#0x2
 000000B4  4800      LDR         R0,=outPnt ; outPnt
 000000B6  6001      STR         R1,[R0,#0x0] ; outPnt
  996:             for (i=1; i<24; i++) nBuffer[outPnt++] = (int) rBuffer[i];
 000000B8  2401      MOV         R4,#0x1
 000000BA          L_218:
 000000BA  00A1      LSL         R1,R4,#0x2 ; i
 000000BC  4800      LDR         R0,=rBuffer ; rBuffer
 000000BE  5840      LDR         R0,[R0,R1]
 000000C0  F7FF      BL          ?C?CASTF?T  ; T=0x0001  (1) ; ?C?CASTF?T
 000000C2  FF9E      BL          ?C?CASTF?T  ; T=0x0001  (2) ; ?C?CASTF?T
 000000C4  4800      LDR         R1,=outPnt ; outPnt
 000000C6  680A      LDR         R2,[R1,#0x0] ; outPnt
 000000C8  1C13      MOV         R3,R2
 000000CA  3301      ADD         R3,#0x1
 000000CC  600B      STR         R3,[R1,#0x0] ; outPnt
 000000CE  0092      LSL         R2,R2,#0x2
 000000D0  4800      LDR         R1,=nBuffer ; nBuffer
 000000D2  5088      STR         R0,[R1,R2]
 000000D4  3401      ADD         R4,#0x1
 000000D6  2C18      CMP         R4,#0x18 ; i
 000000D8  DBEF      BLT         L_218  ; T=0x000000BA
  998:     }
 000000DA          L_206:
  999:     nBuffer[0] = outPnt-1;
 000000DA  4800      LDR         R0,=outPnt ; outPnt
 000000DC  6801      LDR         R1,[R0,#0x0] ; outPnt
 000000DE  3901      SUB         R1,#0x1
 000000E0  4800      LDR         R0,=nBuffer ; nBuffer
 000000E2  6001      STR         R1,[R0,#0x0] ; nBuffer
 000000E4            ; SCOPE-END
 1000: }
 000000E4  BC10      POP         {R4}
 000000E6  BC08      POP         {R3}
 000000E8  4718      BX          R3
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 96  

 000000EA          ENDP ; 'splitInput?T'


*** CODE SEGMENT '?PR?InitAll?T?Fart':
 1002: int InitAll()
 00000000  B510      PUSH        {R4,LR}
 00000002  B081      SUB         R13,#0x4
 1003: {
 00000004            ; SCOPE-START
 1007:     LPCinit();
 00000004  F7FF      BL          LPCinit?T  ; T=0x0001  (1)
 00000006  FFFC      BL          LPCinit?T  ; T=0x0001  (2)
 1008:     IODIR0  = 0x00008FF0;   // P0.4-P0.11 as output bit 0..7
 00000008  4800      LDR         R1,=0x8FF0
 0000000A  4800      LDR         R0,=0xE0028008
 0000000C  6001      STR         R1,[R0,#0x0]
 1011:       IOSET0 |= 0x00000FF0; // LED off 
 0000000E  4800      LDR         R2,=0xFF0
 00000010  4800      LDR         R0,=0xE0028004
 00000012  6801      LDR         R1,[R0,#0x0]
 00000014  4311      ORR         R1,R2
 00000016  6001      STR         R1,[R0,#0x0]
 1013:     Clock_Init();           // interrupt 0                         
 00000018  F7FF      BL          Clock_Init?T  ; T=0x0001  (1)
 0000001A  FFF2      BL          Clock_Init?T  ; T=0x0001  (2)
 1014:     I2C_Init();             // interrupt 1
 0000001C  F7FF      BL          I2C_Init?T  ; T=0x0001  (1)
 0000001E  FFF0      BL          I2C_Init?T  ; T=0x0001  (2)
 1015:     UART0_Init();           // interrupt 2
 00000020  F7FF      BL          UART0_Init?T  ; T=0x0001  (1)
 00000022  FFEE      BL          UART0_Init?T  ; T=0x0001  (2)
 1016:        ADC_Init();              // interrupt 3, channel 0
 00000024  F7FF      BL          ADC_Init?T  ; T=0x0001  (1)
 00000026  FFEC      BL          ADC_Init?T  ; T=0x0001  (2)
 1018:     for (n=0; n<4; n++) NNs[n].active = 0;
 00000028  2000      MOV         R0,#0x0
 0000002A  ---- Variable 'n' assigned to Register 'R0' ----
 0000002A          L_223:
 0000002A  2100      MOV         R1,#0x0
 0000002C  4BB9      LDR         R3,=0x2E4
 0000002E  4343      MUL         R3,R0 ; n
 00000030  4800      LDR         R2,=NNs ; NNs
 00000032  50D1      STR         R1,[R2,R3]
 00000034  3001      ADD         R0,#0x1
 00000036  2804      CMP         R0,#0x4 ; n
 00000038  DBF7      BLT         L_223  ; T=0x0000002A
 1020:     for (n=0; n < 2; n++)
 0000003A  2000      MOV         R0,#0x0
 1022:         for (i=0; i < 4; i++)
 0000003C          L_234:
 0000003C  2400      MOV         R4,#0x0
 0000003E  ---- Variable 'i' assigned to Register 'R4' ----
 0000003E          L_233:
 1024:             Leds[n][0][i].data    = 0; 
 0000003E  2100      MOV         R1,#0x0
 00000040  220C      MOV         R2,#0xC
 00000042  4362      MUL         R2,R4 ; i
 00000044  2360      MOV         R3,#0x60
 00000046  4343      MUL         R3,R0 ; n
 00000048  189B      ADD         R3,R2 ; n
 0000004A  4800      LDR         R2,=Leds + 0x4 ; Leds+4
 0000004C  50D1      STR         R1,[R2,R3]
 1025:             Leds[n][0][i].level   = 0;
 0000004E  2100      MOV         R1,#0x0
 00000050  4800      LDR         R2,=Leds + 0x8 ; Leds+8
 00000052  50D1      STR         R1,[R2,R3]
 1026:             Leds[n][1][i].data    = 0; 
 00000054  2100      MOV         R1,#0x0
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 97  

 00000056  220C      MOV         R2,#0xC
 00000058  4362      MUL         R2,R4 ; i
 0000005A  2360      MOV         R3,#0x60
 0000005C  4343      MUL         R3,R0 ; n
 0000005E  189B      ADD         R3,R2 ; n
 00000060  4800      LDR         R2,=Leds + 0x34 ; Leds+52
 00000062  50D1      STR         R1,[R2,R3]
 1027:             Leds[n][1][i].level   = 0;
 00000064  2100      MOV         R1,#0x0
 00000066  220C      MOV         R2,#0xC
 00000068  4362      MUL         R2,R4 ; i
 0000006A  2360      MOV         R3,#0x60
 0000006C  4343      MUL         R3,R0 ; n
 0000006E  189B      ADD         R3,R2 ; n
 00000070  4800      LDR         R2,=Leds + 0x38 ; Leds+56
 00000072  50D1      STR         R1,[R2,R3]
 1028:         }
 00000074  3401      ADD         R4,#0x1
 00000076  2C04      CMP         R4,#0x4 ; i
 00000078  DBE1      BLT         L_233  ; T=0x0000003E
 1029:     }
 0000007A  3001      ADD         R0,#0x1
 0000007C  2802      CMP         R0,#0x2 ; n
 0000007E  DBDD      BLT         L_234  ; T=0x0000003C
 1030:     for (i=0; i < 4; i++)
 00000080  2400      MOV         R4,#0x0
 00000082          L_238:
 1032:         Leds[0][0][i].address = 0xF7; // Front 1-15
 00000082  20F7      MOV         R0,#0xF7
 00000084  220C      MOV         R2,#0xC
 00000086  4362      MUL         R2,R4 ; i
 00000088  4800      LDR         R1,=Leds ; Leds
 0000008A  5088      STR         R0,[R1,R2]
 1033:         Leds[0][1][i].address = 0xFB; // Front 16-31
 0000008C  20FB      MOV         R0,#0xFB
 0000008E  4800      LDR         R1,=Leds + 0x30 ; Leds+48
 00000090  5088      STR         R0,[R1,R2]
 1034:         Leds[1][0][i].address = 0xFD; // Back 101-115
 00000092  20FD      MOV         R0,#0xFD
 00000094  4800      LDR         R1,=Leds + 0x60 ; Leds+96
 00000096  5088      STR         R0,[R1,R2]
 1035:         Leds[1][1][i].address = 0xFE; // Back 116-129
 00000098  20FE      MOV         R0,#0xFE
 0000009A  4800      LDR         R1,=Leds + 0x90 ; Leds+144
 0000009C  5088      STR         R0,[R1,R2]
 1036:     }
 0000009E  3401      ADD         R4,#0x1
 000000A0  2C04      CMP         R4,#0x4 ; i
 000000A2  DBEE      BLT         L_238  ; T=0x00000082
 1038:     Sky[ 0].address  = 0x76;  Sky[ 0].data   = 0; Sky[ 0].level   = 0x00;
 000000A4  2176      MOV         R1,#0x76
 000000A6  4800      LDR         R0,=Sky ; Sky
 000000A8  6001      STR         R1,[R0,#0x0] ; Sky
 000000AA  2100      MOV         R1,#0x0
 000000AC  4800      LDR         R0,=Sky + 0x4 ; Sky+4
 000000AE  6001      STR         R1,[R0,#0x0] ; Sky+4
 000000B0  2100      MOV         R1,#0x0
 000000B2  4800      LDR         R0,=Sky + 0x8 ; Sky+8
 000000B4  6001      STR         R1,[R0,#0x0] ; Sky+8
 1039:     Sky[ 1].address  = 0x74;  Sky[ 1].data   = 0; Sky[ 1].level   = 0x00;
 000000B6  2174      MOV         R1,#0x74
 000000B8  4800      LDR         R0,=Sky + 0xC ; Sky+12
 000000BA  6001      STR         R1,[R0,#0x0] ; Sky+12
 000000BC  2100      MOV         R1,#0x0
 000000BE  4800      LDR         R0,=Sky + 0x10 ; Sky+16
 000000C0  6001      STR         R1,[R0,#0x0] ; Sky+16
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 98  

 000000C2  2100      MOV         R1,#0x0
 000000C4  4800      LDR         R0,=Sky + 0x14 ; Sky+20
 000000C6  6001      STR         R1,[R0,#0x0] ; Sky+20
 1040:     Sky[ 2].address  = 0x74;  Sky[ 2].data   = 0; Sky[ 2].level   = 0x00;
 000000C8  2174      MOV         R1,#0x74
 000000CA  4800      LDR         R0,=Sky + 0x18 ; Sky+24
 000000CC  6001      STR         R1,[R0,#0x0] ; Sky+24
 000000CE  2100      MOV         R1,#0x0
 000000D0  4800      LDR         R0,=Sky + 0x1C ; Sky+28
 000000D2  6001      STR         R1,[R0,#0x0] ; Sky+28
 000000D4  2100      MOV         R1,#0x0
 000000D6  4800      LDR         R0,=Sky + 0x20 ; Sky+32
 000000D8  6001      STR         R1,[R0,#0x0] ; Sky+32
 1041:     Sky[ 3].address  = 0x74;  Sky[ 3].data   = 0; Sky[ 3].level   = 0x00;
 000000DA  2174      MOV         R1,#0x74
 000000DC  4800      LDR         R0,=Sky + 0x24 ; Sky+36
 000000DE  6001      STR         R1,[R0,#0x0] ; Sky+36
 000000E0  2100      MOV         R1,#0x0
 000000E2  4800      LDR         R0,=Sky + 0x28 ; Sky+40
 000000E4  6001      STR         R1,[R0,#0x0] ; Sky+40
 000000E6  2100      MOV         R1,#0x0
 000000E8  4800      LDR         R0,=Sky + 0x2C ; Sky+44
 000000EA  6001      STR         R1,[R0,#0x0] ; Sky+44
 1042:     Sky[ 4].address  = 0x74;  Sky[ 4].data   = 0; Sky[ 4].level   = 0x00;
 000000EC  2174      MOV         R1,#0x74
 000000EE  4800      LDR         R0,=Sky + 0x30 ; Sky+48
 000000F0  6001      STR         R1,[R0,#0x0] ; Sky+48
 000000F2  2100      MOV         R1,#0x0
 000000F4  4800      LDR         R0,=Sky + 0x34 ; Sky+52
 000000F6  6001      STR         R1,[R0,#0x0] ; Sky+52
 000000F8  2100      MOV         R1,#0x0
 000000FA  4800      LDR         R0,=Sky + 0x38 ; Sky+56
 000000FC  6001      STR         R1,[R0,#0x0] ; Sky+56
 1043:     Sky[ 5].address  = 0x74;  Sky[ 5].data   = 0; Sky[ 5].level   = 0x00;
 000000FE  2174      MOV         R1,#0x74
 00000100  4800      LDR         R0,=Sky + 0x3C ; Sky+60
 00000102  6001      STR         R1,[R0,#0x0] ; Sky+60
 00000104  2100      MOV         R1,#0x0
 00000106  4800      LDR         R0,=Sky + 0x40 ; Sky+64
 00000108  6001      STR         R1,[R0,#0x0] ; Sky+64
 0000010A  2100      MOV         R1,#0x0
 0000010C  4800      LDR         R0,=Sky + 0x44 ; Sky+68
 0000010E  6001      STR         R1,[R0,#0x0] ; Sky+68
 1044:     Sky[ 6].address  = 0x74;  Sky[ 6].data   = 0; Sky[ 6].level   = 0x00;
 00000110  2174      MOV         R1,#0x74
 00000112  4800      LDR         R0,=Sky + 0x48 ; Sky+72
 00000114  6001      STR         R1,[R0,#0x0] ; Sky+72
 00000116  2100      MOV         R1,#0x0
 00000118  4800      LDR         R0,=Sky + 0x4C ; Sky+76
 0000011A  6001      STR         R1,[R0,#0x0] ; Sky+76
 0000011C  2100      MOV         R1,#0x0
 0000011E  4800      LDR         R0,=Sky + 0x50 ; Sky+80
 00000120  6001      STR         R1,[R0,#0x0] ; Sky+80
 1045:     Sky[ 7].address  = 0x74;  Sky[ 7].data   = 0; Sky[ 7].level   = 0x00;
 00000122  2174      MOV         R1,#0x74
 00000124  4800      LDR         R0,=Sky + 0x54 ; Sky+84
 00000126  6001      STR         R1,[R0,#0x0] ; Sky+84
 00000128  2100      MOV         R1,#0x0
 0000012A  4800      LDR         R0,=Sky + 0x58 ; Sky+88
 0000012C  6001      STR         R1,[R0,#0x0] ; Sky+88
 0000012E  2100      MOV         R1,#0x0
 00000130  4800      LDR         R0,=Sky + 0x5C ; Sky+92
 00000132  6001      STR         R1,[R0,#0x0] ; Sky+92
 1046:     Sky[ 8].address  = 0x74;  Sky[ 8].data   = 0; Sky[ 8].level   = 0x00;
 00000134  2174      MOV         R1,#0x74
 00000136  4800      LDR         R0,=Sky + 0x60 ; Sky+96
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 99  

 00000138  6001      STR         R1,[R0,#0x0] ; Sky+96
 0000013A  2100      MOV         R1,#0x0
 0000013C  4800      LDR         R0,=Sky + 0x64 ; Sky+100
 0000013E  6001      STR         R1,[R0,#0x0] ; Sky+100
 00000140  2100      MOV         R1,#0x0
 00000142  4800      LDR         R0,=Sky + 0x68 ; Sky+104
 00000144  6001      STR         R1,[R0,#0x0] ; Sky+104
 1047:     Sky[ 9].address  = 0x76;  Sky[ 9].data   = 0; Sky[ 9].level   = 0x00;
 00000146  2176      MOV         R1,#0x76
 00000148  4800      LDR         R0,=Sky + 0x6C ; Sky+108
 0000014A  6001      STR         R1,[R0,#0x0] ; Sky+108
 0000014C  2100      MOV         R1,#0x0
 0000014E  4800      LDR         R0,=Sky + 0x70 ; Sky+112
 00000150  6001      STR         R1,[R0,#0x0] ; Sky+112
 00000152  2100      MOV         R1,#0x0
 00000154  4800      LDR         R0,=Sky + 0x74 ; Sky+116
 00000156  6001      STR         R1,[R0,#0x0] ; Sky+116
 1048:     Sky[10].address  = 0x76;  Sky[10].data   = 0; Sky[10].level   = 0x00;
 00000158  2176      MOV         R1,#0x76
 0000015A  4800      LDR         R0,=Sky + 0x78 ; Sky+120
 0000015C  6001      STR         R1,[R0,#0x0] ; Sky+120
 0000015E  2100      MOV         R1,#0x0
 00000160  4800      LDR         R0,=Sky + 0x7C ; Sky+124
 00000162  6001      STR         R1,[R0,#0x0] ; Sky+124
 00000164  2100      MOV         R1,#0x0
 00000166  4800      LDR         R0,=Sky + 0x80 ; Sky+128
 00000168  6001      STR         R1,[R0,#0x0] ; Sky+128
 1049:     Sky[11].address  = 0x76;  Sky[11].data   = 0; Sky[11].level   = 0x00;
 0000016A  2176      MOV         R1,#0x76
 0000016C  4800      LDR         R0,=Sky + 0x84 ; Sky+132
 0000016E  6001      STR         R1,[R0,#0x0] ; Sky+132
 00000170  2100      MOV         R1,#0x0
 00000172  4800      LDR         R0,=Sky + 0x88 ; Sky+136
 00000174  6001      STR         R1,[R0,#0x0] ; Sky+136
 00000176  2100      MOV         R1,#0x0
 00000178  4800      LDR         R0,=Sky + 0x8C ; Sky+140
 0000017A  6001      STR         R1,[R0,#0x0] ; Sky+140
 1050:     Sky[12].address  = 0x76;  Sky[12].data   = 0; Sky[12].level   = 0x00;
 0000017C  2176      MOV         R1,#0x76
 0000017E  4800      LDR         R0,=Sky + 0x90 ; Sky+144
 00000180  6001      STR         R1,[R0,#0x0] ; Sky+144
 00000182  2100      MOV         R1,#0x0
 00000184  4800      LDR         R0,=Sky + 0x94 ; Sky+148
 00000186  6001      STR         R1,[R0,#0x0] ; Sky+148
 00000188  2100      MOV         R1,#0x0
 0000018A  4800      LDR         R0,=Sky + 0x98 ; Sky+152
 0000018C  6001      STR         R1,[R0,#0x0] ; Sky+152
 1051:     ClearSky();
 0000018E  F7FF      BL          ClearSky?T  ; T=0x0001  (1)
 00000190  FF37      BL          ClearSky?T  ; T=0x0001  (2)
 1052:     ClearArc();
 00000192  F7FF      BL          ClearArc?T  ; T=0x0001  (1)
 00000194  FF35      BL          ClearArc?T  ; T=0x0001  (2)
 1054:     buffer[0] = 0x00;
 00000196  2100      MOV         R1,#0x0
 00000198  A800      ADD         R0,R13,#0x0
 0000019A  7001      STRB        R1,[R0,#0x0] ; buffer
 1055:     buffer[1] = 0x76;
 0000019C  2176      MOV         R1,#0x76
 0000019E  2001      MOV         R0,#0x1
 000001A0  4468      ADD         R0,R13
 000001A2  7001      STRB        R1,[R0,#0x0] ; buffer+1
 1056:     buffer[2] = 0x00;                                                          
 000001A4  2100      MOV         R1,#0x0
 000001A6  2002      MOV         R0,#0x2
 000001A8  4468      ADD         R0,R13
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 100 

 000001AA  7001      STRB        R1,[R0,#0x0] ; buffer+2
 1057:     buffer[3] = 0x00;
 000001AC  2100      MOV         R1,#0x0
 000001AE  2003      MOV         R0,#0x3
 000001B0  4468      ADD         R0,R13
 000001B2  7001      STRB        R1,[R0,#0x0] ; buffer+3
 1058:     I2C_SendByte(0x70, 4, buffer);
 000001B4  AA00      ADD         R2,R13,#0x0
 000001B6  2070      MOV         R0,#0x70
 000001B8  2104      MOV         R1,#0x4
 000001BA  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 000001BC  FF21      BL          I2C_SendByte?T  ; T=0x0001  (2)
 1060:     for (i=0; i < 8; i++)
 000001BE  2400      MOV         R4,#0x0
 000001C0          L_243:
 1062:         buffer[0] = boards[i];
 000001C0  00A1      LSL         R1,R4,#0x2 ; i
 000001C2  4800      LDR         R0,=boards ; boards
 000001C4  5841      LDR         R1,[R0,R1]
 000001C6  A800      ADD         R0,R13,#0x0
 000001C8  7001      STRB        R1,[R0,#0x0] ; buffer
 1063:         I2C_SendByte(0x4E, 1, buffer);
 000001CA  AA00      ADD         R2,R13,#0x0
 000001CC  204E      MOV         R0,#0x4E
 000001CE  2101      MOV         R1,#0x1
 000001D0  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 000001D2  FF16      BL          I2C_SendByte?T  ; T=0x0001  (2)
 1064:         buffer[0] = 0xFF;
 000001D4  21FF      MOV         R1,#0xFF
 000001D6  A800      ADD         R0,R13,#0x0
 000001D8  7001      STRB        R1,[R0,#0x0] ; buffer
 1065:         I2C_SendByte(0x42, 1, buffer);
 000001DA  AA00      ADD         R2,R13,#0x0
 000001DC  2042      MOV         R0,#0x42
 000001DE  2101      MOV         R1,#0x1
 000001E0  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 000001E2  FF0E      BL          I2C_SendByte?T  ; T=0x0001  (2)
 1066:         I2C_SendByte(0x44, 1, buffer);
 000001E4  AA00      ADD         R2,R13,#0x0
 000001E6  2044      MOV         R0,#0x44
 000001E8  2101      MOV         R1,#0x1
 000001EA  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 000001EC  FF09      BL          I2C_SendByte?T  ; T=0x0001  (2)
 1067:         statusBoards[i][0] = 0xFF;  
 000001EE  20FF      MOV         R0,#0xFF
 000001F0  220C      MOV         R2,#0xC
 000001F2  4362      MUL         R2,R4 ; i
 000001F4  4800      LDR         R1,=statusBoards ; statusBoards
 000001F6  5088      STR         R0,[R1,R2]
 1068:         statusBoards[i][1] = 0xFF;  
 000001F8  20FF      MOV         R0,#0xFF
 000001FA  4800      LDR         R1,=statusBoards + 0x4 ; statusBoards+4
 000001FC  5088      STR         R0,[R1,R2]
 1069:         statusBoards[i][2] = 0xFF;  
 000001FE  20FF      MOV         R0,#0xFF
 00000200  4800      LDR         R1,=statusBoards + 0x8 ; statusBoards+8
 00000202  5088      STR         R0,[R1,R2]
 1070:     }
 00000204  3401      ADD         R4,#0x1
 00000206  2C08      CMP         R4,#0x8 ; i
 00000208  DBDA      BLT         L_243  ; T=0x000001C0
 1072:     return(0);
 0000020A  2000      MOV         R0,#0x0
 0000020C            ; SCOPE-END
 1073: }
 0000020C  B001      ADD         R13,#0x4
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 101 

 0000020E  BC10      POP         {R4}
 00000210  BC08      POP         {R3}
 00000212  4718      BX          R3
 00000214          ENDP ; 'InitAll?T'


*** CODE SEGMENT '?PR?ClearArc?T?Fart':
 1085: void ClearArc(void)
 00000000  B510      PUSH        {R4,LR}
 1086: {
 00000002            ; SCOPE-START
 1088:     for (index = 1; index <= 31; index++)
 00000002  2401      MOV         R4,#0x1
 00000004  ---- Variable 'index' assigned to Register 'R4' ----
 00000004          L_249:
 1089:         LedOnOff(index, 0, OFF);
 00000004  1C20      MOV         R0,R4
 00000006  2100      MOV         R1,#0x0
 00000008  2200      MOV         R2,#0x0
 0000000A  F7FF      BL          LedOnOff?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          LedOnOff?T  ; T=0x0001  (2)
 0000000E  3401      ADD         R4,#0x1
 00000010  2C1F      CMP         R4,#0x1F ; index
 00000012  DDF7      BLE         L_249  ; T=0x00000004
 1090:     for (index = 101; index <=129; index++)
 00000014  2465      MOV         R4,#0x65
 00000016          L_254:
 1091:         LedOnOff(index, 0, OFF);
 00000016  1C20      MOV         R0,R4
 00000018  2100      MOV         R1,#0x0
 0000001A  2200      MOV         R2,#0x0
 0000001C  F7FF      BL          LedOnOff?T  ; T=0x0001  (1)
 0000001E  FFF0      BL          LedOnOff?T  ; T=0x0001  (2)
 00000020  3401      ADD         R4,#0x1
 00000022  2C81      CMP         R4,#0x81 ; index
 00000024  DDF7      BLE         L_254  ; T=0x00000016
 00000026            ; SCOPE-END
 1092: }
 00000026  BC10      POP         {R4}
 00000028  BC08      POP         {R3}
 0000002A  4718      BX          R3
 0000002C          ENDP ; 'ClearArc?T'


*** CODE SEGMENT '?PR?ClearSky?T?Fart':
 1094: void ClearSky(void)
 00000000  B530      PUSH        {R4-R5,LR}
 1095: {
 00000002            ; SCOPE-START
 1097:     SkyOnOff(0, 1, 0, OFF);
 00000002  2000      MOV         R0,#0x0
 00000004  2101      MOV         R1,#0x1
 00000006  2200      MOV         R2,#0x0
 00000008  2300      MOV         R3,#0x0
 0000000A  F7FF      BL          SkyOnOff?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          SkyOnOff?T  ; T=0x0001  (2)
 1098:     SkyOnOff(0, 2, 0, OFF);
 0000000E  2000      MOV         R0,#0x0
 00000010  2102      MOV         R1,#0x2
 00000012  2200      MOV         R2,#0x0
 00000014  2300      MOV         R3,#0x0
 00000016  F7FF      BL          SkyOnOff?T  ; T=0x0001  (1)
 00000018  FFF3      BL          SkyOnOff?T  ; T=0x0001  (2)
 1099:     for (spaak = 1; spaak <= 12; spaak++)
 0000001A  2401      MOV         R4,#0x1
 0000001C  ---- Variable 'spaak' assigned to Register 'R4' ----
 1101:         for (led = 0; led <= 7; led++)
 0000001C          L_265:
 0000001C  2500      MOV         R5,#0x0
 0000001E  ---- Variable 'led' assigned to Register 'R5' ----
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 102 

 0000001E          L_264:
 1103:             SkyOnOff(spaak, led, 0, OFF);
 0000001E  1C20      MOV         R0,R4
 00000020  1C29      MOV         R1,R5
 00000022  2200      MOV         R2,#0x0
 00000024  2300      MOV         R3,#0x0
 00000026  F7FF      BL          SkyOnOff?T  ; T=0x0001  (1)
 00000028  FFEB      BL          SkyOnOff?T  ; T=0x0001  (2)
 1104:         }
 0000002A  3501      ADD         R5,#0x1
 0000002C  2D07      CMP         R5,#0x7 ; led
 0000002E  DDF6      BLE         L_264  ; T=0x0000001E
 1105:     }
 00000030  3401      ADD         R4,#0x1
 00000032  2C0C      CMP         R4,#0xC ; spaak
 00000034  DDF2      BLE         L_265  ; T=0x0000001C
 00000036            ; SCOPE-END
 1106: }
 00000036  BC30      POP         {R4-R5}
 00000038  BC08      POP         {R3}
 0000003A  4718      BX          R3
 0000003C          ENDP ; 'ClearSky?T'


*** CODE SEGMENT '?PR?LedOnOff?T?Fart':
 1108: void LedOnOff(int index, int level, int OnOff)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C15      MOV         R5,R2 ; OnOff
 00000004  ---- Variable 'OnOff' assigned to Register 'R5' ----
 00000004  1C0E      MOV         R6,R1 ; level
 00000006  ---- Variable 'level' assigned to Register 'R6' ----
 00000006  1C07      MOV         R7,R0 ; index
 00000008  ---- Variable 'index' assigned to Register 'R7' ----
 00000008  B0A9      SUB         R13,#0xA4
 0000000A  ---- Variable 'led' assigned to Register 'R4' ----
 1109: {
 0000000A            ; SCOPE-START
 1112:     int PWM1 = 0x14;    // (autoincrement (16) + register
 0000000A  2014      MOV         R0,#0x14
 0000000C  9004      STR         R0,[R13,#0x10] ; PWM1
 1113:     int LS0  = 0x06;    
 0000000E  2006      MOV         R0,#0x6
 00000010  9005      STR         R0,[R13,#0x14] ; LS0
 1114:     int LS1  = 0x07;    
 00000012  2007      MOV         R0,#0x7
 00000014  9006      STR         R0,[R13,#0x18] ; LS1
 1115:     int LS2  = 0x08;    
 00000016  2008      MOV         R0,#0x8
 00000018  9007      STR         R0,[R13,#0x1C] ; LS2
 1116:     int LS3  = 0x09;
 0000001A  2009      MOV         R0,#0x9
 0000001C  9008      STR         R0,[R13,#0x20] ; LS3
 1123:     int ledsIndex[] = { 16,15,14,13,12,11,10, 9, 8, 7, 6, 5, 4, 3, 2, 1,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18
             -,17};
 0000001E  4800      LDR         R1,=?tpl?0004 ; ?tpl?0004
 00000020  A809      ADD         R0,R13,#0x24
 00000022  2280      MOV         R2,#0x80
 00000024          L_569:
 00000024  780B      LDRB        R3,[R1,#0x0]
 00000026  7003      STRB        R3,[R0,#0x0]
 00000028  1C49      ADD         R1,R1,#0x1
 0000002A  1C40      ADD         R0,R0,#0x1
 0000002C  1E52      SUB         R2,R2,#0x1
 0000002E  D1F9      BNE         L_569  ; T=0x00000024
 1128:     if (index > 100) led = index - 100; else led = index; // Range now 1..32 
 00000030  2F64      CMP         R7,#0x64 ; index
 00000032  DD02      BLE         L_266  ; T=0x0000003A
 00000034  1C3C      MOV         R4,R7 ; index
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 103 

 00000036  3C64      SUB         R4,#0x64
 00000038  E000      B           L_267  ; T=0x0000003C
 0000003A          L_266:
 0000003A  1C3C      MOV         R4,R7 ; led
 0000003C          L_267:
 1129:     led = ledsIndex[led-1];                               // for the electronincs
 0000003C  00A1      LSL         R1,R4,#0x2 ; led
 0000003E  A808      ADD         R0,R13,#0x20
 00000040  5844      LDR         R4,[R0,R1]
 1130:     if (led <= 16) ic = 0; else ic = 1;                   // IC 1..2
 00000042  2C10      CMP         R4,#0x10 ; led
 00000044  DC02      BGT         L_268  ; T=0x0000004C
 00000046  2000      MOV         R0,#0x0
 00000048  9001      STR         R0,[R13,#0x4] ; ic
 0000004A  E001      B           L_269  ; T=0x00000050
 0000004C          L_268:
 0000004C  2001      MOV         R0,#0x1
 0000004E  9001      STR         R0,[R13,#0x4] ; ic
 00000050          L_269:
 1131:     led = led - ic*16;                                    // led 1..16
 00000050  9A01      LDR         R2,[R13,#0x4] ; ic
 00000052  0110      LSL         R0,R2,#0x4
 00000054  1A24      SUB         R4,R0 ; led
 1132:     ls = (led-1)/4;                                       // led selector 1..4
 00000056  1C20      MOV         R0,R4 ; led
 00000058  3801      SUB         R0,#0x1
 0000005A  2104      MOV         R1,#0x4
 0000005C  F7FF      BL          ?C?SDIV?T  ; T=0x0001  (1) ; ?C?SDIV?T
 0000005E  FFD0      BL          ?C?SDIV?T  ; T=0x0001  (2) ; ?C?SDIV?T
 00000060  1C08      MOV         R0,R1
 00000062  9002      STR         R0,[R13,#0x8] ; ls
 1134:     if (index < 100) n = 0; else n = 1;
 00000064  2F64      CMP         R7,#0x64 ; index
 00000066  DA02      BGE         L_270  ; T=0x0000006E
 00000068  2000      MOV         R0,#0x0
 0000006A  9000      STR         R0,[R13,#0x0] ; n
 0000006C  E001      B           L_271  ; T=0x00000072
 0000006E          L_270:
 0000006E  2001      MOV         R0,#0x1
 00000070  9000      STR         R0,[R13,#0x0] ; n
 00000072          L_271:
 1135:     buffer[0] = Leds[n][ic][ls].address;                  // address led-IC
 00000072  2030      MOV         R0,#0x30
 00000074  4350      MUL         R0,R2
 00000076  9900      LDR         R1,[R13,#0x0] ; n
 00000078  2260      MOV         R2,#0x60
 0000007A  4351      MUL         R1,R2
 0000007C  1809      ADD         R1,R0
 0000007E  9802      LDR         R0,[R13,#0x8] ; ls
 00000080  220C      MOV         R2,#0xC
 00000082  4350      MUL         R0,R2
 00000084  1809      ADD         R1,R0
 00000086  4800      LDR         R0,=Leds ; Leds
 00000088  5841      LDR         R1,[R0,R1]
 0000008A  A803      ADD         R0,R13,#0xC
 0000008C  7001      STRB        R1,[R0,#0x0] ; buffer
 1136:      I2C_SendByte(0x72, 1, buffer);                       // load pre-selection with address
 0000008E  AA03      ADD         R2,R13,#0xC
 00000090  2072      MOV         R0,#0x72
 00000092  2101      MOV         R1,#0x1
 00000094  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 00000096  FFB4      BL          I2C_SendByte?T  ; T=0x0001  (2)
 1139:     buffer[0] = PWM1;               // subaddress
 00000098  9904      LDR         R1,[R13,#0x10] ; PWM1
 0000009A  A803      ADD         R0,R13,#0xC
 0000009C  7001      STRB        R1,[R0,#0x0] ; buffer
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 104 

 1140:     buffer[1] = 0;                  // PSC1
 0000009E  2100      MOV         R1,#0x0
 000000A0  200D      MOV         R0,#0xD
 000000A2  4468      ADD         R0,R13
 000000A4  7001      STRB        R1,[R0,#0x0] ; buffer+1
 1141:     buffer[2] = level & 0xFF;
 000000A6  21FF      MOV         R1,#0xFF
 000000A8  4031      AND         R1,R6 ; level
 000000AA  200E      MOV         R0,#0xE
 000000AC  4468      ADD         R0,R13
 000000AE  7001      STRB        R1,[R0,#0x0] ; buffer+2
 1142:     I2C_SendByte(0xC0, 3, buffer);  // preselection determines the address of C0
 000000B0  AA03      ADD         R2,R13,#0xC
 000000B2  20C0      MOV         R0,#0xC0
 000000B4  2103      MOV         R1,#0x3
 000000B6  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 000000B8  FFA3      BL          I2C_SendByte?T  ; T=0x0001  (2)
 1145:     led = (led-1) % 4;
 000000BA  1C20      MOV         R0,R4 ; led
 000000BC  3801      SUB         R0,#0x1
 000000BE  2104      MOV         R1,#0x4
 000000C0  F7FF      BL          ?C?SDIV?T  ; T=0x0001  (1) ; ?C?SDIV?T
 000000C2  FF9E      BL          ?C?SDIV?T  ; T=0x0001  (2) ; ?C?SDIV?T
 000000C4  1C01      MOV         R1,R0
 000000C6  1C0C      MOV         R4,R1 ; led
 1146:     tmp = (0x03 << (2*(led)));      // 11 = blink at PWM1 rate
 000000C8  0060      LSL         R0,R4,#0x1 ; led
 000000CA  2303      MOV         R3,#0x3
 000000CC  4083      LSL         R3,R0
 000000CE  ---- Variable 'tmp' assigned to Register 'R3' ----
 1147:     if (OnOff == ON)
 000000CE  2D01      CMP         R5,#0x1 ; OnOff
 000000D0  D110      BNE         L_272  ; T=0x000000F4
 1148:         Leds[n][ic][ls].data |= tmp;
 000000D2  9801      LDR         R0,[R13,#0x4] ; ic
 000000D4  2130      MOV         R1,#0x30
 000000D6  4348      MUL         R0,R1
 000000D8  9900      LDR         R1,[R13,#0x0] ; n
 000000DA  2260      MOV         R2,#0x60
 000000DC  4351      MUL         R1,R2
 000000DE  1809      ADD         R1,R0
 000000E0  9802      LDR         R0,[R13,#0x8] ; ls
 000000E2  220C      MOV         R2,#0xC
 000000E4  4350      MUL         R0,R2
 000000E6  1809      ADD         R1,R0
 000000E8  4800      LDR         R0,=Leds + 0x4 ; Leds+4
 000000EA  1840      ADD         R0,R1 ; Leds+4
 000000EC  6801      LDR         R1,[R0,#0x0]
 000000EE  4319      ORR         R1,R3 ; tmp
 000000F0  6001      STR         R1,[R0,#0x0]
 000000F2  E00F      B           L_273  ; T=0x00000114
 000000F4          L_272:
 1150:         Leds[n][ic][ls].data &= ~tmp;
 000000F4  9801      LDR         R0,[R13,#0x4] ; ic
 000000F6  2130      MOV         R1,#0x30
 000000F8  4348      MUL         R0,R1
 000000FA  9900      LDR         R1,[R13,#0x0] ; n
 000000FC  2260      MOV         R2,#0x60
 000000FE  4351      MUL         R1,R2
 00000100  1809      ADD         R1,R0
 00000102  9802      LDR         R0,[R13,#0x8] ; ls
 00000104  220C      MOV         R2,#0xC
 00000106  4350      MUL         R0,R2
 00000108  1809      ADD         R1,R0
 0000010A  4800      LDR         R0,=Leds + 0x4 ; Leds+4
 0000010C  1840      ADD         R0,R1 ; Leds+4
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 105 

 0000010E  6801      LDR         R1,[R0,#0x0]
 00000110  4399      BIC         R1,R3 ; tmp
 00000112  6001      STR         R1,[R0,#0x0]
 00000114          L_273:
 1152:     switch(ls)
 00000114  9802      LDR         R0,[R13,#0x8] ; ls
 00000116  2801      CMP         R0,#0x1
 00000118  D009      BEQ         L_276  ; T=0x0000012E
 0000011A  2802      CMP         R0,#0x2
 0000011C  D00B      BEQ         L_277  ; T=0x00000136
 0000011E  2803      CMP         R0,#0x3
 00000120  D00D      BEQ         L_278  ; T=0x0000013E
 00000122  2800      CMP         R0,#0x0
 00000124  D10E      BNE         L_274  ; T=0x00000144
 1154:     case 0: buffer[0] = LS0; break;
 00000126          L_275:
 00000126  9905      LDR         R1,[R13,#0x14] ; LS0
 00000128  A803      ADD         R0,R13,#0xC
 0000012A  7001      STRB        R1,[R0,#0x0] ; buffer
 0000012C  E00A      B           L_274  ; T=0x00000144
 1155:     case 1: buffer[0] = LS1; break;
 0000012E          L_276:
 0000012E  9906      LDR         R1,[R13,#0x18] ; LS1
 00000130  A803      ADD         R0,R13,#0xC
 00000132  7001      STRB        R1,[R0,#0x0] ; buffer
 00000134  E006      B           L_274  ; T=0x00000144
 1156:     case 2: buffer[0] = LS2; break;
 00000136          L_277:
 00000136  9907      LDR         R1,[R13,#0x1C] ; LS2
 00000138  A803      ADD         R0,R13,#0xC
 0000013A  7001      STRB        R1,[R0,#0x0] ; buffer
 0000013C  E002      B           L_274  ; T=0x00000144
 1157:     case 3: buffer[0] = LS3; break;
 0000013E          L_278:
 0000013E  9908      LDR         R1,[R13,#0x20] ; LS3
 00000140  A803      ADD         R0,R13,#0xC
 00000142  7001      STRB        R1,[R0,#0x0] ; buffer
 1158:     }
 00000144          L_274:
 1159:     buffer[1] = Leds[n][ic][ls].data & 0xFF;
 00000144  9801      LDR         R0,[R13,#0x4] ; ic
 00000146  2130      MOV         R1,#0x30
 00000148  4348      MUL         R0,R1
 0000014A  9900      LDR         R1,[R13,#0x0] ; n
 0000014C  2260      MOV         R2,#0x60
 0000014E  4351      MUL         R1,R2
 00000150  1809      ADD         R1,R0
 00000152  9802      LDR         R0,[R13,#0x8] ; ls
 00000154  220C      MOV         R2,#0xC
 00000156  4350      MUL         R0,R2
 00000158  1809      ADD         R1,R0
 0000015A  4800      LDR         R0,=Leds + 0x4 ; Leds+4
 0000015C  5841      LDR         R1,[R0,R1]
 0000015E  20FF      MOV         R0,#0xFF
 00000160  4001      AND         R1,R0
 00000162  200D      MOV         R0,#0xD
 00000164  4468      ADD         R0,R13
 00000166  7001      STRB        R1,[R0,#0x0] ; buffer+1
 1160:     I2C_SendByte(0xC0, 2, buffer);
 00000168  AA03      ADD         R2,R13,#0xC
 0000016A  20C0      MOV         R0,#0xC0
 0000016C  2102      MOV         R1,#0x2
 0000016E  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 00000170  FF47      BL          I2C_SendByte?T  ; T=0x0001  (2)
 1162:     buffer[0] = 0xFF;
 00000172  21FF      MOV         R1,#0xFF
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 106 

 00000174  A803      ADD         R0,R13,#0xC
 00000176  7001      STRB        R1,[R0,#0x0] ; buffer
 1163:     I2C_SendByte(0x72,1,buffer);
 00000178  AA03      ADD         R2,R13,#0xC
 0000017A  2072      MOV         R0,#0x72
 0000017C  2101      MOV         R1,#0x1
 0000017E  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 00000180  FF3F      BL          I2C_SendByte?T  ; T=0x0001  (2)
 00000182            ; SCOPE-END
 1165: }
 00000182  B029      ADD         R13,#0xA4
 00000184  BCF0      POP         {R4-R7}
 00000186  BC08      POP         {R3}
 00000188  4718      BX          R3
 0000018A          ENDP ; 'LedOnOff?T'


*** CODE SEGMENT '?PR?SkyOnOff?T?Fart':
 1167: void SkyOnOff(int spaak, int led, int level, int OnOff)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C1E      MOV         R6,R3 ; OnOff
 00000004  ---- Variable 'OnOff' assigned to Register 'R6' ----
 00000004  1C17      MOV         R7,R2 ; level
 00000006  ---- Variable 'level' assigned to Register 'R7' ----
 00000006  1C0D      MOV         R5,R1 ; led
 00000008  ---- Variable 'led' assigned to Register 'R5' ----
 00000008  1C04      MOV         R4,R0 ; spaak
 0000000A  ---- Variable 'spaak' assigned to Register 'R4' ----
 0000000A  B085      SUB         R13,#0x14
 1168: {
 0000000C            ; SCOPE-START
 1171:     int PWM1 = 0x14;    // (autoincrement (16) + register
 0000000C  2014      MOV         R0,#0x14
 0000000E  9002      STR         R0,[R13,#0x8] ; PWM1
 1172:     int LS0  = 0x06;    
 00000010  2006      MOV         R0,#0x6
 00000012  9003      STR         R0,[R13,#0xC] ; LS0
 1173:     int LS1  = 0x07;    
 00000014  2007      MOV         R0,#0x7
 00000016  9004      STR         R0,[R13,#0x10] ; LS1
 1175:     if (spaak == 0)
 00000018  2C00      CMP         R4,#0x0 ; spaak
 0000001A  D103      BNE         L_279  ; T=0x00000024
 1177:         buffer[0] = 0xEF;
 0000001C  21EF      MOV         R1,#0xEF
 0000001E  A801      ADD         R0,R13,#0x4
 00000020  7001      STRB        R1,[R0,#0x0] ; buffer
 1178:     }
 00000022  E010      B           L_280  ; T=0x00000046
 00000024          L_279:
 1181:         if (spaak < 9)
 00000024  2C09      CMP         R4,#0x9 ; spaak
 00000026  DA07      BGE         L_281  ; T=0x00000038
 1182:             buffer[0] = ~(1 << (spaak-1)); 
 00000028  1C20      MOV         R0,R4 ; spaak
 0000002A  3801      SUB         R0,#0x1
 0000002C  2101      MOV         R1,#0x1
 0000002E  4081      LSL         R1,R0
 00000030  43C9      MVN         R1,R1
 00000032  A801      ADD         R0,R13,#0x4
 00000034  7001      STRB        R1,[R0,#0x0] ; buffer
 00000036  E006      B           L_280  ; T=0x00000046
 00000038          L_281:
 1184:             buffer[0] = ~(1 << (spaak-9)); 
 00000038  1C20      MOV         R0,R4 ; spaak
 0000003A  3809      SUB         R0,#0x9
 0000003C  2101      MOV         R1,#0x1
 0000003E  4081      LSL         R1,R0
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 107 

 00000040  43C9      MVN         R1,R1
 00000042  A801      ADD         R0,R13,#0x4
 00000044  7001      STRB        R1,[R0,#0x0] ; buffer
 1185:     }
 00000046          L_280:
 1186:      I2C_SendByte(Sky[spaak].address, 1, buffer);  // laad pre-selectie met spaak-IC
 00000046  210C      MOV         R1,#0xC
 00000048  4361      MUL         R1,R4 ; spaak
 0000004A  4800      LDR         R0,=Sky ; Sky
 0000004C  5840      LDR         R0,[R0,R1]
 0000004E  AA01      ADD         R2,R13,#0x4
 00000050  2101      MOV         R1,#0x1
 00000052  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 00000054  FFD5      BL          I2C_SendByte?T  ; T=0x0001  (2)
 1188:     buffer[0] = PWM1;   // subaddress
 00000056  9902      LDR         R1,[R13,#0x8] ; PWM1
 00000058  A801      ADD         R0,R13,#0x4
 0000005A  7001      STRB        R1,[R0,#0x0] ; buffer
 1189:     buffer[1] = 0;      // PSC1
 0000005C  2100      MOV         R1,#0x0
 0000005E  2005      MOV         R0,#0x5
 00000060  4468      ADD         R0,R13
 00000062  7001      STRB        R1,[R0,#0x0] ; buffer+1
 1190:     buffer[2] = level & 0xFF;
 00000064  21FF      MOV         R1,#0xFF
 00000066  4039      AND         R1,R7 ; level
 00000068  2006      MOV         R0,#0x6
 0000006A  4468      ADD         R0,R13
 0000006C  7001      STRB        R1,[R0,#0x0] ; buffer+2
 1191:     I2C_SendByte(0xC0, 3, buffer);
 0000006E  AA01      ADD         R2,R13,#0x4
 00000070  20C0      MOV         R0,#0xC0
 00000072  2103      MOV         R1,#0x3
 00000074  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 00000076  FFC4      BL          I2C_SendByte?T  ; T=0x0001  (2)
 1193:     if (spaak == 0)
 00000078  2C00      CMP         R4,#0x0 ; spaak
 0000007A  D123      BNE         L_283  ; T=0x000000C4
 1195:         buffer[0] = LS0;
 0000007C  9903      LDR         R1,[R13,#0xC] ; LS0
 0000007E  A801      ADD         R0,R13,#0x4
 00000080  7001      STRB        R1,[R0,#0x0] ; buffer
 1196:         tmp = (0x03 << (2*(led-1)));
 00000082  1C29      MOV         R1,R5 ; led
 00000084  3901      SUB         R1,#0x1
 00000086  0049      LSL         R1,R1,#0x1 ; led
 00000088  2003      MOV         R0,#0x3
 0000008A  4088      LSL         R0,R1
 0000008C  9000      STR         R0,[R13,#0x0] ; tmp
 1197:         if (OnOff == ON)
 0000008E  2E01      CMP         R6,#0x1 ; OnOff
 00000090  D108      BNE         L_284  ; T=0x000000A4
 1198:             Sky[spaak].data |= tmp;
 00000092  9A00      LDR         R2,[R13,#0x0] ; tmp
 00000094  210C      MOV         R1,#0xC
 00000096  4361      MUL         R1,R4 ; spaak
 00000098  4800      LDR         R0,=Sky + 0x4 ; Sky+4
 0000009A  1840      ADD         R0,R1 ; Sky+4
 0000009C  6801      LDR         R1,[R0,#0x0]
 0000009E  4311      ORR         R1,R2
 000000A0  6001      STR         R1,[R0,#0x0]
 000000A2  E007      B           L_285  ; T=0x000000B4
 000000A4          L_284:
 1200:             Sky[spaak].data &= ~tmp;
 000000A4  9A00      LDR         R2,[R13,#0x0] ; tmp
 000000A6  210C      MOV         R1,#0xC
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 108 

 000000A8  4361      MUL         R1,R4 ; spaak
 000000AA  4800      LDR         R0,=Sky + 0x4 ; Sky+4
 000000AC  1840      ADD         R0,R1 ; Sky+4
 000000AE  6801      LDR         R1,[R0,#0x0]
 000000B0  4391      BIC         R1,R2
 000000B2  6001      STR         R1,[R0,#0x0]
 000000B4          L_285:
 1201:         buffer[1] = Sky[spaak].data;
 000000B4  210C      MOV         R1,#0xC
 000000B6  4361      MUL         R1,R4 ; spaak
 000000B8  4800      LDR         R0,=Sky + 0x4 ; Sky+4
 000000BA  5841      LDR         R1,[R0,R1]
 000000BC  2005      MOV         R0,#0x5
 000000BE  4468      ADD         R0,R13
 000000C0  7001      STRB        R1,[R0,#0x0] ; buffer+1
 1202:     }
 000000C2  E034      B           L_286  ; T=0x0000012E
 000000C4          L_283:
 1205:         tmp = (0x03 << (2*(led-1)));
 000000C4  1C29      MOV         R1,R5 ; led
 000000C6  3901      SUB         R1,#0x1
 000000C8  0049      LSL         R1,R1,#0x1 ; led
 000000CA  2003      MOV         R0,#0x3
 000000CC  4088      LSL         R0,R1
 000000CE  9000      STR         R0,[R13,#0x0] ; tmp
 1206:         if (OnOff == ON)
 000000D0  2E01      CMP         R6,#0x1 ; OnOff
 000000D2  D108      BNE         L_287  ; T=0x000000E6
 1207:             Sky[spaak].data |= tmp;
 000000D4  9A00      LDR         R2,[R13,#0x0] ; tmp
 000000D6  210C      MOV         R1,#0xC
 000000D8  4361      MUL         R1,R4 ; spaak
 000000DA  4800      LDR         R0,=Sky + 0x4 ; Sky+4
 000000DC  1840      ADD         R0,R1 ; Sky+4
 000000DE  6801      LDR         R1,[R0,#0x0]
 000000E0  4311      ORR         R1,R2
 000000E2  6001      STR         R1,[R0,#0x0]
 000000E4  E007      B           L_288  ; T=0x000000F6
 000000E6          L_287:
 1209:             Sky[spaak].data &= ~tmp;
 000000E6  9A00      LDR         R2,[R13,#0x0] ; tmp
 000000E8  210C      MOV         R1,#0xC
 000000EA  4361      MUL         R1,R4 ; spaak
 000000EC  4800      LDR         R0,=Sky + 0x4 ; Sky+4
 000000EE  1840      ADD         R0,R1 ; Sky+4
 000000F0  6801      LDR         R1,[R0,#0x0]
 000000F2  4391      BIC         R1,R2
 000000F4  6001      STR         R1,[R0,#0x0]
 000000F6          L_288:
 1210:         if (led < 5)
 000000F6  2D05      CMP         R5,#0x5 ; led
 000000F8  DA0C      BGE         L_289  ; T=0x00000114
 1212:             buffer[0] = LS0;
 000000FA  9903      LDR         R1,[R13,#0xC] ; LS0
 000000FC  A801      ADD         R0,R13,#0x4
 000000FE  7001      STRB        R1,[R0,#0x0] ; buffer
 1213:             buffer[1] = (Sky[spaak].data & 0xFF);
 00000100  210C      MOV         R1,#0xC
 00000102  4361      MUL         R1,R4 ; spaak
 00000104  4800      LDR         R0,=Sky + 0x4 ; Sky+4
 00000106  5841      LDR         R1,[R0,R1]
 00000108  20FF      MOV         R0,#0xFF
 0000010A  4001      AND         R1,R0
 0000010C  2005      MOV         R0,#0x5
 0000010E  4468      ADD         R0,R13
 00000110  7001      STRB        R1,[R0,#0x0] ; buffer+1
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 109 

 1214:         }
 00000112  E00C      B           L_286  ; T=0x0000012E
 00000114          L_289:
 1217:             buffer[0] = LS1;
 00000114  9904      LDR         R1,[R13,#0x10] ; LS1
 00000116  A801      ADD         R0,R13,#0x4
 00000118  7001      STRB        R1,[R0,#0x0] ; buffer
 1218:             buffer[1] = ((Sky[spaak].data >> 8) & 0xFF);
 0000011A  210C      MOV         R1,#0xC
 0000011C  4361      MUL         R1,R4 ; spaak
 0000011E  4800      LDR         R0,=Sky + 0x4 ; Sky+4
 00000120  5841      LDR         R1,[R0,R1]
 00000122  1209      ASR         R1,R1,#0x8
 00000124  20FF      MOV         R0,#0xFF
 00000126  4001      AND         R1,R0
 00000128  2005      MOV         R0,#0x5
 0000012A  4468      ADD         R0,R13
 0000012C  7001      STRB        R1,[R0,#0x0] ; buffer+1
 1220:     }
 0000012E          L_286:
 1221:     I2C_SendByte(0xC0, 2, buffer);
 0000012E  AA01      ADD         R2,R13,#0x4
 00000130  20C0      MOV         R0,#0xC0
 00000132  2102      MOV         R1,#0x2
 00000134  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 00000136  FF64      BL          I2C_SendByte?T  ; T=0x0001  (2)
 1222:     buffer[0] = 0xFF;
 00000138  21FF      MOV         R1,#0xFF
 0000013A  A801      ADD         R0,R13,#0x4
 0000013C  7001      STRB        R1,[R0,#0x0] ; buffer
 1223:     I2C_SendByte(Sky[spaak].address, 1, buffer);
 0000013E  210C      MOV         R1,#0xC
 00000140  4361      MUL         R1,R4 ; spaak
 00000142  4800      LDR         R0,=Sky ; Sky
 00000144  5840      LDR         R0,[R0,R1]
 00000146  AA01      ADD         R2,R13,#0x4
 00000148  2101      MOV         R1,#0x1
 0000014A  F7FF      BL          I2C_SendByte?T  ; T=0x0001  (1)
 0000014C  FF59      BL          I2C_SendByte?T  ; T=0x0001  (2)
 0000014E            ; SCOPE-END
 1224: }
 0000014E  B005      ADD         R13,#0x14
 00000150  BCF0      POP         {R4-R7}
 00000152  BC08      POP         {R3}
 00000154  4718      BX          R3
 00000156          ENDP ; 'SkyOnOff?T'


*** CODE SEGMENT '?PR?execStim?T?Fart':
 1237: void execStim()
 00000000  B570      PUSH        {R4-R6,LR}
 00000002  ---- Variable 'bit' assigned to Register 'R4' ----
 1238: {
 00000002            ; SCOPE-START
 1239:      int bit, level, n=0, i;
 00000002  2500      MOV         R5,#0x0
 00000004  ---- Variable 'n' assigned to Register 'R5' ----
 1241:     int outFlag = 0;
 00000004  2600      MOV         R6,#0x0
 00000006  ---- Variable 'outFlag' assigned to Register 'R6' ----
 1242:     switch (nBuffer[2])
 00000006  4800      LDR         R0,=nBuffer + 0x8 ; nBuffer+8
 00000008  6800      LDR         R0,[R0,#0x0] ; nBuffer+8
 0000000A  2802      CMP         R0,#0x2
 0000000C  D021      BEQ         L_294  ; T=0x00000052
 0000000E  2804      CMP         R0,#0x4
 00000010  D041      BEQ         L_295  ; T=0x00000096
 00000012  2805      CMP         R0,#0x5
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 110 

 00000014  D051      BEQ         L_296  ; T=0x000000BA
 00000016  280D      CMP         R0,#0xD
 00000018  D05F      BEQ         L_297  ; T=0x000000DA
 0000001A  280E      CMP         R0,#0xE
 0000001C  D065      BEQ         L_298  ; T=0x000000EA
 0000001E  2801      CMP         R0,#0x1
 00000020  D167      BNE         L_293  ; T=0x000000F2
 1244:     case stimDin:
 00000022          L_292:
 1245:         value = GetBitsPar();
 00000022  F7FF      BL          GetBitsPar?T  ; T=0x0001  (1)
 00000024  FFED      BL          GetBitsPar?T  ; T=0x0001  (2)
 00000026  ---- Variable 'value' assigned to Register 'R0' ----
 1246:         value = ((parOutp << 8) | value);
 00000026  4800      LDR         R1,=parOutp ; parOutp
 00000028  6809      LDR         R1,[R1,#0x0] ; parOutp
 0000002A  0209      LSL         R1,R1,#0x8
 0000002C  4308      ORR         R0,R1
 1248:         bit = (1 << nBuffer[3]-1);
 0000002E  4800      LDR         R1,=nBuffer + 0xC ; nBuffer+12
 00000030  6809      LDR         R1,[R1,#0x0] ; nBuffer+12
 00000032  3901      SUB         R1,#0x1
 00000034  2401      MOV         R4,#0x1
 00000036  408C      LSL         R4,R1
 1249:         if ((value & bit) == 0) bit = 0; else bit = 1;
 00000038  4020      AND         R0,R4 ; bit
 0000003A  2800      CMP         R0,#0x0 ; value
 0000003C  D101      BNE         L_299  ; T=0x00000042
 0000003E  2400      MOV         R4,#0x0
 00000040  E000      B           L_300  ; T=0x00000044
 00000042          L_299:
 00000042  2401      MOV         R4,#0x1
 00000044          L_300:
 1250:         n = sprintf(outBuf,"%d\n",bit);
 00000044  4800      LDR         R0,=outBuf ; outBuf
 00000046  4800      LDR         R1,=??S_5 ; ??S_5
 00000048  1C22      MOV         R2,R4
 0000004A  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 0000004C  FFD9      BL          sprintf?T  ; T=0x0001  (2)
 0000004E  1C05      MOV         R5,R0 ; n
 1251:         break;
 00000050  E056      B           L_291  ; T=0x00000100
 1252:     case stimDout:
 00000052          L_294:
 1254:         bit = (1 << nBuffer[3]-1);
 00000052  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 00000054  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 00000056  3801      SUB         R0,#0x1
 00000058  2401      MOV         R4,#0x1
 0000005A  4084      LSL         R4,R0
 1255:         level = nBuffer[4];
 0000005C  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 0000005E  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 00000060  ---- Variable 'level' assigned to Register 'R0' ----
 1256:         if (level > 0)
 00000060  2800      CMP         R0,#0x0 ; level
 00000062  DD08      BLE         L_301  ; T=0x00000076
 1258:             SetBitsPar(bit);
 00000064  1C20      MOV         R0,R4
 00000066  F7FF      BL          SetBitsPar?T  ; T=0x0001  (1)
 00000068  FFCB      BL          SetBitsPar?T  ; T=0x0001  (2)
 1259:             parOutp |= bit;
 0000006A  4800      LDR         R0,=parOutp ; parOutp
 0000006C  6801      LDR         R1,[R0,#0x0] ; parOutp
 0000006E  4321      ORR         R1,R4 ; bit
 00000070  4800      LDR         R0,=parOutp ; parOutp
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 111 

 00000072  6001      STR         R1,[R0,#0x0] ; parOutp
 1260:         }
 00000074  E007      B           L_302  ; T=0x00000086
 00000076          L_301:
 1263:             ClrBitsPar(bit);
 00000076  1C20      MOV         R0,R4
 00000078  F7FF      BL          ClrBitsPar?T  ; T=0x0001  (1)
 0000007A  FFC2      BL          ClrBitsPar?T  ; T=0x0001  (2)
 1264:             parOutp &= ~bit;
 0000007C  4800      LDR         R0,=parOutp ; parOutp
 0000007E  6801      LDR         R1,[R0,#0x0] ; parOutp
 00000080  43A1      BIC         R1,R4 ; bit
 00000082  4800      LDR         R0,=parOutp ; parOutp
 00000084  6001      STR         R1,[R0,#0x0] ; parOutp
 1265:         }
 00000086          L_302:
 1266:         n = sprintf(outBuf,"%d\n",curTime);
 00000086  4800      LDR         R0,=outBuf ; outBuf
 00000088  4800      LDR         R1,=??S_5 ; ??S_5
 0000008A  4800      LDR         R2,=curTime ; curTime
 0000008C  6812      LDR         R2,[R2,#0x0] ; curTime
 0000008E  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000090  FFB7      BL          sprintf?T  ; T=0x0001  (2)
 00000092  1C05      MOV         R5,R0 ; n
 1267:         break;
 00000094  E034      B           L_291  ; T=0x00000100
 1268:     case stimSky:
 00000096          L_295:
 1270:         SkyOnOff(nBuffer[3], nBuffer[4], nBuffer[5], nBuffer[6]);
 00000096  4800      LDR         R0,=nBuffer + 0xC ; nBuffer+12
 00000098  6800      LDR         R0,[R0,#0x0] ; nBuffer+12
 0000009A  4800      LDR         R1,=nBuffer + 0x10 ; nBuffer+16
 0000009C  6809      LDR         R1,[R1,#0x0] ; nBuffer+16
 0000009E  4800      LDR         R2,=nBuffer + 0x14 ; nBuffer+20
 000000A0  6812      LDR         R2,[R2,#0x0] ; nBuffer+20
 000000A2  4800      LDR         R3,=nBuffer + 0x18 ; nBuffer+24
 000000A4  681B      LDR         R3,[R3,#0x0] ; nBuffer+24
 000000A6  F7FF      BL          SkyOnOff?T  ; T=0x0001  (1)
 000000A8  FFAB      BL          SkyOnOff?T  ; T=0x0001  (2)
 1271:         n = sprintf(outBuf,"%d\n",curTime);
 000000AA  4800      LDR         R0,=outBuf ; outBuf
 000000AC  4800      LDR         R1,=??S_5 ; ??S_5
 000000AE  4800      LDR         R2,=curTime ; curTime
 000000B0  6812      LDR         R2,[R2,#0x0] ; curTime
 000000B2  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 000000B4  FFA5      BL          sprintf?T  ; T=0x0001  (2)
 000000B6  1C05      MOV         R5,R0 ; n
 1272:         break;
 000000B8  E022      B           L_291  ; T=0x00000100
 1273:     case stimLed:
 000000BA          L_296:
 1275:         LedOnOff(nBuffer[4], nBuffer[5], nBuffer[6]);
 000000BA  4800      LDR         R0,=nBuffer + 0x10 ; nBuffer+16
 000000BC  6800      LDR         R0,[R0,#0x0] ; nBuffer+16
 000000BE  4800      LDR         R1,=nBuffer + 0x14 ; nBuffer+20
 000000C0  6809      LDR         R1,[R1,#0x0] ; nBuffer+20
 000000C2  4800      LDR         R2,=nBuffer + 0x18 ; nBuffer+24
 000000C4  6812      LDR         R2,[R2,#0x0] ; nBuffer+24
 000000C6  F7FF      BL          LedOnOff?T  ; T=0x0001  (1)
 000000C8  FF9B      BL          LedOnOff?T  ; T=0x0001  (2)
 1276:         n = sprintf(outBuf,"%d\n",curTime);
 000000CA  4800      LDR         R0,=outBuf ; outBuf
 000000CC  4800      LDR         R1,=??S_5 ; ??S_5
 000000CE  4800      LDR         R2,=curTime ; curTime
 000000D0  6812      LDR         R2,[R2,#0x0] ; curTime
 000000D2  F7FF      BL          sprintf?T  ; T=0x0001  (1)
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 112 

 000000D4  FF95      BL          sprintf?T  ; T=0x0001  (2)
 000000D6  1C05      MOV         R5,R0 ; n
 1277:         break;
 000000D8  E012      B           L_291  ; T=0x00000100
 1278:     case stimSelADC:
 000000DA          L_297:
 1281:         n = sprintf(outBuf,"%d\n",curTime);
 000000DA  4800      LDR         R0,=outBuf ; outBuf
 000000DC  4800      LDR         R1,=??S_5 ; ??S_5
 000000DE  4800      LDR         R2,=curTime ; curTime
 000000E0  6812      LDR         R2,[R2,#0x0] ; curTime
 000000E2  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 000000E4  FF8D      BL          sprintf?T  ; T=0x0001  (2)
 000000E6  1C05      MOV         R5,R0 ; n
 1282:         break;
 000000E8  E00A      B           L_291  ; T=0x00000100
 1283:     case stimADC:
 000000EA          L_298:
 1285:         getADC();
 000000EA  F7FF      BL          getADC?T  ; T=0x0001  (1)
 000000EC  FF89      BL          getADC?T  ; T=0x0001  (2)
 1286:         outFlag = 1;
 000000EE  2601      MOV         R6,#0x1
 1287:         break;
 000000F0  E006      B           L_291  ; T=0x00000100
 1288:     default:
 000000F2          L_293:
 1289:         n = sprintf(outBuf,"%d\n",curTime);
 000000F2  4800      LDR         R0,=outBuf ; outBuf
 000000F4  4800      LDR         R1,=??S_5 ; ??S_5
 000000F6  4800      LDR         R2,=curTime ; curTime
 000000F8  6812      LDR         R2,[R2,#0x0] ; curTime
 000000FA  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 000000FC  FF81      BL          sprintf?T  ; T=0x0001  (2)
 000000FE  1C05      MOV         R5,R0 ; n
 1291:     }
 00000100          L_291:
 1293:     if (outFlag == 0)
 00000100  2E00      CMP         R6,#0x0 ; outFlag
 00000102  D106      BNE         L_303  ; T=0x00000112
 1295:         i = UART0_Str(outBuf, n);
 00000104  4800      LDR         R0,=outBuf ; outBuf
 00000106  1C29      MOV         R1,R5
 00000108  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 0000010A  FF7A      BL          UART0_Str?T  ; T=0x0001  (2)
 1296:         nBuffer[1] = 0;
 0000010C  2100      MOV         R1,#0x0
 0000010E  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 00000110  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 1297:     }
 00000112          L_303:
 00000112            ; SCOPE-END
 1298: }
 00000112  BC70      POP         {R4-R6}
 00000114  BC08      POP         {R3}
 00000116  4718      BX          R3
 00000118          ENDP ; 'execStim?T'


*** CODE SEGMENT '?PR?getInfo?T?Fart':
 1299: void getInfo()
 00000000  B500      PUSH        {LR}
 1300: {
 00000002            ; SCOPE-START
 1303:     n = 0;
 00000002  2100      MOV         R1,#0x0
 00000004  ---- Variable 'n' assigned to Register 'R1' ----
 1304:     while ((n < 80) && (version[n] > 0)) n++;
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 113 

 00000004  E000      B           L_304  ; T=0x00000008
 00000006          L_306:
 00000006  3101      ADD         R1,#0x1
 00000008          L_304:
 00000008  2950      CMP         R1,#0x50 ; n
 0000000A  DA03      BGE         L_305  ; T=0x00000014
 0000000C  4800      LDR         R0,=version ; version
 0000000E  5C40      LDRB        R0,[R0,R1]
 00000010  2800      CMP         R0,#0x0
 00000012  DCF8      BGT         L_306  ; T=0x00000006
 00000014          L_305:
 1305:     i = UART0_Str(version, n);
 00000014  4800      LDR         R0,=version ; version
 00000016  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000018  FFF3      BL          UART0_Str?T  ; T=0x0001  (2)
 1306:     nBuffer[1] = 0;
 0000001A  2100      MOV         R1,#0x0
 0000001C  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 0000001E  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 00000020            ; SCOPE-END
 1307: }
 00000020  BC08      POP         {R3}
 00000022  4718      BX          R3
 00000024          ENDP ; 'getInfo?T'


*** CODE SEGMENT '?PR?getClock?T?Fart':
 1309: void getClock()
 00000000  B500      PUSH        {LR}
 1310: {
 00000002            ; SCOPE-START
 1313:     val = Clock_GetSeconds();
 00000002  F7FF      BL          Clock_GetSeconds?T  ; T=0x0001  (1)
 00000004  FFFD      BL          Clock_GetSeconds?T  ; T=0x0001  (2)
 00000006  1C02      MOV         R2,R0 ; val
 00000008  ---- Variable 'val' assigned to Register 'R2' ----
 1314:     n = sprintf(outBuf,"%d\n",val);
 00000008  4800      LDR         R0,=outBuf ; outBuf
 0000000A  4800      LDR         R1,=??S_5 ; ??S_5
 0000000C  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 0000000E  FFF8      BL          sprintf?T  ; T=0x0001  (2)
 00000010  1C01      MOV         R1,R0 ; n
 00000012  ---- Variable 'n' assigned to Register 'R1' ----
 1315:     i = UART0_Str(outBuf, n);
 00000012  4800      LDR         R0,=outBuf ; outBuf
 00000014  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000016  FFF4      BL          UART0_Str?T  ; T=0x0001  (2)
 1316:     nBuffer[1] = 0;
 00000018  2100      MOV         R1,#0x0
 0000001A  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 0000001C  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 0000001E            ; SCOPE-END
 1317: }
 0000001E  BC08      POP         {R3}
 00000020  4718      BX          R3
 00000022          ENDP ; 'getClock?T'


*** CODE SEGMENT '?PR?getState?T?Fart':
 1319: void getState()
 00000000  B500      PUSH        {LR}
 1320: {
 00000002            ; SCOPE-START
 1323:     n = 0;
 00000002  2100      MOV         R1,#0x0
 00000004  ---- Variable 'n' assigned to Register 'R1' ----
 1324:     while ((n < 80) && (state[n] > 0)) n++;
 00000004  E000      B           L_309  ; T=0x00000008
 00000006          L_311:
 00000006  3101      ADD         R1,#0x1
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 114 

 00000008          L_309:
 00000008  2950      CMP         R1,#0x50 ; n
 0000000A  DA03      BGE         L_310  ; T=0x00000014
 0000000C  4800      LDR         R0,=state ; state
 0000000E  5C40      LDRB        R0,[R0,R1]
 00000010  2800      CMP         R0,#0x0
 00000012  DCF8      BGT         L_311  ; T=0x00000006
 00000014          L_310:
 1325:     i = UART0_Str(state, n);
 00000014  4800      LDR         R0,=state ; state
 00000016  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000018  FFF3      BL          UART0_Str?T  ; T=0x0001  (2)
 1326:     nBuffer[1] = 0;
 0000001A  2100      MOV         R1,#0x0
 0000001C  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 0000001E  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 00000020            ; SCOPE-END
 1327: }
 00000020  BC08      POP         {R3}
 00000022  4718      BX          R3
 00000024          ENDP ; 'getState?T'


*** CODE SEGMENT '?PR?getStateTrial?T?Fart':
 1329: void getStateTrial()
 00000000  B500      PUSH        {LR}
 1330: {
 00000002            ; SCOPE-START
 1333:     n = sprintf(outBuf,"%d\n",MCS);
 00000002  4800      LDR         R0,=outBuf ; outBuf
 00000004  4800      LDR         R1,=??S_5 ; ??S_5
 00000006  4800      LDR         R2,=MCS ; MCS
 00000008  6812      LDR         R2,[R2,#0x0] ; MCS
 0000000A  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          sprintf?T  ; T=0x0001  (2)
 0000000E  1C01      MOV         R1,R0 ; n
 00000010  ---- Variable 'n' assigned to Register 'R1' ----
 1334:     i = UART0_Str(outBuf, n);
 00000010  4800      LDR         R0,=outBuf ; outBuf
 00000012  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000014  FFF5      BL          UART0_Str?T  ; T=0x0001  (2)
 1335:     nBuffer[1] = 0;
 00000016  2100      MOV         R1,#0x0
 00000018  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 0000001A  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 0000001C            ; SCOPE-END
 1336: }
 0000001C  BC08      POP         {R3}
 0000001E  4718      BX          R3
 00000020          ENDP ; 'getStateTrial?T'


*** CODE SEGMENT '?PR?execNextTrial?T?Fart':
 1338: void execNextTrial()
 00000000  B500      PUSH        {LR}
 1339: {
 00000002            ; SCOPE-START
 1342:     nStim   = 0;
 00000002  2100      MOV         R1,#0x0
 00000004  4800      LDR         R0,=nStim ; nStim
 00000006  6001      STR         R1,[R0,#0x0] ; nStim
 1343:     MCS     = statNextTrial;        
 00000008  2102      MOV         R1,#0x2
 0000000A  4800      LDR         R0,=MCS ; MCS
 0000000C  6001      STR         R1,[R0,#0x0] ; MCS
 1345:     n = sprintf(outBuf,"%d\n",curTime);
 0000000E  4800      LDR         R0,=outBuf ; outBuf
 00000010  4800      LDR         R1,=??S_5 ; ??S_5
 00000012  4800      LDR         R2,=curTime ; curTime
 00000014  6812      LDR         R2,[R2,#0x0] ; curTime
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 115 

 00000016  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000018  FFF3      BL          sprintf?T  ; T=0x0001  (2)
 0000001A  1C01      MOV         R1,R0 ; n
 0000001C  ---- Variable 'n' assigned to Register 'R1' ----
 1346:     i = UART0_Str(outBuf, n);
 0000001C  4800      LDR         R0,=outBuf ; outBuf
 0000001E  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000020  FFEF      BL          UART0_Str?T  ; T=0x0001  (2)
 1347:     nBuffer[1] = 0;
 00000022  2100      MOV         R1,#0x0
 00000024  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 00000026  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 00000028            ; SCOPE-END
 1348: }
 00000028  BC08      POP         {R3}
 0000002A  4718      BX          R3
 0000002C          ENDP ; 'execNextTrial?T'


*** CODE SEGMENT '?PR?execStartTrial?T?Fart':
 1350: void execStartTrial()
 00000000  B500      PUSH        {LR}
 1351: {
 00000002            ; SCOPE-START
 1354:     T_start = Clock_GetTicks();
 00000002  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000004  FFFD      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000006  4800      LDR         R1,=T_start ; T_start
 00000008  6008      STR         R0,[R1,#0x0] ; T_start
 1355:     T_ITI   = T_start - T_done;
 0000000A  4800      LDR         R0,=T_done ; T_done
 0000000C  6800      LDR         R0,[R0,#0x0] ; T_done
 0000000E  4800      LDR         R1,=T_start ; T_start
 00000010  6809      LDR         R1,[R1,#0x0] ; T_start
 00000012  1A09      SUB         R1,R0
 00000014  4800      LDR         R0,=T_ITI ; T_ITI
 00000016  6001      STR         R1,[R0,#0x0] ; T_ITI
 1356:     MCS = statRunTrial;
 00000018  2103      MOV         R1,#0x3
 0000001A  4800      LDR         R0,=MCS ; MCS
 0000001C  6001      STR         R1,[R0,#0x0] ; MCS
 1357:     errFlag = false;
 0000001E  2100      MOV         R1,#0x0
 00000020  4800      LDR         R0,=errFlag ; errFlag
 00000022  6001      STR         R1,[R0,#0x0] ; errFlag
 1358:     n = sprintf(outBuf,"%d\n",curTime);
 00000024  4800      LDR         R0,=outBuf ; outBuf
 00000026  4800      LDR         R1,=??S_5 ; ??S_5
 00000028  4800      LDR         R2,=curTime ; curTime
 0000002A  6812      LDR         R2,[R2,#0x0] ; curTime
 0000002C  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 0000002E  FFE8      BL          sprintf?T  ; T=0x0001  (2)
 00000030  1C01      MOV         R1,R0 ; n
 00000032  ---- Variable 'n' assigned to Register 'R1' ----
 1359:     i = UART0_Str(outBuf, n);
 00000032  4800      LDR         R0,=outBuf ; outBuf
 00000034  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000036  FFE4      BL          UART0_Str?T  ; T=0x0001  (2)
 1360:     nBuffer[1] = 0;
 00000038  2100      MOV         R1,#0x0
 0000003A  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 0000003C  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 0000003E            ; SCOPE-END
 1361: }
 0000003E  BC08      POP         {R3}
 00000040  4718      BX          R3
 00000042          ENDP ; 'execStartTrial?T'


*** CODE SEGMENT '?PR?execEvent?T?Fart':
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 116 

 1371: void execEvent(int event)
 00000000  B530      PUSH        {R4-R5,LR}
 00000002  1C05      MOV         R5,R0 ; event
 00000004  ---- Variable 'event' assigned to Register 'R5' ----
 1372: {
 00000004            ; SCOPE-START
 1374:     int newTime = Clock_GetTicks() - T_start;
 00000004  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000006  FFFC      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000008  4800      LDR         R1,=T_start ; T_start
 0000000A  6809      LDR         R1,[R1,#0x0] ; T_start
 0000000C  1A44      SUB         R4,R0,R1 ; Clock_GetTicks?T
 0000000E  ---- Variable 'newTime' assigned to Register 'R4' ----
 1375:     if (event == 99)
 0000000E  2D63      CMP         R5,#0x63 ; event
 00000010  D102      BNE         L_314  ; T=0x00000018
 1377:         execError();
 00000012  F7FF      BL          execError?T  ; T=0x0001  (1)
 00000014  FFF5      BL          execError?T  ; T=0x0001  (2)
 1378:     }
 00000016  E022      B           L_315  ; T=0x0000005E
 00000018          L_314:
 1381:         if (event != 0)
 00000018  2D00      CMP         R5,#0x0 ; event
 0000001A  D020      BEQ         L_315  ; T=0x0000005E
 1383:         for (i = 0; i < nStim; i++) 
 0000001C  2100      MOV         R1,#0x0
 0000001E  ---- Variable 'i' assigned to Register 'R1' ----
 0000001E  E01A      B           L_319  ; T=0x00000056
 00000020          L_320:
 1385:                 if (stim[i].startRef == event)
 00000020  224C      MOV         R2,#0x4C
 00000022  434A      MUL         R2,R1 ; i
 00000024  4800      LDR         R0,=stim + 0x24 ; stim+36
 00000026  5883      LDR         R3,[R0,R2]
 00000028  42AB      CMP         R3,R5 ; event
 0000002A  D107      BNE         L_322  ; T=0x0000003C
 1387:                     stim[i].startRef = 0;
 0000002C  2000      MOV         R0,#0x0
 0000002E  4800      LDR         R3,=stim + 0x24 ; stim+36
 00000030  5098      STR         R0,[R3,R2]
 1388:                     stim[i].startTime += newTime;
 00000032  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000034  1880      ADD         R0,R2 ; stim+40
 00000036  6803      LDR         R3,[R0,#0x0]
 00000038  191B      ADD         R3,R4 ; newTime
 0000003A  6003      STR         R3,[R0,#0x0]
 1389:                 }
 0000003C          L_322:
 1390:                 if (stim[i].stopRef == event)
 0000003C  4800      LDR         R0,=stim + 0x2C ; stim+44
 0000003E  5883      LDR         R3,[R0,R2]
 00000040  42AB      CMP         R3,R5 ; event
 00000042  D107      BNE         L_317  ; T=0x00000054
 1392:                     stim[i].stopRef = 0;
 00000044  2000      MOV         R0,#0x0
 00000046  4800      LDR         R3,=stim + 0x2C ; stim+44
 00000048  5098      STR         R0,[R3,R2]
 1393:                     stim[i].stopTime += newTime;
 0000004A  4800      LDR         R0,=stim + 0x30 ; stim+48
 0000004C  1880      ADD         R0,R2 ; stim+48
 0000004E  6802      LDR         R2,[R0,#0x0]
 00000050  1912      ADD         R2,R4 ; newTime
 00000052  6002      STR         R2,[R0,#0x0]
 1395:             }
 00000054          L_317:
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 117 

 00000054  3101      ADD         R1,#0x1
 00000056          L_319:
 00000056  4800      LDR         R0,=nStim ; nStim
 00000058  6800      LDR         R0,[R0,#0x0] ; nStim
 0000005A  4281      CMP         R1,R0 ; i
 0000005C  DBE0      BLT         L_320  ; T=0x00000020
 1397:     }
 0000005E          L_315:
 0000005E            ; SCOPE-END
 1398: }
 0000005E  BC30      POP         {R4-R5}
 00000060  BC08      POP         {R3}
 00000062  4718      BX          R3
 00000064          ENDP ; 'execEvent?T'


*** CODE SEGMENT '?PR?execBar?T?Fart':
 1400: int execBar(int index)
 00000000  B530      PUSH        {R4-R5,LR}
 00000002  1C05      MOV         R5,R0 ; index
 00000004  ---- Variable 'index' assigned to Register 'R5' ----
 1401: {
 00000004            ; SCOPE-START
 1402:     int ans = 0;
 00000004  2400      MOV         R4,#0x0
 00000006  ---- Variable 'ans' assigned to Register 'R4' ----
 1403:     switch(stim[index].mode)
 00000006  214C      MOV         R1,#0x4C
 00000008  4369      MUL         R1,R5 ; index
 0000000A  4800      LDR         R0,=stim + 0x40 ; stim+64
 0000000C  5840      LDR         R0,[R0,R1]
 0000000E  2801      CMP         R0,#0x1
 00000010  D008      BEQ         L_326  ; T=0x00000024
 00000012  2802      CMP         R0,#0x2
 00000014  D00B      BEQ         L_327  ; T=0x0000002E
 00000016  2800      CMP         R0,#0x0
 00000018  D10D      BNE         L_324  ; T=0x00000036
 1405:     case 0: ans = execBarFlank(index);  break;
 0000001A          L_325:
 0000001A  1C28      MOV         R0,R5
 0000001C  F7FF      BL          execBarFlank?T  ; T=0x0001  (1)
 0000001E  FFF0      BL          execBarFlank?T  ; T=0x0001  (2)
 00000020  1C04      MOV         R4,R0 ; ans
 00000022  E008      B           L_324  ; T=0x00000036
 1406:     case 1: ans = execBarLevel(index);  break;
 00000024          L_326:
 00000024  1C28      MOV         R0,R5
 00000026  F7FF      BL          execBarLevel?T  ; T=0x0001  (1)
 00000028  FFEB      BL          execBarLevel?T  ; T=0x0001  (2)
 0000002A  1C04      MOV         R4,R0 ; ans
 0000002C  E003      B           L_324  ; T=0x00000036
 1407:     case 2: ans = execBarCheck(index);  break;
 0000002E          L_327:
 0000002E  1C28      MOV         R0,R5
 00000030  F7FF      BL          execBarCheck?T  ; T=0x0001  (1)
 00000032  FFE6      BL          execBarCheck?T  ; T=0x0001  (2)
 00000034  1C04      MOV         R4,R0 ; ans
 1408:     }
 00000036          L_324:
 1409:     return ans;
 00000036  1C20      MOV         R0,R4 ; ans
 00000038            ; SCOPE-END
 1410: }
 00000038  BC30      POP         {R4-R5}
 0000003A  BC08      POP         {R3}
 0000003C  4718      BX          R3
 0000003E          ENDP ; 'execBar?T'


*** CODE SEGMENT '?PR?execBarLevel?T?Fart':
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 118 

 1412: int execBarLevel(int index)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C05      MOV         R5,R0 ; index
 00000004  ---- Variable 'index' assigned to Register 'R5' ----
 1413: {
 00000004            ; SCOPE-START
 1414:     int newTime = Clock_GetTicks() - T_start;
 00000004  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000006  FFFC      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000008  4800      LDR         R1,=T_start ; T_start
 0000000A  6809      LDR         R1,[R1,#0x0] ; T_start
 0000000C  1A44      SUB         R4,R0,R1 ; Clock_GetTicks?T
 0000000E  ---- Variable 'newTime' assigned to Register 'R4' ----
 1415:     int    barBit  = (1 << (stim[index].bitNo-1));
 0000000E  234C      MOV         R3,#0x4C
 00000010  436B      MUL         R3,R5 ; index
 00000012  4800      LDR         R0,=stim + 0x14 ; stim+20
 00000014  58C0      LDR         R0,[R0,R3]
 00000016  3801      SUB         R0,#0x1
 00000018  2601      MOV         R6,#0x1
 0000001A  4086      LSL         R6,R0
 0000001C  ---- Variable 'barBit' assigned to Register 'R6' ----
 1416:     int    barEdge = stim[index].edge;
 0000001C  4800      LDR         R0,=stim + 0x10 ; stim+16
 0000001E  58C7      LDR         R7,[R0,R3]
 00000020  ---- Variable 'barEdge' assigned to Register 'R7' ----
 1419:     if (stim[index].status == statInit)
 00000020  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000022  58C1      LDR         R1,[R0,R3]
 00000024  2901      CMP         R1,#0x1
 00000026  D114      BNE         L_329  ; T=0x00000052
 1421:         if (stim[index].startRef == 0)
 00000028  4800      LDR         R0,=stim + 0x24 ; stim+36
 0000002A  58C0      LDR         R0,[R0,R3]
 0000002C  2800      CMP         R0,#0x0
 0000002E  D10E      BNE         L_330  ; T=0x0000004E
 1423:             if(curTime < stim[index].startTime)  // end off start delay ?
 00000030  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000032  58C2      LDR         R2,[R0,R3]
 00000034  4800      LDR         R0,=curTime ; curTime
 00000036  6800      LDR         R0,[R0,#0x0] ; curTime
 00000038  4290      CMP         R0,R2
 0000003A  D201      BCS         L_331  ; T=0x00000040
 1424:                 return 2;
 0000003C  2002      MOV         R0,#0x2
 0000003E  E05A      B           L_332  ; T=0x000000F6
 00000040          L_331:
 1427:                 stim[index].startTime = newTime;
 00000040  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000042  50C4      STR         R4,[R0,R3] ; newTime
 1428:                 stim[index].status    = statRun;
 00000044  200A      MOV         R0,#0xA
 00000046  4800      LDR         R2,=stim + 0x4 ; stim+4
 00000048  50D0      STR         R0,[R2,R3]
 1429:                 return 1;
 0000004A  2001      MOV         R0,#0x1
 0000004C  E053      B           L_332  ; T=0x000000F6
 1431:         }
 0000004E          L_330:
 1433:             return 2;
 0000004E  2002      MOV         R0,#0x2
 00000050  E051      B           L_332  ; T=0x000000F6
 1434:     }
 00000052          L_329:
 1437:     if (stim[index].status == statRun)
 00000052  290A      CMP         R1,#0xA
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 119 

 00000054  D14E      BNE         L_335  ; T=0x000000F4
 1439:         if (stim[index].stopRef == 0)           // endtime set ?
 00000056  214C      MOV         R1,#0x4C
 00000058  4369      MUL         R1,R5 ; index
 0000005A  4800      LDR         R0,=stim + 0x2C ; stim+44
 0000005C  5840      LDR         R0,[R0,R1]
 0000005E  2800      CMP         R0,#0x0
 00000060  D130      BNE         L_336  ; T=0x000000C4
 1441:             if (curTime < stim[index].stopTime) // and reached
 00000062  214C      MOV         R1,#0x4C
 00000064  4369      MUL         R1,R5 ; index
 00000066  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000068  5841      LDR         R1,[R0,R1]
 0000006A  4800      LDR         R0,=curTime ; curTime
 0000006C  6800      LDR         R0,[R0,#0x0] ; curTime
 0000006E  4288      CMP         R0,R1
 00000070  D217      BCS         L_337  ; T=0x000000A2
 1445:                 if (((barEdge == 1) && ((parInp & barBit) == 0)) ||
 00000072  2F01      CMP         R7,#0x1 ; barEdge
 00000074  D104      BNE         L_340  ; T=0x00000080
 00000076  4800      LDR         R0,=parInp ; parInp
 00000078  6800      LDR         R0,[R0,#0x0] ; parInp
 0000007A  4030      AND         R0,R6 ; barBit
 0000007C  2800      CMP         R0,#0x0
 0000007E  D006      BEQ         L_339  ; T=0x0000008E
 00000080          L_340:
 00000080  2F00      CMP         R7,#0x0 ; barEdge
 00000082  D10C      BNE         L_338  ; T=0x0000009E
 00000084  4800      LDR         R0,=parInp ; parInp
 00000086  6800      LDR         R0,[R0,#0x0] ; parInp
 00000088  4030      AND         R0,R6 ; barBit
 0000008A  2800      CMP         R0,#0x0
 0000008C  DD07      BLE         L_338  ; T=0x0000009E
 0000008E          L_339:
 1448:                     stim[index].stopTime = newTime;
 0000008E  214C      MOV         R1,#0x4C
 00000090  4369      MUL         R1,R5 ; index
 00000092  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000094  5044      STR         R4,[R0,R1] ; newTime
 1449:                     execError();
 00000096  F7FF      BL          execError?T  ; T=0x0001  (1)
 00000098  FFB3      BL          execError?T  ; T=0x0001  (2)
 1450:                     return 0;
 0000009A  2000      MOV         R0,#0x0
 0000009C  E02B      B           L_332  ; T=0x000000F6
 1451:                 }
 0000009E          L_338:
 1452:                 return 1;
 0000009E  2001      MOV         R0,#0x1
 000000A0  E029      B           L_332  ; T=0x000000F6
 1453:             }
 000000A2          L_337:
 1456:                 stim[index].stopTime = newTime;
 000000A2  214C      MOV         R1,#0x4C
 000000A4  4369      MUL         R1,R5 ; index
 000000A6  4800      LDR         R0,=stim + 0x30 ; stim+48
 000000A8  5044      STR         R4,[R0,R1] ; newTime
 1457:                 stim[index].status   = statDone;
 000000AA  2105      MOV         R1,#0x5
 000000AC  224C      MOV         R2,#0x4C
 000000AE  436A      MUL         R2,R5 ; index
 000000B0  4800      LDR         R0,=stim + 0x4 ; stim+4
 000000B2  5081      STR         R1,[R0,R2]
 1458:                 execEvent(stim[index].event);
 000000B4  214C      MOV         R1,#0x4C
 000000B6  4369      MUL         R1,R5 ; index
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 120 

 000000B8  4800      LDR         R0,=stim + 0x3C ; stim+60
 000000BA  5840      LDR         R0,[R0,R1]
 000000BC  F7FF      BL          execEvent?T  ; T=0x0001  (1)
 000000BE  FFA0      BL          execEvent?T  ; T=0x0001  (2)
 1459:                 return 0;                   // exit after executing event
 000000C0  2000      MOV         R0,#0x0
 000000C2  E018      B           L_332  ; T=0x000000F6
 1461:         }
 000000C4          L_336:
 1466:             if (((barEdge == 1) && ((parInp & barBit) ==  0)) ||
 000000C4  2F01      CMP         R7,#0x1 ; barEdge
 000000C6  D104      BNE         L_345  ; T=0x000000D2
 000000C8  4800      LDR         R0,=parInp ; parInp
 000000CA  6800      LDR         R0,[R0,#0x0] ; parInp
 000000CC  4030      AND         R0,R6 ; barBit
 000000CE  2800      CMP         R0,#0x0
 000000D0  D006      BEQ         L_344  ; T=0x000000E0
 000000D2          L_345:
 000000D2  2F00      CMP         R7,#0x0 ; barEdge
 000000D4  D10C      BNE         L_343  ; T=0x000000F0
 000000D6  4800      LDR         R0,=parInp ; parInp
 000000D8  6800      LDR         R0,[R0,#0x0] ; parInp
 000000DA  4030      AND         R0,R6 ; barBit
 000000DC  2800      CMP         R0,#0x0
 000000DE  DD07      BLE         L_343  ; T=0x000000F0
 000000E0          L_344:
 1469:                 stim[index].stopTime = newTime;
 000000E0  214C      MOV         R1,#0x4C
 000000E2  4369      MUL         R1,R5 ; index
 000000E4  4800      LDR         R0,=stim + 0x30 ; stim+48
 000000E6  5044      STR         R4,[R0,R1] ; newTime
 1470:                 execError();
 000000E8  F7FF      BL          execError?T  ; T=0x0001  (1)
 000000EA  FF8A      BL          execError?T  ; T=0x0001  (2)
 1471:                 return 0;
 000000EC  2000      MOV         R0,#0x0
 000000EE  E002      B           L_332  ; T=0x000000F6
 1472:             }
 000000F0          L_343:
 1473:             return 1;
 000000F0  2001      MOV         R0,#0x1
 000000F2  E000      B           L_332  ; T=0x000000F6
 1475:     }
 000000F4          L_335:
 1477:     return 0;
 000000F4  2000      MOV         R0,#0x0
 000000F6            ; SCOPE-END
 1478: }
 000000F6          L_332:
 000000F6  BCF0      POP         {R4-R7}
 000000F8  BC08      POP         {R3}
 000000FA  4718      BX          R3
 000000FC          ENDP ; 'execBarLevel?T'


*** CODE SEGMENT '?PR?execBarCheck?T?Fart':
 1480: int execBarCheck(int index)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C04      MOV         R4,R0 ; index
 00000004  ---- Variable 'index' assigned to Register 'R4' ----
 1481: {
 00000004            ; SCOPE-START
 1482:     int newTime = Clock_GetTicks() - T_start;
 00000004  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000006  FFFC      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000008  4800      LDR         R1,=T_start ; T_start
 0000000A  6809      LDR         R1,[R1,#0x0] ; T_start
 0000000C  1A45      SUB         R5,R0,R1 ; Clock_GetTicks?T
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 121 

 0000000E  ---- Variable 'newTime' assigned to Register 'R5' ----
 1483:     int    barBit  = (1 << (stim[index].bitNo-1));
 0000000E  234C      MOV         R3,#0x4C
 00000010  4363      MUL         R3,R4 ; index
 00000012  4800      LDR         R0,=stim + 0x14 ; stim+20
 00000014  58C0      LDR         R0,[R0,R3]
 00000016  3801      SUB         R0,#0x1
 00000018  2601      MOV         R6,#0x1
 0000001A  4086      LSL         R6,R0
 0000001C  ---- Variable 'barBit' assigned to Register 'R6' ----
 1484:     int    barEdge = stim[index].edge;
 0000001C  4800      LDR         R0,=stim + 0x10 ; stim+16
 0000001E  58C7      LDR         R7,[R0,R3]
 00000020  ---- Variable 'barEdge' assigned to Register 'R7' ----
 1487:     if (stim[index].status == statInit)
 00000020  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000022  58C1      LDR         R1,[R0,R3]
 00000024  2901      CMP         R1,#0x1
 00000026  D114      BNE         L_346  ; T=0x00000052
 1489:         if (stim[index].startRef == 0)
 00000028  4800      LDR         R0,=stim + 0x24 ; stim+36
 0000002A  58C0      LDR         R0,[R0,R3]
 0000002C  2800      CMP         R0,#0x0
 0000002E  D10E      BNE         L_347  ; T=0x0000004E
 1491:             if(curTime < stim[index].startTime)  // end off start delay ?
 00000030  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000032  58C2      LDR         R2,[R0,R3]
 00000034  4800      LDR         R0,=curTime ; curTime
 00000036  6800      LDR         R0,[R0,#0x0] ; curTime
 00000038  4290      CMP         R0,R2
 0000003A  D201      BCS         L_348  ; T=0x00000040
 1492:                 return 2;
 0000003C  2002      MOV         R0,#0x2
 0000003E  E063      B           L_349  ; T=0x00000108
 00000040          L_348:
 1495:                 stim[index].startTime = newTime;
 00000040  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000042  50C5      STR         R5,[R0,R3] ; newTime
 1496:                 stim[index].status    = statRun;
 00000044  200A      MOV         R0,#0xA
 00000046  4800      LDR         R2,=stim + 0x4 ; stim+4
 00000048  50D0      STR         R0,[R2,R3]
 1497:                 return 1;
 0000004A  2001      MOV         R0,#0x1
 0000004C  E05C      B           L_349  ; T=0x00000108
 1499:         }
 0000004E          L_347:
 1501:             return 2;
 0000004E  2002      MOV         R0,#0x2
 00000050  E05A      B           L_349  ; T=0x00000108
 1502:     }
 00000052          L_346:
 1505:     if (stim[index].status == statRun)
 00000052  290A      CMP         R1,#0xA
 00000054  D157      BNE         L_352  ; T=0x00000106
 1507:         if (stim[index].stopRef == 0)           // endtime set ?
 00000056  214C      MOV         R1,#0x4C
 00000058  4361      MUL         R1,R4 ; index
 0000005A  4800      LDR         R0,=stim + 0x2C ; stim+44
 0000005C  5840      LDR         R0,[R0,R1]
 0000005E  2800      CMP         R0,#0x0
 00000060  D130      BNE         L_353  ; T=0x000000C4
 1509:             if (curTime < stim[index].stopTime) // and reached
 00000062  214C      MOV         R1,#0x4C
 00000064  4361      MUL         R1,R4 ; index
 00000066  4800      LDR         R0,=stim + 0x30 ; stim+48
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 122 

 00000068  5841      LDR         R1,[R0,R1]
 0000006A  4800      LDR         R0,=curTime ; curTime
 0000006C  6800      LDR         R0,[R0,#0x0] ; curTime
 0000006E  4288      CMP         R0,R1
 00000070  D220      BCS         L_354  ; T=0x000000B4
 1513:                 if (((barEdge == 1) && ((parInp & barBit) >  0)) ||
 00000072  2F01      CMP         R7,#0x1 ; barEdge
 00000074  D104      BNE         L_357  ; T=0x00000080
 00000076  4800      LDR         R0,=parInp ; parInp
 00000078  6800      LDR         R0,[R0,#0x0] ; parInp
 0000007A  4030      AND         R0,R6 ; barBit
 0000007C  2800      CMP         R0,#0x0
 0000007E  DC06      BGT         L_356  ; T=0x0000008E
 00000080          L_357:
 00000080  2F00      CMP         R7,#0x0 ; barEdge
 00000082  D115      BNE         L_355  ; T=0x000000B0
 00000084  4800      LDR         R0,=parInp ; parInp
 00000086  6800      LDR         R0,[R0,#0x0] ; parInp
 00000088  4030      AND         R0,R6 ; barBit
 0000008A  2800      CMP         R0,#0x0
 0000008C  D110      BNE         L_355  ; T=0x000000B0
 0000008E          L_356:
 1516:                     stim[index].stopTime = newTime;
 0000008E  214C      MOV         R1,#0x4C
 00000090  4361      MUL         R1,R4 ; index
 00000092  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000094  5045      STR         R5,[R0,R1] ; newTime
 1517:                     stim[index].status   = statDone;
 00000096  2105      MOV         R1,#0x5
 00000098  224C      MOV         R2,#0x4C
 0000009A  4362      MUL         R2,R4 ; index
 0000009C  4800      LDR         R0,=stim + 0x4 ; stim+4
 0000009E  5081      STR         R1,[R0,R2]
 1518:                     execEvent(stim[index].event);
 000000A0  214C      MOV         R1,#0x4C
 000000A2  4361      MUL         R1,R4 ; index
 000000A4  4800      LDR         R0,=stim + 0x3C ; stim+60
 000000A6  5840      LDR         R0,[R0,R1]
 000000A8  F7FF      BL          execEvent?T  ; T=0x0001  (1)
 000000AA  FFAA      BL          execEvent?T  ; T=0x0001  (2)
 1519:                     return 0;                   // exit after executing event
 000000AC  2000      MOV         R0,#0x0
 000000AE  E02B      B           L_349  ; T=0x00000108
 1520:                 }
 000000B0          L_355:
 1521:                 return 1;
 000000B0  2001      MOV         R0,#0x1
 000000B2  E029      B           L_349  ; T=0x00000108
 1522:             }
 000000B4          L_354:
 1525:                 stim[index].stopTime = newTime;
 000000B4  214C      MOV         R1,#0x4C
 000000B6  4361      MUL         R1,R4 ; index
 000000B8  4800      LDR         R0,=stim + 0x30 ; stim+48
 000000BA  5045      STR         R5,[R0,R1] ; newTime
 1526:                 execError();
 000000BC  F7FF      BL          execError?T  ; T=0x0001  (1)
 000000BE  FFA0      BL          execError?T  ; T=0x0001  (2)
 1527:                 return 0;
 000000C0  2000      MOV         R0,#0x0
 000000C2  E021      B           L_349  ; T=0x00000108
 1529:         }
 000000C4          L_353:
 1534:             if (((barEdge == 1) && ((parInp & barBit) >  0)) ||
 000000C4  2F01      CMP         R7,#0x1 ; barEdge
 000000C6  D104      BNE         L_362  ; T=0x000000D2
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 123 

 000000C8  4800      LDR         R0,=parInp ; parInp
 000000CA  6800      LDR         R0,[R0,#0x0] ; parInp
 000000CC  4030      AND         R0,R6 ; barBit
 000000CE  2800      CMP         R0,#0x0
 000000D0  DC06      BGT         L_361  ; T=0x000000E0
 000000D2          L_362:
 000000D2  2F00      CMP         R7,#0x0 ; barEdge
 000000D4  D115      BNE         L_360  ; T=0x00000102
 000000D6  4800      LDR         R0,=parInp ; parInp
 000000D8  6800      LDR         R0,[R0,#0x0] ; parInp
 000000DA  4030      AND         R0,R6 ; barBit
 000000DC  2800      CMP         R0,#0x0
 000000DE  D110      BNE         L_360  ; T=0x00000102
 000000E0          L_361:
 1537:                 stim[index].stopTime = newTime;
 000000E0  214C      MOV         R1,#0x4C
 000000E2  4361      MUL         R1,R4 ; index
 000000E4  4800      LDR         R0,=stim + 0x30 ; stim+48
 000000E6  5045      STR         R5,[R0,R1] ; newTime
 1538:                 stim[index].status   = statDone;
 000000E8  2105      MOV         R1,#0x5
 000000EA  224C      MOV         R2,#0x4C
 000000EC  4362      MUL         R2,R4 ; index
 000000EE  4800      LDR         R0,=stim + 0x4 ; stim+4
 000000F0  5081      STR         R1,[R0,R2]
 1539:                 execEvent(stim[index].event);
 000000F2  214C      MOV         R1,#0x4C
 000000F4  4361      MUL         R1,R4 ; index
 000000F6  4800      LDR         R0,=stim + 0x3C ; stim+60
 000000F8  5840      LDR         R0,[R0,R1]
 000000FA  F7FF      BL          execEvent?T  ; T=0x0001  (1)
 000000FC  FF81      BL          execEvent?T  ; T=0x0001  (2)
 1540:                 return 0;   // exit after executing event
 000000FE  2000      MOV         R0,#0x0
 00000100  E002      B           L_349  ; T=0x00000108
 1541:             }
 00000102          L_360:
 1542:             return 1;
 00000102  2001      MOV         R0,#0x1
 00000104  E000      B           L_349  ; T=0x00000108
 1544:     }
 00000106          L_352:
 1546:     return 0;
 00000106  2000      MOV         R0,#0x0
 00000108            ; SCOPE-END
 1547: }
 00000108          L_349:
 00000108  BCF0      POP         {R4-R7}
 0000010A  BC08      POP         {R3}
 0000010C  4718      BX          R3
 0000010E          ENDP ; 'execBarCheck?T'


*** CODE SEGMENT '?PR?execBarFlank?T?Fart':
 1549: int execBarFlank(int index)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C04      MOV         R4,R0 ; index
 00000004  ---- Variable 'index' assigned to Register 'R4' ----
 1550: {
 00000004            ; SCOPE-START
 1551:     int newTime = Clock_GetTicks() - T_start;
 00000004  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000006  FFFC      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000008  4800      LDR         R1,=T_start ; T_start
 0000000A  6809      LDR         R1,[R1,#0x0] ; T_start
 0000000C  1A45      SUB         R5,R0,R1 ; Clock_GetTicks?T
 0000000E  ---- Variable 'newTime' assigned to Register 'R5' ----
 1552:     int    barBit  = (1 << (stim[index].bitNo-1));
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 124 

 0000000E  214C      MOV         R1,#0x4C
 00000010  4361      MUL         R1,R4 ; index
 00000012  4800      LDR         R0,=stim + 0x14 ; stim+20
 00000014  5840      LDR         R0,[R0,R1]
 00000016  3801      SUB         R0,#0x1
 00000018  2601      MOV         R6,#0x1
 0000001A  4086      LSL         R6,R0
 0000001C  ---- Variable 'barBit' assigned to Register 'R6' ----
 1553:     int    barEdge = stim[index].edge;
 0000001C  4800      LDR         R0,=stim + 0x10 ; stim+16
 0000001E  5847      LDR         R7,[R0,R1]
 00000020  ---- Variable 'barEdge' assigned to Register 'R7' ----
 1556:     if (stim[index].status == statInit)
 00000020  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000022  5840      LDR         R0,[R0,R1]
 00000024  2801      CMP         R0,#0x1
 00000026  D12C      BNE         L_363  ; T=0x00000082
 1558:         if (stim[index].startRef == 0)
 00000028  4800      LDR         R0,=stim + 0x24 ; stim+36
 0000002A  5840      LDR         R0,[R0,R1]
 0000002C  2800      CMP         R0,#0x0
 0000002E  D126      BNE         L_364  ; T=0x0000007E
 1560:             if(curTime < stim[index].startTime)  // end off start delay ?
 00000030  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000032  5842      LDR         R2,[R0,R1]
 00000034  4800      LDR         R0,=curTime ; curTime
 00000036  6800      LDR         R0,[R0,#0x0] ; curTime
 00000038  4290      CMP         R0,R2
 0000003A  D215      BCS         L_365  ; T=0x00000068
 1564:                 if (((barEdge == 1) && ((parInp & barBit) == 0)) ||
 0000003C  2F01      CMP         R7,#0x1 ; barEdge
 0000003E  D104      BNE         L_368  ; T=0x0000004A
 00000040  4800      LDR         R0,=parInp ; parInp
 00000042  6800      LDR         R0,[R0,#0x0] ; parInp
 00000044  4030      AND         R0,R6 ; barBit
 00000046  2800      CMP         R0,#0x0
 00000048  D006      BEQ         L_367  ; T=0x00000058
 0000004A          L_368:
 0000004A  2F00      CMP         R7,#0x0 ; barEdge
 0000004C  D106      BNE         L_366  ; T=0x0000005C
 0000004E  4800      LDR         R0,=parInp ; parInp
 00000050  6800      LDR         R0,[R0,#0x0] ; parInp
 00000052  4030      AND         R0,R6 ; barBit
 00000054  2800      CMP         R0,#0x0
 00000056  DD01      BLE         L_366  ; T=0x0000005C
 00000058          L_367:
 1567:                     return 2;
 00000058  2002      MOV         R0,#0x2
 0000005A  E076      B           L_369  ; T=0x0000014A
 1568:                 }
 0000005C          L_366:
 1571:                     stim[index].startTime = newTime;
 0000005C  4800      LDR         R0,=stim + 0x28 ; stim+40
 0000005E  5045      STR         R5,[R0,R1] ; newTime
 1572:                     execError();
 00000060  F7FF      BL          execError?T  ; T=0x0001  (1)
 00000062  FFCE      BL          execError?T  ; T=0x0001  (2)
 1573:                     return 0;                   // exit with error
 00000064  2000      MOV         R0,#0x0
 00000066  E070      B           L_369  ; T=0x0000014A
 1575:             }
 00000068          L_365:
 1578:                 stim[index].startTime = newTime;
 00000068  214C      MOV         R1,#0x4C
 0000006A  4361      MUL         R1,R4 ; index
 0000006C  4800      LDR         R0,=stim + 0x28 ; stim+40
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 125 

 0000006E  5045      STR         R5,[R0,R1] ; newTime
 1579:                 stim[index].status    = statRun;
 00000070  210A      MOV         R1,#0xA
 00000072  224C      MOV         R2,#0x4C
 00000074  4362      MUL         R2,R4 ; index
 00000076  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000078  5081      STR         R1,[R0,R2]
 1580:                 return 1;
 0000007A  2001      MOV         R0,#0x1
 0000007C  E065      B           L_369  ; T=0x0000014A
 1582:         }
 0000007E          L_364:
 1584:             return 2;
 0000007E  2002      MOV         R0,#0x2
 00000080  E063      B           L_369  ; T=0x0000014A
 1585:     }
 00000082          L_363:
 1588:     if (stim[index].status == statRun)
 00000082  214C      MOV         R1,#0x4C
 00000084  4361      MUL         R1,R4 ; index
 00000086  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000088  5840      LDR         R0,[R0,R1]
 0000008A  280A      CMP         R0,#0xA
 0000008C  D15C      BNE         L_373  ; T=0x00000148
 1590:         if (stim[index].stopRef == 0)           // endtime set ?
 0000008E  214C      MOV         R1,#0x4C
 00000090  4361      MUL         R1,R4 ; index
 00000092  4800      LDR         R0,=stim + 0x2C ; stim+44
 00000094  5840      LDR         R0,[R0,R1]
 00000096  2800      CMP         R0,#0x0
 00000098  D130      BNE         L_374  ; T=0x000000FC
 1592:             if (curTime < stim[index].stopTime) // and reached
 0000009A  214C      MOV         R1,#0x4C
 0000009C  4361      MUL         R1,R4 ; index
 0000009E  4800      LDR         R0,=stim + 0x30 ; stim+48
 000000A0  5841      LDR         R1,[R0,R1]
 000000A2  4800      LDR         R0,=curTime ; curTime
 000000A4  6800      LDR         R0,[R0,#0x0] ; curTime
 000000A6  4288      CMP         R0,R1
 000000A8  D220      BCS         L_375  ; T=0x000000EC
 1596:                 if (((barEdge == 1) && ((parInp & barBit) >  0)) ||
 000000AA  2F01      CMP         R7,#0x1 ; barEdge
 000000AC  D104      BNE         L_378  ; T=0x000000B8
 000000AE  4800      LDR         R0,=parInp ; parInp
 000000B0  6800      LDR         R0,[R0,#0x0] ; parInp
 000000B2  4030      AND         R0,R6 ; barBit
 000000B4  2800      CMP         R0,#0x0
 000000B6  DC06      BGT         L_377  ; T=0x000000C6
 000000B8          L_378:
 000000B8  2F00      CMP         R7,#0x0 ; barEdge
 000000BA  D115      BNE         L_376  ; T=0x000000E8
 000000BC  4800      LDR         R0,=parInp ; parInp
 000000BE  6800      LDR         R0,[R0,#0x0] ; parInp
 000000C0  4030      AND         R0,R6 ; barBit
 000000C2  2800      CMP         R0,#0x0
 000000C4  D110      BNE         L_376  ; T=0x000000E8
 000000C6          L_377:
 1599:                     stim[index].stopTime = newTime;
 000000C6  214C      MOV         R1,#0x4C
 000000C8  4361      MUL         R1,R4 ; index
 000000CA  4800      LDR         R0,=stim + 0x30 ; stim+48
 000000CC  5045      STR         R5,[R0,R1] ; newTime
 1600:                     stim[index].status   = statDone;
 000000CE  2105      MOV         R1,#0x5
 000000D0  224C      MOV         R2,#0x4C
 000000D2  4362      MUL         R2,R4 ; index
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 126 

 000000D4  4800      LDR         R0,=stim + 0x4 ; stim+4
 000000D6  5081      STR         R1,[R0,R2]
 1601:                     execEvent(stim[index].event);
 000000D8  214C      MOV         R1,#0x4C
 000000DA  4361      MUL         R1,R4 ; index
 000000DC  4800      LDR         R0,=stim + 0x3C ; stim+60
 000000DE  5840      LDR         R0,[R0,R1]
 000000E0  F7FF      BL          execEvent?T  ; T=0x0001  (1)
 000000E2  FF8E      BL          execEvent?T  ; T=0x0001  (2)
 1602:                     return 0;                   // exit after executing event
 000000E4  2000      MOV         R0,#0x0
 000000E6  E030      B           L_369  ; T=0x0000014A
 1603:                 }
 000000E8          L_376:
 1606:                     return 1;
 000000E8  2001      MOV         R0,#0x1
 000000EA  E02E      B           L_369  ; T=0x0000014A
 1608:             }
 000000EC          L_375:
 1611:                 stim[index].stopTime = newTime;
 000000EC  214C      MOV         R1,#0x4C
 000000EE  4361      MUL         R1,R4 ; index
 000000F0  4800      LDR         R0,=stim + 0x30 ; stim+48
 000000F2  5045      STR         R5,[R0,R1] ; newTime
 1612:                 execError();
 000000F4  F7FF      BL          execError?T  ; T=0x0001  (1)
 000000F6  FF84      BL          execError?T  ; T=0x0001  (2)
 1613:                 return 0;
 000000F8  2000      MOV         R0,#0x0
 000000FA  E026      B           L_369  ; T=0x0000014A
 1615:         }
 000000FC          L_374:
 1620:             if (((barEdge == 1) && ((parInp & barBit) >  0)) ||
 000000FC  2F01      CMP         R7,#0x1 ; barEdge
 000000FE  D104      BNE         L_384  ; T=0x0000010A
 00000100  4800      LDR         R0,=parInp ; parInp
 00000102  6800      LDR         R0,[R0,#0x0] ; parInp
 00000104  4030      AND         R0,R6 ; barBit
 00000106  2800      CMP         R0,#0x0
 00000108  DC06      BGT         L_383  ; T=0x00000118
 0000010A          L_384:
 0000010A  2F00      CMP         R7,#0x0 ; barEdge
 0000010C  D11A      BNE         L_382  ; T=0x00000144
 0000010E  4800      LDR         R0,=parInp ; parInp
 00000110  6800      LDR         R0,[R0,#0x0] ; parInp
 00000112  4030      AND         R0,R6 ; barBit
 00000114  2800      CMP         R0,#0x0
 00000116  D115      BNE         L_382  ; T=0x00000144
 00000118          L_383:
 1623:                     stim[index].stopRef  = 0;
 00000118  2100      MOV         R1,#0x0
 0000011A  224C      MOV         R2,#0x4C
 0000011C  4362      MUL         R2,R4 ; index
 0000011E  4800      LDR         R0,=stim + 0x2C ; stim+44
 00000120  5081      STR         R1,[R0,R2]
 1624:                     stim[index].stopTime = newTime;
 00000122  214C      MOV         R1,#0x4C
 00000124  4361      MUL         R1,R4 ; index
 00000126  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000128  5045      STR         R5,[R0,R1] ; newTime
 1625:                     stim[index].status   = statDone;
 0000012A  2105      MOV         R1,#0x5
 0000012C  224C      MOV         R2,#0x4C
 0000012E  4362      MUL         R2,R4 ; index
 00000130  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000132  5081      STR         R1,[R0,R2]
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 127 

 1626:                     execEvent(stim[index].event);
 00000134  214C      MOV         R1,#0x4C
 00000136  4361      MUL         R1,R4 ; index
 00000138  4800      LDR         R0,=stim + 0x3C ; stim+60
 0000013A  5840      LDR         R0,[R0,R1]
 0000013C  F7FF      BL          execEvent?T  ; T=0x0001  (1)
 0000013E  FF60      BL          execEvent?T  ; T=0x0001  (2)
 1627:                     return 0;                   // exit after executing event
 00000140  2000      MOV         R0,#0x0
 00000142  E002      B           L_369  ; T=0x0000014A
 1628:             }
 00000144          L_382:
 1631:                 return 1;
 00000144  2001      MOV         R0,#0x1
 00000146  E000      B           L_369  ; T=0x0000014A
 1634:     }
 00000148          L_373:
 1636:     return 0;
 00000148  2000      MOV         R0,#0x0
 0000014A            ; SCOPE-END
 1637: }
 0000014A          L_369:
 0000014A  BCF0      POP         {R4-R7}
 0000014C  BC08      POP         {R3}
 0000014E  4718      BX          R3
 00000150          ENDP ; 'execBarFlank?T'


*** CODE SEGMENT '?PR?execSky?T?Fart':
 1639: int execSky(int index)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C05      MOV         R5,R0 ; index
 00000004  ---- Variable 'index' assigned to Register 'R5' ----
 1640: {                                                                        
 00000004            ; SCOPE-START
 1641:     int newTime = Clock_GetTicks() - T_start;
 00000004  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000006  FFFC      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000008  4800      LDR         R1,=T_start ; T_start
 0000000A  6809      LDR         R1,[R1,#0x0] ; T_start
 0000000C  1A44      SUB         R4,R0,R1 ; Clock_GetTicks?T
 0000000E  ---- Variable 'newTime' assigned to Register 'R4' ----
 1642:     if (stim[index].status == statInit)
 0000000E  274C      MOV         R7,#0x4C
 00000010  436F      MUL         R7,R5 ; index
 00000012  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000014  59C6      LDR         R6,[R0,R7]
 00000016  2E01      CMP         R6,#0x1
 00000018  D11D      BNE         L_386  ; T=0x00000056
 1644:         if ((stim[index].startRef == 0) && (curTime >= stim[index].startTime))
 0000001A  4800      LDR         R0,=stim + 0x24 ; stim+36
 0000001C  59C0      LDR         R0,[R0,R7]
 0000001E  2800      CMP         R0,#0x0
 00000020  D117      BNE         L_387  ; T=0x00000052
 00000022  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000024  59C1      LDR         R1,[R0,R7]
 00000026  4800      LDR         R0,=curTime ; curTime
 00000028  6800      LDR         R0,[R0,#0x0] ; curTime
 0000002A  4288      CMP         R0,R1
 0000002C  D311      BCC         L_387  ; T=0x00000052
 1646:                 SkyOnOff(stim[index].posX, stim[index].posY, stim[index].level, ON);
 0000002E  4800      LDR         R0,=stim + 0x18 ; stim+24
 00000030  59C0      LDR         R0,[R0,R7]
 00000032  4800      LDR         R1,=stim + 0x1C ; stim+28
 00000034  59C9      LDR         R1,[R1,R7]
 00000036  4800      LDR         R2,=stim + 0x20 ; stim+32
 00000038  59D2      LDR         R2,[R2,R7]
 0000003A  2301      MOV         R3,#0x1
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 128 

 0000003C  F7FF      BL          SkyOnOff?T  ; T=0x0001  (1)
 0000003E  FFE0      BL          SkyOnOff?T  ; T=0x0001  (2)
 1647:                 stim[index].startTime = newTime;
 00000040  224C      MOV         R2,#0x4C
 00000042  436A      MUL         R2,R5 ; index
 00000044  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000046  5084      STR         R4,[R0,R2] ; newTime
 1648:                 stim[index].status    = statRun;
 00000048  200A      MOV         R0,#0xA
 0000004A  4800      LDR         R1,=stim + 0x4 ; stim+4
 0000004C  5088      STR         R0,[R1,R2]
 1649:                 return 1;
 0000004E  2001      MOV         R0,#0x1
 00000050  E030      B           L_388  ; T=0x000000B4
 1650:             }
 00000052          L_387:
 1652:         return 2;
 00000052  2002      MOV         R0,#0x2
 00000054  E02E      B           L_388  ; T=0x000000B4
 1653:     }
 00000056          L_386:
 1655:     if (stim[index].status == statRun)
 00000056  2E0A      CMP         R6,#0xA
 00000058  D12B      BNE         L_389  ; T=0x000000B2
 1657:         if ((stim[index].stopRef == 0) && (curTime >= stim[index].stopTime))
 0000005A  214C      MOV         R1,#0x4C
 0000005C  4369      MUL         R1,R5 ; index
 0000005E  4800      LDR         R0,=stim + 0x2C ; stim+44
 00000060  5840      LDR         R0,[R0,R1]
 00000062  2800      CMP         R0,#0x0
 00000064  D123      BNE         L_390  ; T=0x000000AE
 00000066  214C      MOV         R1,#0x4C
 00000068  4369      MUL         R1,R5 ; index
 0000006A  4800      LDR         R0,=stim + 0x30 ; stim+48
 0000006C  5841      LDR         R1,[R0,R1]
 0000006E  4800      LDR         R0,=curTime ; curTime
 00000070  6800      LDR         R0,[R0,#0x0] ; curTime
 00000072  4288      CMP         R0,R1
 00000074  D31B      BCC         L_390  ; T=0x000000AE
 1659:             SkyOnOff(stim[index].posX, stim[index].posY, stim[index].level, OFF);
 00000076  214C      MOV         R1,#0x4C
 00000078  4369      MUL         R1,R5 ; index
 0000007A  4800      LDR         R0,=stim + 0x18 ; stim+24
 0000007C  5840      LDR         R0,[R0,R1]
 0000007E  224C      MOV         R2,#0x4C
 00000080  436A      MUL         R2,R5 ; index
 00000082  4800      LDR         R1,=stim + 0x1C ; stim+28
 00000084  5889      LDR         R1,[R1,R2]
 00000086  234C      MOV         R3,#0x4C
 00000088  436B      MUL         R3,R5 ; index
 0000008A  4800      LDR         R2,=stim + 0x20 ; stim+32
 0000008C  58D2      LDR         R2,[R2,R3]
 0000008E  2300      MOV         R3,#0x0
 00000090  F7FF      BL          SkyOnOff?T  ; T=0x0001  (1)
 00000092  FFB6      BL          SkyOnOff?T  ; T=0x0001  (2)
 1660:             stim[index].stopTime = newTime;
 00000094  214C      MOV         R1,#0x4C
 00000096  4369      MUL         R1,R5 ; index
 00000098  4800      LDR         R0,=stim + 0x30 ; stim+48
 0000009A  5044      STR         R4,[R0,R1] ; newTime
 1661:             stim[index].status   = statDone;
 0000009C  2005      MOV         R0,#0x5
 0000009E  4800      LDR         R2,=stim + 0x4 ; stim+4
 000000A0  5050      STR         R0,[R2,R1]
 1662:             execEvent(stim[index].event);
 000000A2  4800      LDR         R0,=stim + 0x3C ; stim+60
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 129 

 000000A4  5840      LDR         R0,[R0,R1]
 000000A6  F7FF      BL          execEvent?T  ; T=0x0001  (1)
 000000A8  FFAB      BL          execEvent?T  ; T=0x0001  (2)
 1663:             return 0;
 000000AA  2000      MOV         R0,#0x0
 000000AC  E002      B           L_388  ; T=0x000000B4
 1664:         }
 000000AE          L_390:
 1665:         return 1;
 000000AE  2001      MOV         R0,#0x1
 000000B0  E000      B           L_388  ; T=0x000000B4
 1666:     }
 000000B2          L_389:
 1667:     return 0;
 000000B2  2000      MOV         R0,#0x0
 000000B4            ; SCOPE-END
 1668: }
 000000B4          L_388:
 000000B4  BCF0      POP         {R4-R7}
 000000B6  BC08      POP         {R3}
 000000B8  4718      BX          R3
 000000BA          ENDP ; 'execSky?T'


*** CODE SEGMENT '?PR?execLed?T?Fart':
 1670: int execLed(int index)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C05      MOV         R5,R0 ; index
 00000004  ---- Variable 'index' assigned to Register 'R5' ----
 1671: { 
 00000004            ; SCOPE-START
 1672:     int newTime = Clock_GetTicks() - T_start;
 00000004  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000006  FFFC      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000008  4800      LDR         R1,=T_start ; T_start
 0000000A  6809      LDR         R1,[R1,#0x0] ; T_start
 0000000C  1A44      SUB         R4,R0,R1 ; Clock_GetTicks?T
 0000000E  ---- Variable 'newTime' assigned to Register 'R4' ----
 1673:     if (stim[index].status == statInit)
 0000000E  274C      MOV         R7,#0x4C
 00000010  436F      MUL         R7,R5 ; index
 00000012  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000014  59C6      LDR         R6,[R0,R7]
 00000016  2E01      CMP         R6,#0x1
 00000018  D11B      BNE         L_391  ; T=0x00000052
 1675:         if ((stim[index].startRef == 0) && (curTime >= stim[index].startTime))
 0000001A  4800      LDR         R0,=stim + 0x24 ; stim+36
 0000001C  59C0      LDR         R0,[R0,R7]
 0000001E  2800      CMP         R0,#0x0
 00000020  D115      BNE         L_392  ; T=0x0000004E
 00000022  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000024  59C1      LDR         R1,[R0,R7]
 00000026  4800      LDR         R0,=curTime ; curTime
 00000028  6800      LDR         R0,[R0,#0x0] ; curTime
 0000002A  4288      CMP         R0,R1
 0000002C  D30F      BCC         L_392  ; T=0x0000004E
 1677:             LedOnOff(stim[index].posY, stim[index].level, ON);
 0000002E  4800      LDR         R0,=stim + 0x1C ; stim+28
 00000030  59C0      LDR         R0,[R0,R7]
 00000032  4800      LDR         R1,=stim + 0x20 ; stim+32
 00000034  59C9      LDR         R1,[R1,R7]
 00000036  2201      MOV         R2,#0x1
 00000038  F7FF      BL          LedOnOff?T  ; T=0x0001  (1)
 0000003A  FFE2      BL          LedOnOff?T  ; T=0x0001  (2)
 1678:             stim[index].startTime = newTime;
 0000003C  224C      MOV         R2,#0x4C
 0000003E  436A      MUL         R2,R5 ; index
 00000040  4800      LDR         R0,=stim + 0x28 ; stim+40
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 130 

 00000042  5084      STR         R4,[R0,R2] ; newTime
 1679:             stim[index].status = statRun;
 00000044  200A      MOV         R0,#0xA
 00000046  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000048  5088      STR         R0,[R1,R2]
 1680:             return 1;
 0000004A  2001      MOV         R0,#0x1
 0000004C  E02C      B           L_393  ; T=0x000000A8
 1681:         }
 0000004E          L_392:
 1682:         return 2;
 0000004E  2002      MOV         R0,#0x2
 00000050  E02A      B           L_393  ; T=0x000000A8
 1683:     }
 00000052          L_391:
 1685:     if (stim[index].status == statRun)
 00000052  2E0A      CMP         R6,#0xA
 00000054  D127      BNE         L_394  ; T=0x000000A6
 1687:         if ((stim[index].stopRef == 0) && (curTime >= stim[index].stopTime))
 00000056  214C      MOV         R1,#0x4C
 00000058  4369      MUL         R1,R5 ; index
 0000005A  4800      LDR         R0,=stim + 0x2C ; stim+44
 0000005C  5840      LDR         R0,[R0,R1]
 0000005E  2800      CMP         R0,#0x0
 00000060  D11F      BNE         L_395  ; T=0x000000A2
 00000062  214C      MOV         R1,#0x4C
 00000064  4369      MUL         R1,R5 ; index
 00000066  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000068  5841      LDR         R1,[R0,R1]
 0000006A  4800      LDR         R0,=curTime ; curTime
 0000006C  6800      LDR         R0,[R0,#0x0] ; curTime
 0000006E  4288      CMP         R0,R1
 00000070  D317      BCC         L_395  ; T=0x000000A2
 1689:             LedOnOff(stim[index].posY, stim[index].level, OFF);
 00000072  214C      MOV         R1,#0x4C
 00000074  4369      MUL         R1,R5 ; index
 00000076  4800      LDR         R0,=stim + 0x1C ; stim+28
 00000078  5840      LDR         R0,[R0,R1]
 0000007A  224C      MOV         R2,#0x4C
 0000007C  436A      MUL         R2,R5 ; index
 0000007E  4800      LDR         R1,=stim + 0x20 ; stim+32
 00000080  5889      LDR         R1,[R1,R2]
 00000082  2200      MOV         R2,#0x0
 00000084  F7FF      BL          LedOnOff?T  ; T=0x0001  (1)
 00000086  FFBC      BL          LedOnOff?T  ; T=0x0001  (2)
 1690:             stim[index].stopTime = newTime;
 00000088  214C      MOV         R1,#0x4C
 0000008A  4369      MUL         R1,R5 ; index
 0000008C  4800      LDR         R0,=stim + 0x30 ; stim+48
 0000008E  5044      STR         R4,[R0,R1] ; newTime
 1691:             stim[index].status   = statDone;
 00000090  2005      MOV         R0,#0x5
 00000092  4800      LDR         R2,=stim + 0x4 ; stim+4
 00000094  5050      STR         R0,[R2,R1]
 1692:             execEvent(stim[index].event);
 00000096  4800      LDR         R0,=stim + 0x3C ; stim+60
 00000098  5840      LDR         R0,[R0,R1]
 0000009A  F7FF      BL          execEvent?T  ; T=0x0001  (1)
 0000009C  FFB1      BL          execEvent?T  ; T=0x0001  (2)
 1693:             return 0;
 0000009E  2000      MOV         R0,#0x0
 000000A0  E002      B           L_393  ; T=0x000000A8
 1694:         }
 000000A2          L_395:
 1695:         return 1;
 000000A2  2001      MOV         R0,#0x1
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 131 

 000000A4  E000      B           L_393  ; T=0x000000A8
 1696:     }
 000000A6          L_394:
 1698:     return 0;
 000000A6  2000      MOV         R0,#0x0
 000000A8            ; SCOPE-END
 1699: }
 000000A8          L_393:
 000000A8  BCF0      POP         {R4-R7}
 000000AA  BC08      POP         {R3}
 000000AC  4718      BX          R3
 000000AE          ENDP ; 'execLed?T'


*** CODE SEGMENT '?PR?execRec?T?Fart':
 1701: int execRec(int index)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C05      MOV         R5,R0 ; index
 00000004  ---- Variable 'index' assigned to Register 'R5' ----
 1702: {
 00000004            ; SCOPE-START
 1703:     int newTime = Clock_GetTicks() - T_start;
 00000004  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000006  FFFC      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000008  4800      LDR         R1,=T_start ; T_start
 0000000A  6809      LDR         R1,[R1,#0x0] ; T_start
 0000000C  1A44      SUB         R4,R0,R1 ; Clock_GetTicks?T
 0000000E  ---- Variable 'newTime' assigned to Register 'R4' ----
 1705:     if (stim[index].status == statInit)
 0000000E  274C      MOV         R7,#0x4C
 00000010  436F      MUL         R7,R5 ; index
 00000012  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000014  59C6      LDR         R6,[R0,R7]
 00000016  2E01      CMP         R6,#0x1
 00000018  D11D      BNE         L_396  ; T=0x00000056
 1707:         if ((stim[index].startRef == 0) && (curTime >= stim[index].startTime))
 0000001A  4800      LDR         R0,=stim + 0x24 ; stim+36
 0000001C  59C0      LDR         R0,[R0,R7]
 0000001E  2800      CMP         R0,#0x0
 00000020  D117      BNE         L_397  ; T=0x00000052
 00000022  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000024  59C1      LDR         R1,[R0,R7]
 00000026  4800      LDR         R0,=curTime ; curTime
 00000028  6800      LDR         R0,[R0,#0x0] ; curTime
 0000002A  4288      CMP         R0,R1
 0000002C  D311      BCC         L_397  ; T=0x00000052
 1709:             stim[index].startTime = newTime;
 0000002E  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000030  51C4      STR         R4,[R0,R7] ; newTime
 1710:             stim[index].status    = statRun;
 00000032  200A      MOV         R0,#0xA
 00000034  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000036  51C8      STR         R0,[R1,R7]
 1711:             SetBitsPar(recBit);   // maak trigger hoog
 00000038  4800      LDR         R0,=recBit ; recBit
 0000003A  6800      LDR         R0,[R0,#0x0] ; recBit
 0000003C  F7FF      BL          SetBitsPar?T  ; T=0x0001  (1)
 0000003E  FFE0      BL          SetBitsPar?T  ; T=0x0001  (2)
 1712:             parOutp |= recBit;
 00000040  4800      LDR         R0,=recBit ; recBit
 00000042  6800      LDR         R0,[R0,#0x0] ; recBit
 00000044  4800      LDR         R1,=parOutp ; parOutp
 00000046  6809      LDR         R1,[R1,#0x0] ; parOutp
 00000048  4301      ORR         R1,R0
 0000004A  4800      LDR         R0,=parOutp ; parOutp
 0000004C  6001      STR         R1,[R0,#0x0] ; parOutp
 1713:             return 1;
 0000004E  2001      MOV         R0,#0x1
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 132 

 00000050  E04F      B           L_398  ; T=0x000000F2
 1714:         }
 00000052          L_397:
 1715:         return 2;
 00000052  2002      MOV         R0,#0x2
 00000054  E04D      B           L_398  ; T=0x000000F2
 1716:     }
 00000056          L_396:
 1718:     if (stim[index].status == statRun)
 00000056  2E0A      CMP         R6,#0xA
 00000058  D14A      BNE         L_399  ; T=0x000000F0
 1720:         if (curTime > stim[index].startTime+10) // geef circuit tijd om te starten
 0000005A  214C      MOV         R1,#0x4C
 0000005C  4369      MUL         R1,R5 ; index
 0000005E  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000060  5841      LDR         R1,[R0,R1]
 00000062  310A      ADD         R1,#0xA
 00000064  4800      LDR         R0,=curTime ; curTime
 00000066  6800      LDR         R0,[R0,#0x0] ; curTime
 00000068  4288      CMP         R0,R1
 0000006A  D91B      BLS         L_400  ; T=0x000000A4
 1721:         {
 0000006C            ; SCOPE-START
 1722:             int parInp  = GetBitsPar();
 0000006C  F7FF      BL          GetBitsPar?T  ; T=0x0001  (1)
 0000006E  FFC8      BL          GetBitsPar?T  ; T=0x0001  (2)
 00000070  1C01      MOV         R1,R0 ; parInp
 00000072  ---- Variable 'parInp' assigned to Register 'R1' ----
 1723:             if ((parInp & recBit) == 0)         // ready
 00000072  4800      LDR         R0,=recBit ; recBit
 00000074  6800      LDR         R0,[R0,#0x0] ; recBit
 00000076  4001      AND         R1,R0
 00000078  2900      CMP         R1,#0x0 ; parInp
 0000007A  D113      BNE         L_400  ; T=0x000000A4
 1725:                 parOutp &= ~recBit;             // trigger laag
 0000007C  4800      LDR         R1,=parOutp ; parOutp
 0000007E  680A      LDR         R2,[R1,#0x0] ; parOutp
 00000080  4382      BIC         R2,R0
 00000082  4800      LDR         R1,=parOutp ; parOutp
 00000084  600A      STR         R2,[R1,#0x0] ; parOutp
 1726:                 ClrBitsPar(recBit);
 00000086  F7FF      BL          ClrBitsPar?T  ; T=0x0001  (1)
 00000088  FFBB      BL          ClrBitsPar?T  ; T=0x0001  (2)
 1727:                 stim[index].stopTime = newTime;
 0000008A  214C      MOV         R1,#0x4C
 0000008C  4369      MUL         R1,R5 ; index
 0000008E  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000090  5044      STR         R4,[R0,R1] ; newTime
 1728:                 stim[index].status   = statDone;
 00000092  2005      MOV         R0,#0x5
 00000094  4800      LDR         R2,=stim + 0x4 ; stim+4
 00000096  5050      STR         R0,[R2,R1]
 1729:                 execEvent(stim[index].event);
 00000098  4800      LDR         R0,=stim + 0x3C ; stim+60
 0000009A  5840      LDR         R0,[R0,R1]
 0000009C  F7FF      BL          execEvent?T  ; T=0x0001  (1)
 0000009E  FFB0      BL          execEvent?T  ; T=0x0001  (2)
 1730:                 return 0;
 000000A0  2000      MOV         R0,#0x0
 000000A2  E026      B           L_398  ; T=0x000000F2
 1731:             }
 000000A4            ; SCOPE-END
 1732:         }
 000000A4          L_400:
 1733:         if ((stim[index].stopRef == 0) && (curTime >= stim[index].stopTime))
 000000A4  214C      MOV         R1,#0x4C
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 133 

 000000A6  4369      MUL         R1,R5 ; index
 000000A8  4800      LDR         R0,=stim + 0x2C ; stim+44
 000000AA  5840      LDR         R0,[R0,R1]
 000000AC  2800      CMP         R0,#0x0
 000000AE  D11D      BNE         L_402  ; T=0x000000EC
 000000B0  214C      MOV         R1,#0x4C
 000000B2  4369      MUL         R1,R5 ; index
 000000B4  4800      LDR         R0,=stim + 0x30 ; stim+48
 000000B6  5841      LDR         R1,[R0,R1]
 000000B8  4800      LDR         R0,=curTime ; curTime
 000000BA  6800      LDR         R0,[R0,#0x0] ; curTime
 000000BC  4288      CMP         R0,R1
 000000BE  D315      BCC         L_402  ; T=0x000000EC
 1735:             parOutp &= ~recBit;             // trigger laag
 000000C0  4800      LDR         R0,=recBit ; recBit
 000000C2  6800      LDR         R0,[R0,#0x0] ; recBit
 000000C4  4800      LDR         R1,=parOutp ; parOutp
 000000C6  680A      LDR         R2,[R1,#0x0] ; parOutp
 000000C8  4382      BIC         R2,R0
 000000CA  4800      LDR         R1,=parOutp ; parOutp
 000000CC  600A      STR         R2,[R1,#0x0] ; parOutp
 1736:             ClrBitsPar(recBit);
 000000CE  F7FF      BL          ClrBitsPar?T  ; T=0x0001  (1)
 000000D0  FF97      BL          ClrBitsPar?T  ; T=0x0001  (2)
 1737:             stim[index].stopTime = newTime;
 000000D2  214C      MOV         R1,#0x4C
 000000D4  4369      MUL         R1,R5 ; index
 000000D6  4800      LDR         R0,=stim + 0x30 ; stim+48
 000000D8  5044      STR         R4,[R0,R1] ; newTime
 1738:             stim[index].status   = statDone;
 000000DA  2005      MOV         R0,#0x5
 000000DC  4800      LDR         R2,=stim + 0x4 ; stim+4
 000000DE  5050      STR         R0,[R2,R1]
 1739:             execEvent(stim[index].event);
 000000E0  4800      LDR         R0,=stim + 0x3C ; stim+60
 000000E2  5840      LDR         R0,[R0,R1]
 000000E4  F7FF      BL          execEvent?T  ; T=0x0001  (1)
 000000E6  FF8C      BL          execEvent?T  ; T=0x0001  (2)
 1740:             return 0;
 000000E8  2000      MOV         R0,#0x0
 000000EA  E002      B           L_398  ; T=0x000000F2
 1741:         }
 000000EC          L_402:
 1742:         return 1;
 000000EC  2001      MOV         R0,#0x1
 000000EE  E000      B           L_398  ; T=0x000000F2
 1743:     }
 000000F0          L_399:
 1744:     return 0;
 000000F0  2000      MOV         R0,#0x0
 000000F2            ; SCOPE-END
 1745: }
 000000F2          L_398:
 000000F2  BCF0      POP         {R4-R7}
 000000F4  BC08      POP         {R3}
 000000F6  4718      BX          R3
 000000F8          ENDP ; 'execRec?T'


*** CODE SEGMENT '?PR?execSnd?T?Fart':
 1747: int execSnd(int index)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C05      MOV         R5,R0 ; index
 00000004  ---- Variable 'index' assigned to Register 'R5' ----
 1748: {
 00000004            ; SCOPE-START
 1749:     int newTime = Clock_GetTicks() - T_start;
 00000004  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 134 

 00000006  FFFC      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000008  4800      LDR         R1,=T_start ; T_start
 0000000A  6809      LDR         R1,[R1,#0x0] ; T_start
 0000000C  1A44      SUB         R4,R0,R1 ; Clock_GetTicks?T
 0000000E  ---- Variable 'newTime' assigned to Register 'R4' ----
 1751:     if (stim[index].status == statInit)
 0000000E  274C      MOV         R7,#0x4C
 00000010  436F      MUL         R7,R5 ; index
 00000012  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000014  59C6      LDR         R6,[R0,R7]
 00000016  2E01      CMP         R6,#0x1
 00000018  D11D      BNE         L_403  ; T=0x00000056
 1753:         if ((stim[index].startRef == 0) && (curTime >= stim[index].startTime))
 0000001A  4800      LDR         R0,=stim + 0x24 ; stim+36
 0000001C  59C0      LDR         R0,[R0,R7]
 0000001E  2800      CMP         R0,#0x0
 00000020  D117      BNE         L_404  ; T=0x00000052
 00000022  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000024  59C1      LDR         R1,[R0,R7]
 00000026  4800      LDR         R0,=curTime ; curTime
 00000028  6800      LDR         R0,[R0,#0x0] ; curTime
 0000002A  4288      CMP         R0,R1
 0000002C  D311      BCC         L_404  ; T=0x00000052
 1755:             stim[index].startTime = newTime;
 0000002E  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000030  51C4      STR         R4,[R0,R7] ; newTime
 1756:             stim[index].status    = statRun;
 00000032  200A      MOV         R0,#0xA
 00000034  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000036  51C8      STR         R0,[R1,R7]
 1757:             SetBitsPar(sndBit);   
 00000038  4800      LDR         R0,=sndBit ; sndBit
 0000003A  6800      LDR         R0,[R0,#0x0] ; sndBit
 0000003C  F7FF      BL          SetBitsPar?T  ; T=0x0001  (1)
 0000003E  FFE0      BL          SetBitsPar?T  ; T=0x0001  (2)
 1758:             parOutp |= sndBit;
 00000040  4800      LDR         R0,=sndBit ; sndBit
 00000042  6800      LDR         R0,[R0,#0x0] ; sndBit
 00000044  4800      LDR         R1,=parOutp ; parOutp
 00000046  6809      LDR         R1,[R1,#0x0] ; parOutp
 00000048  4301      ORR         R1,R0
 0000004A  4800      LDR         R0,=parOutp ; parOutp
 0000004C  6001      STR         R1,[R0,#0x0] ; parOutp
 1759:             return 1;
 0000004E  2001      MOV         R0,#0x1
 00000050  E049      B           L_405  ; T=0x000000E6
 1760:         }
 00000052          L_404:
 1761:         return 2;
 00000052  2002      MOV         R0,#0x2
 00000054  E047      B           L_405  ; T=0x000000E6
 1762:     }
 00000056          L_403:
 1764:     if (stim[index].status == statRun)
 00000056  2E0A      CMP         R6,#0xA
 00000058  D144      BNE         L_406  ; T=0x000000E4
 1766:         if ((stim[index].stopRef == 0) && (curTime >= stim[index].stopTime))
 0000005A  214C      MOV         R1,#0x4C
 0000005C  4369      MUL         R1,R5 ; index
 0000005E  4800      LDR         R0,=stim + 0x2C ; stim+44
 00000060  5840      LDR         R0,[R0,R1]
 00000062  2800      CMP         R0,#0x0
 00000064  D118      BNE         L_407  ; T=0x00000098
 00000066  214C      MOV         R1,#0x4C
 00000068  4369      MUL         R1,R5 ; index
 0000006A  4800      LDR         R0,=stim + 0x30 ; stim+48
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 135 

 0000006C  5841      LDR         R1,[R0,R1]
 0000006E  4800      LDR         R0,=curTime ; curTime
 00000070  6800      LDR         R0,[R0,#0x0] ; curTime
 00000072  4288      CMP         R0,R1
 00000074  D310      BCC         L_407  ; T=0x00000098
 1768:                 ClrBitsPar(sndBit);  
 00000076  4800      LDR         R0,=sndBit ; sndBit
 00000078  6800      LDR         R0,[R0,#0x0] ; sndBit
 0000007A  F7FF      BL          ClrBitsPar?T  ; T=0x0001  (1)
 0000007C  FFC1      BL          ClrBitsPar?T  ; T=0x0001  (2)
 1769:                 parOutp &= ~sndBit;
 0000007E  4800      LDR         R0,=sndBit ; sndBit
 00000080  6800      LDR         R0,[R0,#0x0] ; sndBit
 00000082  4800      LDR         R1,=parOutp ; parOutp
 00000084  6809      LDR         R1,[R1,#0x0] ; parOutp
 00000086  4381      BIC         R1,R0
 00000088  4800      LDR         R0,=parOutp ; parOutp
 0000008A  6001      STR         R1,[R0,#0x0] ; parOutp
 1770:                 stim[index].stopTime = newTime;
 0000008C  214C      MOV         R1,#0x4C
 0000008E  4369      MUL         R1,R5 ; index
 00000090  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000092  5044      STR         R4,[R0,R1] ; newTime
 1771:                 execError();
 00000094  F7FF      BL          execError?T  ; T=0x0001  (1)
 00000096  FFB4      BL          execError?T  ; T=0x0001  (2)
 1772:         }
 00000098          L_407:
 1773:         if ((parInp & sndBit) == 0)
 00000098  4800      LDR         R0,=sndBit ; sndBit
 0000009A  6800      LDR         R0,[R0,#0x0] ; sndBit
 0000009C  4800      LDR         R1,=parInp ; parInp
 0000009E  6809      LDR         R1,[R1,#0x0] ; parInp
 000000A0  4001      AND         R1,R0
 000000A2  2900      CMP         R1,#0x0
 000000A4  D11C      BNE         L_408  ; T=0x000000E0
 1775:             if (newTime > (stim[index].startTime+10))
 000000A6  224C      MOV         R2,#0x4C
 000000A8  436A      MUL         R2,R5 ; index
 000000AA  4800      LDR         R1,=stim + 0x28 ; stim+40
 000000AC  5889      LDR         R1,[R1,R2]
 000000AE  310A      ADD         R1,#0xA
 000000B0  428C      CMP         R4,R1 ; newTime
 000000B2  DD15      BLE         L_408  ; T=0x000000E0
 1777:                 ClrBitsPar(sndBit);  
 000000B4  F7FF      BL          ClrBitsPar?T  ; T=0x0001  (1)
 000000B6  FFA4      BL          ClrBitsPar?T  ; T=0x0001  (2)
 1778:                 parOutp &= ~sndBit;
 000000B8  4800      LDR         R0,=sndBit ; sndBit
 000000BA  6800      LDR         R0,[R0,#0x0] ; sndBit
 000000BC  4800      LDR         R1,=parOutp ; parOutp
 000000BE  6809      LDR         R1,[R1,#0x0] ; parOutp
 000000C0  4381      BIC         R1,R0
 000000C2  4800      LDR         R0,=parOutp ; parOutp
 000000C4  6001      STR         R1,[R0,#0x0] ; parOutp
 1779:                 stim[index].stopTime = newTime;
 000000C6  214C      MOV         R1,#0x4C
 000000C8  4369      MUL         R1,R5 ; index
 000000CA  4800      LDR         R0,=stim + 0x30 ; stim+48
 000000CC  5044      STR         R4,[R0,R1] ; newTime
 1780:                 stim[index].status   = statDone;
 000000CE  2005      MOV         R0,#0x5
 000000D0  4800      LDR         R2,=stim + 0x4 ; stim+4
 000000D2  5050      STR         R0,[R2,R1]
 1781:                 execEvent(stim[index].event);
 000000D4  4800      LDR         R0,=stim + 0x3C ; stim+60
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 136 

 000000D6  5840      LDR         R0,[R0,R1]
 000000D8  F7FF      BL          execEvent?T  ; T=0x0001  (1)
 000000DA  FF92      BL          execEvent?T  ; T=0x0001  (2)
 1782:                 return 0;
 000000DC  2000      MOV         R0,#0x0
 000000DE  E002      B           L_405  ; T=0x000000E6
 1784:         }
 000000E0          L_408:
 1785:         return 1;
 000000E0  2001      MOV         R0,#0x1
 000000E2  E000      B           L_405  ; T=0x000000E6
 1786:     }
 000000E4          L_406:
 1787:     return 0;
 000000E4  2000      MOV         R0,#0x0
 000000E6            ; SCOPE-END
 1788: }
 000000E6          L_405:
 000000E6  BCF0      POP         {R4-R7}
 000000E8  BC08      POP         {R3}
 000000EA  4718      BX          R3
 000000EC          ENDP ; 'execSnd?T'


*** CODE SEGMENT '?PR?loadNNMod?T?Fart':
 1790: void loadNNMod() {
 00000000  B530      PUSH        {R4-R5,LR}
 00000002  ---- Variable 'i' assigned to Register 'R5' ----
 00000002  ---- Variable 'n' assigned to Register 'R4' ----
 00000002            ; SCOPE-START
 1793:     pnt = (int) rBuffer[1];
 00000002  4800      LDR         R0,=rBuffer + 0x4 ; rBuffer+4
 00000004  6800      LDR         R0,[R0,#0x0] ; rBuffer+4
 00000006  F7FF      BL          ?C?CASTF?T  ; T=0x0001  (1) ; ?C?CASTF?T
 00000008  FFFB      BL          ?C?CASTF?T  ; T=0x0001  (2) ; ?C?CASTF?T
 0000000A  ---- Variable 'pnt' assigned to Register 'R0' ----
 1794:     switch (pnt)
 0000000A  2802      CMP         R0,#0x2 ; pnt
 0000000C  D100      BEQ         $+4
 0000000E  E0CB      B           L_460  ; T=0x000001A8
 00000012  2803      CMP         R0,#0x3 ; pnt
 00000014  D100      BEQ         $+4
 00000016  E0DD      B           L_465  ; T=0x000001D4
 0000001A  2804      CMP         R0,#0x4 ; pnt
 0000001C  D100      BEQ         $+4
 0000001E  E0EF      B           L_414  ; T=0x00000200
 00000022  280B      CMP         R0,#0xB ; pnt
 00000024  D03C      BEQ         L_430  ; T=0x000000A0
 00000026  280C      CMP         R0,#0xC ; pnt
 00000028  D050      BEQ         L_435  ; T=0x000000CC
 0000002A  280D      CMP         R0,#0xD ; pnt
 0000002C  D064      BEQ         L_440  ; T=0x000000F8
 0000002E  280E      CMP         R0,#0xE ; pnt
 00000030  D078      BEQ         L_445  ; T=0x00000124
 00000032  280F      CMP         R0,#0xF ; pnt
 00000034  D100      BEQ         $+4
 00000036  E08B      B           L_450  ; T=0x00000150
 0000003A  2810      CMP         R0,#0x10 ; pnt
 0000003C  D100      BEQ         $+4
 0000003E  E09D      B           L_455  ; T=0x0000017C
 00000042  2800      CMP         R0,#0x0 ; pnt
 00000044  D000      BNE         $+4
 00000046  E120      B           L_410  ; T=0x0000028A
 1796:         case 0: NetNum = (int) rBuffer[3];
 0000004A          L_411:
 0000004A  4800      LDR         R0,=rBuffer + 0xC ; rBuffer+12
 0000004C  6800      LDR         R0,[R0,#0x0] ; rBuffer+12
 0000004E  F7FF      BL          ?C?CASTF?T  ; T=0x0001  (1) ; ?C?CASTF?T
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 137 

 00000050  FFD7      BL          ?C?CASTF?T  ; T=0x0001  (2) ; ?C?CASTF?T
 00000052  4800      LDR         R1,=NetNum ; NetNum
 00000054  6008      STR         R0,[R1,#0x0] ; NetNum
 1797:                 NNs[NetNum].active  = 0;
 00000056  2000      MOV         R0,#0x0
 00000058  4800      LDR         R1,=NetNum ; NetNum
 0000005A  680A      LDR         R2,[R1,#0x0] ; NetNum
 0000005C  49B9      LDR         R1,=0x2E4
 0000005E  434A      MUL         R2,R1
 00000060  4800      LDR         R1,=NNs ; NNs
 00000062  5088      STR         R0,[R1,R2]
 1798:                 NNs[NetNum].nInput  = (int) rBuffer[4];
 00000064  4800      LDR         R0,=rBuffer + 0x10 ; rBuffer+16
 00000066  6800      LDR         R0,[R0,#0x0] ; rBuffer+16
 00000068  F7FF      BL          ?C?CASTF?T  ; T=0x0001  (1) ; ?C?CASTF?T
 0000006A  FFCA      BL          ?C?CASTF?T  ; T=0x0001  (2) ; ?C?CASTF?T
 0000006C  4800      LDR         R1,=NNs + 0x4 ; NNs+4
 0000006E  5088      STR         R0,[R1,R2]
 1799:                 NNs[NetNum].nHidden = (int) rBuffer[5];
 00000070  4800      LDR         R0,=rBuffer + 0x14 ; rBuffer+20
 00000072  6800      LDR         R0,[R0,#0x0] ; rBuffer+20
 00000074  F7FF      BL          ?C?CASTF?T  ; T=0x0001  (1) ; ?C?CASTF?T
 00000076  FFC4      BL          ?C?CASTF?T  ; T=0x0001  (2) ; ?C?CASTF?T
 00000078  4800      LDR         R1,=NNs + 0xC ; NNs+12
 0000007A  5088      STR         R0,[R1,R2]
 1800:                 for (i=0;i<NNs[NetNum].nInput;i++) NNs[NetNum].channels[i] = (int) rBuffer[6+i];
 0000007C  2500      MOV         R5,#0x0
 0000007E  E006      B           L_423  ; T=0x0000008E
 00000080          L_424:
 00000080  00A9      LSL         R1,R5,#0x2 ; i
 00000082  4800      LDR         R0,=rBuffer + 0x18 ; rBuffer+24
 00000084  5840      LDR         R0,[R0,R1]
 00000086  F7FF      BL          ?C?CASTF?T  ; T=0x0001  (1) ; ?C?CASTF?T
 00000088  FFBB      BL          ?C?CASTF?T  ; T=0x0001  (2) ; ?C?CASTF?T
 0000008A  4800      LDR         R2,=NetNum ; NetNum
 0000008C  6812      LDR         R2,[R2,#0x0] ; NetNum
 0000008E  4BB9      LDR         R3,=0x2E4
 00000090  435A      MUL         R2,R3
 00000092  1852      ADD         R2,R1 ; i
 00000094  4800      LDR         R1,=NNs + 0x10 ; NNs+16
 00000096  5088      STR         R0,[R1,R2]
 00000098  3501      ADD         R5,#0x1
 0000009A          L_423:
 0000009A  4800      LDR         R0,=NetNum ; NetNum
 0000009C  6801      LDR         R1,[R0,#0x0] ; NetNum
 0000009E  48B9      LDR         R0,=0x2E4
 000000A0  4341      MUL         R1,R0
 000000A2  4800      LDR         R0,=NNs + 0x4 ; NNs+4
 000000A4  5840      LDR         R0,[R0,R1]
 000000A6  4285      CMP         R5,R0 ; i
 000000A8  DBEA      BLT         L_424  ; T=0x00000080
 1801:                 break;
 000000AA  E0EE      B           L_410  ; T=0x0000028A
 1802:         case 11:for (i=0;i<NNs[NetNum].nHidden;i++) NNs[NetNum].weightsHidden[0][i] = rBuffer[3+i]; 
 000000AC          L_430:
 000000AC  2500      MOV         R5,#0x0
 000000AE  E004      B           L_428  ; T=0x000000BA
 000000B0          L_429:
 000000B0  00A9      LSL         R1,R5,#0x2 ; i
 000000B2  4800      LDR         R0,=rBuffer + 0xC ; rBuffer+12
 000000B4  5840      LDR         R0,[R0,R1]
 000000B6  4800      LDR         R2,=NetNum ; NetNum
 000000B8  6812      LDR         R2,[R2,#0x0] ; NetNum
 000000BA  4BB9      LDR         R3,=0x2E4
 000000BC  435A      MUL         R2,R3
 000000BE  1852      ADD         R2,R1 ; i
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 138 

 000000C0  4800      LDR         R1,=NNs + 0xB4 ; NNs+180
 000000C2  5088      STR         R0,[R1,R2]
 000000C4  3501      ADD         R5,#0x1
 000000C6          L_428:
 000000C6  4800      LDR         R0,=NetNum ; NetNum
 000000C8  6801      LDR         R1,[R0,#0x0] ; NetNum
 000000CA  48B9      LDR         R0,=0x2E4
 000000CC  4341      MUL         R1,R0
 000000CE  4800      LDR         R0,=NNs + 0xC ; NNs+12
 000000D0  5840      LDR         R0,[R0,R1]
 000000D2  4285      CMP         R5,R0 ; i
 000000D4  DBEC      BLT         L_429  ; T=0x000000B0
 1803:                 break;
 000000D6  E0D8      B           L_410  ; T=0x0000028A
 1804:         case 12:for (i=0;i<NNs[NetNum].nHidden;i++) NNs[NetNum].weightsHidden[1][i] = rBuffer[3+i]; 
 000000D8          L_435:
 000000D8  2500      MOV         R5,#0x0
 000000DA  E004      B           L_433  ; T=0x000000E6
 000000DC          L_434:
 000000DC  00A9      LSL         R1,R5,#0x2 ; i
 000000DE  4800      LDR         R0,=rBuffer + 0xC ; rBuffer+12
 000000E0  5840      LDR         R0,[R0,R1]
 000000E2  4800      LDR         R2,=NetNum ; NetNum
 000000E4  6812      LDR         R2,[R2,#0x0] ; NetNum
 000000E6  4BB9      LDR         R3,=0x2E4
 000000E8  435A      MUL         R2,R3
 000000EA  1852      ADD         R2,R1 ; i
 000000EC  4800      LDR         R1,=NNs + 0x104 ; NNs+260
 000000EE  5088      STR         R0,[R1,R2]
 000000F0  3501      ADD         R5,#0x1
 000000F2          L_433:
 000000F2  4800      LDR         R0,=NetNum ; NetNum
 000000F4  6801      LDR         R1,[R0,#0x0] ; NetNum
 000000F6  48B9      LDR         R0,=0x2E4
 000000F8  4341      MUL         R1,R0
 000000FA  4800      LDR         R0,=NNs + 0xC ; NNs+12
 000000FC  5840      LDR         R0,[R0,R1]
 000000FE  4285      CMP         R5,R0 ; i
 00000100  DBEC      BLT         L_434  ; T=0x000000DC
 1805:                 break;
 00000102  E0C2      B           L_410  ; T=0x0000028A
 1806:         case 13:for (i=0;i<NNs[NetNum].nHidden;i++) NNs[NetNum].weightsHidden[2][i] = rBuffer[3+i]; 
 00000104          L_440:
 00000104  2500      MOV         R5,#0x0
 00000106  E004      B           L_438  ; T=0x00000112
 00000108          L_439:
 00000108  00A9      LSL         R1,R5,#0x2 ; i
 0000010A  4800      LDR         R0,=rBuffer + 0xC ; rBuffer+12
 0000010C  5840      LDR         R0,[R0,R1]
 0000010E  4800      LDR         R2,=NetNum ; NetNum
 00000110  6812      LDR         R2,[R2,#0x0] ; NetNum
 00000112  4BB9      LDR         R3,=0x2E4
 00000114  435A      MUL         R2,R3
 00000116  1852      ADD         R2,R1 ; i
 00000118  4800      LDR         R1,=NNs + 0x154 ; NNs+340
 0000011A  5088      STR         R0,[R1,R2]
 0000011C  3501      ADD         R5,#0x1
 0000011E          L_438:
 0000011E  4800      LDR         R0,=NetNum ; NetNum
 00000120  6801      LDR         R1,[R0,#0x0] ; NetNum
 00000122  48B9      LDR         R0,=0x2E4
 00000124  4341      MUL         R1,R0
 00000126  4800      LDR         R0,=NNs + 0xC ; NNs+12
 00000128  5840      LDR         R0,[R0,R1]
 0000012A  4285      CMP         R5,R0 ; i
 0000012C  DBEC      BLT         L_439  ; T=0x00000108
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 139 

 1807:                 break;
 0000012E  E0AC      B           L_410  ; T=0x0000028A
 1808:         case 14:for (i=0;i<NNs[NetNum].nHidden;i++) NNs[NetNum].weightsHidden[3][i] = rBuffer[3+i]; 
 00000130          L_445:
 00000130  2500      MOV         R5,#0x0
 00000132  E004      B           L_443  ; T=0x0000013E
 00000134          L_444:
 00000134  00A9      LSL         R1,R5,#0x2 ; i
 00000136  4800      LDR         R0,=rBuffer + 0xC ; rBuffer+12
 00000138  5840      LDR         R0,[R0,R1]
 0000013A  4800      LDR         R2,=NetNum ; NetNum
 0000013C  6812      LDR         R2,[R2,#0x0] ; NetNum
 0000013E  4BB9      LDR         R3,=0x2E4
 00000140  435A      MUL         R2,R3
 00000142  1852      ADD         R2,R1 ; i
 00000144  4800      LDR         R1,=NNs + 0x1A4 ; NNs+420
 00000146  5088      STR         R0,[R1,R2]
 00000148  3501      ADD         R5,#0x1
 0000014A          L_443:
 0000014A  4800      LDR         R0,=NetNum ; NetNum
 0000014C  6801      LDR         R1,[R0,#0x0] ; NetNum
 0000014E  48B9      LDR         R0,=0x2E4
 00000150  4341      MUL         R1,R0
 00000152  4800      LDR         R0,=NNs + 0xC ; NNs+12
 00000154  5840      LDR         R0,[R0,R1]
 00000156  4285      CMP         R5,R0 ; i
 00000158  DBEC      BLT         L_444  ; T=0x00000134
 1809:                 break;
 0000015A  E096      B           L_410  ; T=0x0000028A
 1810:         case 15:for (i=0;i<NNs[NetNum].nHidden;i++) NNs[NetNum].weightsHidden[4][i] = rBuffer[3+i]; 
 0000015C          L_450:
 0000015C  2500      MOV         R5,#0x0
 0000015E  E004      B           L_448  ; T=0x0000016A
 00000160          L_449:
 00000160  00A9      LSL         R1,R5,#0x2 ; i
 00000162  4800      LDR         R0,=rBuffer + 0xC ; rBuffer+12
 00000164  5840      LDR         R0,[R0,R1]
 00000166  4800      LDR         R2,=NetNum ; NetNum
 00000168  6812      LDR         R2,[R2,#0x0] ; NetNum
 0000016A  4BB9      LDR         R3,=0x2E4
 0000016C  435A      MUL         R2,R3
 0000016E  1852      ADD         R2,R1 ; i
 00000170  4800      LDR         R1,=NNs + 0x1F4 ; NNs+500
 00000172  5088      STR         R0,[R1,R2]
 00000174  3501      ADD         R5,#0x1
 00000176          L_448:
 00000176  4800      LDR         R0,=NetNum ; NetNum
 00000178  6801      LDR         R1,[R0,#0x0] ; NetNum
 0000017A  48B9      LDR         R0,=0x2E4
 0000017C  4341      MUL         R1,R0
 0000017E  4800      LDR         R0,=NNs + 0xC ; NNs+12
 00000180  5840      LDR         R0,[R0,R1]
 00000182  4285      CMP         R5,R0 ; i
 00000184  DBEC      BLT         L_449  ; T=0x00000160
 1811:                 break;
 00000186  E080      B           L_410  ; T=0x0000028A
 1812:         case 16:for (i=0;i<NNs[NetNum].nHidden;i++) NNs[NetNum].weightsHidden[5][i] = rBuffer[3+i]; 
 00000188          L_455:
 00000188  2500      MOV         R5,#0x0
 0000018A  E004      B           L_453  ; T=0x00000196
 0000018C          L_454:
 0000018C  00A9      LSL         R1,R5,#0x2 ; i
 0000018E  4800      LDR         R0,=rBuffer + 0xC ; rBuffer+12
 00000190  5840      LDR         R0,[R0,R1]
 00000192  4800      LDR         R2,=NetNum ; NetNum
 00000194  6812      LDR         R2,[R2,#0x0] ; NetNum
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 140 

 00000196  4BB9      LDR         R3,=0x2E4
 00000198  435A      MUL         R2,R3
 0000019A  1852      ADD         R2,R1 ; i
 0000019C  4800      LDR         R1,=NNs + 0x244 ; NNs+580
 0000019E  5088      STR         R0,[R1,R2]
 000001A0  3501      ADD         R5,#0x1
 000001A2          L_453:
 000001A2  4800      LDR         R0,=NetNum ; NetNum
 000001A4  6801      LDR         R1,[R0,#0x0] ; NetNum
 000001A6  48B9      LDR         R0,=0x2E4
 000001A8  4341      MUL         R1,R0
 000001AA  4800      LDR         R0,=NNs + 0xC ; NNs+12
 000001AC  5840      LDR         R0,[R0,R1]
 000001AE  4285      CMP         R5,R0 ; i
 000001B0  DBEC      BLT         L_454  ; T=0x0000018C
 1813:                 break;
 000001B2  E06A      B           L_410  ; T=0x0000028A
 1814:         case 2: for (i=0;i<NNs[NetNum].nHidden;i++) NNs[NetNum].weightsOutput[i]    = rBuffer[3+i]; 
 000001B4          L_460:
 000001B4  2500      MOV         R5,#0x0
 000001B6  E004      B           L_458  ; T=0x000001C2
 000001B8          L_459:
 000001B8  00A9      LSL         R1,R5,#0x2 ; i
 000001BA  4800      LDR         R0,=rBuffer + 0xC ; rBuffer+12
 000001BC  5840      LDR         R0,[R0,R1]
 000001BE  4800      LDR         R2,=NetNum ; NetNum
 000001C0  6812      LDR         R2,[R2,#0x0] ; NetNum
 000001C2  4BB9      LDR         R3,=0x2E4
 000001C4  435A      MUL         R2,R3
 000001C6  1852      ADD         R2,R1 ; i
 000001C8  4800      LDR         R1,=NNs + 0x294 ; NNs+660
 000001CA  5088      STR         R0,[R1,R2]
 000001CC  3501      ADD         R5,#0x1
 000001CE          L_458:
 000001CE  4800      LDR         R0,=NetNum ; NetNum
 000001D0  6801      LDR         R1,[R0,#0x0] ; NetNum
 000001D2  48B9      LDR         R0,=0x2E4
 000001D4  4341      MUL         R1,R0
 000001D6  4800      LDR         R0,=NNs + 0xC ; NNs+12
 000001D8  5840      LDR         R0,[R0,R1]
 000001DA  4285      CMP         R5,R0 ; i
 000001DC  DBEC      BLT         L_459  ; T=0x000001B8
 1815:                 break;
 000001DE  E054      B           L_410  ; T=0x0000028A
 1816:         case 3: for (i=0;i<NNs[NetNum].nHidden;i++) NNs[NetNum].biasHidden[i]       = rBuffer[3+i]; 
 000001E0          L_465:
 000001E0  2500      MOV         R5,#0x0
 000001E2  E004      B           L_463  ; T=0x000001EE
 000001E4          L_464:
 000001E4  00A9      LSL         R1,R5,#0x2 ; i
 000001E6  4800      LDR         R0,=rBuffer + 0xC ; rBuffer+12
 000001E8  5840      LDR         R0,[R0,R1]
 000001EA  4800      LDR         R2,=NetNum ; NetNum
 000001EC  6812      LDR         R2,[R2,#0x0] ; NetNum
 000001EE  4BB9      LDR         R3,=0x2E4
 000001F0  435A      MUL         R2,R3
 000001F2  1852      ADD         R2,R1 ; i
 000001F4  4800      LDR         R1,=NNs + 0x60 ; NNs+96
 000001F6  5088      STR         R0,[R1,R2]
 000001F8  3501      ADD         R5,#0x1
 000001FA          L_463:
 000001FA  4800      LDR         R0,=NetNum ; NetNum
 000001FC  6801      LDR         R1,[R0,#0x0] ; NetNum
 000001FE  48B9      LDR         R0,=0x2E4
 00000200  4341      MUL         R1,R0
 00000202  4800      LDR         R0,=NNs + 0xC ; NNs+12
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 141 

 00000204  5840      LDR         R0,[R0,R1]
 00000206  4285      CMP         R5,R0 ; i
 00000208  DBEC      BLT         L_464  ; T=0x000001E4
 1817:                 break;
 0000020A  E03E      B           L_410  ; T=0x0000028A
 1818:         case 4: NNs[NetNum].biasOutput = rBuffer[3];
 0000020C          L_414:
 0000020C  4800      LDR         R0,=rBuffer + 0xC ; rBuffer+12
 0000020E  6800      LDR         R0,[R0,#0x0] ; rBuffer+12
 00000210  4800      LDR         R1,=NetNum ; NetNum
 00000212  680A      LDR         R2,[R1,#0x0] ; NetNum
 00000214  49B9      LDR         R1,=0x2E4
 00000216  434A      MUL         R2,R1
 00000218  4800      LDR         R1,=NNs + 0xB0 ; NNs+176
 0000021A  5088      STR         R0,[R1,R2]
 1819:                 n = 4; 
 0000021C  2404      MOV         R4,#0x4
 1820:                 for (i=0;i<NNs[NetNum].nInput;i++)  NNs[NetNum].scaleInput[i][0]    = rBuffer[n+i];
 0000021E  2500      MOV         R5,#0x0
 00000220  E006      B           L_468  ; T=0x00000230
 00000222          L_469:
 00000222  1961      ADD         R1,R4,R5 ; n
 00000224  0089      LSL         R1,R1,#0x2 ; n
 00000226  4800      LDR         R0,=rBuffer ; rBuffer
 00000228  5840      LDR         R0,[R0,R1]
 0000022A  00E9      LSL         R1,R5,#0x3 ; i
 0000022C  4800      LDR         R2,=NetNum ; NetNum
 0000022E  6812      LDR         R2,[R2,#0x0] ; NetNum
 00000230  4BB9      LDR         R3,=0x2E4
 00000232  435A      MUL         R2,R3
 00000234  1852      ADD         R2,R1 ; i
 00000236  4800      LDR         R1,=NNs + 0x28 ; NNs+40
 00000238  5088      STR         R0,[R1,R2]
 0000023A  3501      ADD         R5,#0x1
 0000023C          L_468:
 0000023C  4800      LDR         R0,=NetNum ; NetNum
 0000023E  6801      LDR         R1,[R0,#0x0] ; NetNum
 00000240  48B9      LDR         R0,=0x2E4
 00000242  4341      MUL         R1,R0
 00000244  4800      LDR         R0,=NNs + 0x4 ; NNs+4
 00000246  5840      LDR         R0,[R0,R1]
 00000248  4285      CMP         R5,R0 ; i
 0000024A  DBEA      BLT         L_469  ; T=0x00000222
 1821:                 n = n + NNs[NetNum].nInput;
 0000024C  1824      ADD         R4,R0 ; n
 1822:                 for (i=0;i<NNs[NetNum].nInput;i++)  NNs[NetNum].scaleInput[i][1]    = rBuffer[n+i];
 0000024E  2500      MOV         R5,#0x0
 00000250  E006      B           L_473  ; T=0x00000260
 00000252          L_474:
 00000252  1961      ADD         R1,R4,R5 ; n
 00000254  0089      LSL         R1,R1,#0x2 ; n
 00000256  4800      LDR         R0,=rBuffer ; rBuffer
 00000258  5840      LDR         R0,[R0,R1]
 0000025A  00E9      LSL         R1,R5,#0x3 ; i
 0000025C  4800      LDR         R2,=NetNum ; NetNum
 0000025E  6812      LDR         R2,[R2,#0x0] ; NetNum
 00000260  4BB9      LDR         R3,=0x2E4
 00000262  435A      MUL         R2,R3
 00000264  1852      ADD         R2,R1 ; i
 00000266  4800      LDR         R1,=NNs + 0x2C ; NNs+44
 00000268  5088      STR         R0,[R1,R2]
 0000026A  3501      ADD         R5,#0x1
 0000026C          L_473:
 0000026C  4800      LDR         R0,=NetNum ; NetNum
 0000026E  6802      LDR         R2,[R0,#0x0] ; NetNum
 00000270  48B9      LDR         R0,=0x2E4
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 142 

 00000272  4342      MUL         R2,R0
 00000274  4800      LDR         R0,=NNs + 0x4 ; NNs+4
 00000276  5880      LDR         R0,[R0,R2]
 00000278  4285      CMP         R5,R0 ; i
 0000027A  DBEA      BLT         L_474  ; T=0x00000252
 1823:                 n = n + NNs[NetNum].nInput;
 0000027C  1824      ADD         R4,R0 ; n
 1824:                 NNs[NetNum].scaleOutput[0] = rBuffer[n];
 0000027E  00A1      LSL         R1,R4,#0x2 ; n
 00000280  4800      LDR         R0,=rBuffer ; rBuffer
 00000282  5840      LDR         R0,[R0,R1]
 00000284  4800      LDR         R3,=NNs + 0x58 ; NNs+88
 00000286  5098      STR         R0,[R3,R2]
 1825:                 NNs[NetNum].scaleOutput[1] = rBuffer[n+1];
 00000288  4800      LDR         R0,=rBuffer + 0x4 ; rBuffer+4
 0000028A  5840      LDR         R0,[R0,R1]
 0000028C  4800      LDR         R1,=NNs + 0x5C ; NNs+92
 0000028E  5088      STR         R0,[R1,R2]
 1826:                 NNs[NetNum].active  = 1;
 00000290  2001      MOV         R0,#0x1
 00000292  4800      LDR         R1,=NNs ; NNs
 00000294  5088      STR         R0,[R1,R2]
 1828:     }
 00000296          L_410:
 1829:     n = sprintf(outBuf,"Loaded net:%d\n",NetNum);
 00000296  4800      LDR         R0,=outBuf ; outBuf
 00000298  4800      LDR         R1,=??S_12 ; ??S_12
 0000029A  4800      LDR         R2,=NetNum ; NetNum
 0000029C  6812      LDR         R2,[R2,#0x0] ; NetNum
 0000029E  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 000002A0  FEAF      BL          sprintf?T  ; T=0x0001  (2)
 000002A2  1C04      MOV         R4,R0 ; n
 1830:     i = UART0_Str(outBuf, n);
 000002A4  4800      LDR         R0,=outBuf ; outBuf
 000002A6  1C21      MOV         R1,R4
 000002A8  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 000002AA  FEAA      BL          UART0_Str?T  ; T=0x0001  (2)
 000002AC  1C05      MOV         R5,R0 ; i
 1831:     nBuffer[1] = 0;
 000002AE  2100      MOV         R1,#0x0
 000002B0  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 000002B2  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 000002B4            ; SCOPE-END
 1832: }    
 000002B4  BC30      POP         {R4-R5}
 000002B6  BC08      POP         {R3}
 000002B8  4718      BX          R3
 000002BA          ENDP ; 'loadNNMod?T'


*** CODE SEGMENT '?PR?tansig?T?Fart':
 1834: double tansig(double d)
 00000000  B500      PUSH        {LR}
 00000002  1C01      MOV         R1,R0 ; d
 00000004  ---- Variable 'd' assigned to Register 'R1' ----
 1835: {
 00000004            ; SCOPE-START
 1836:     double e = 2.71828;
 00000004  4800      LDR         R2,=0x402DF84D
 00000006  ---- Variable 'e' assigned to Register 'R2' ----
 1837:     return (2.0/(1.0+pow(e,-2.0*d))-1.0);
 00000006  4800      LDR         R0,=0xC0000000
 00000008  F7FF      BL          ?C?FPMUL?T  ; T=0x0001  (1) ; ?C?FPMUL?T
 0000000A  FFFA      BL          ?C?FPMUL?T  ; T=0x0001  (2) ; ?C?FPMUL?T
 0000000C  1C01      MOV         R1,R0
 0000000E  1C10      MOV         R0,R2
 00000010  F7FF      BL          pow?T  ; T=0x0001  (1)
 00000012  FFF6      BL          pow?T  ; T=0x0001  (2)
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 143 

 00000014  4800      LDR         R1,=0x3F800000
 00000016  F7FF      BL          ?C?FPADD?T  ; T=0x0001  (1) ; ?C?FPADD?T
 00000018  FFF3      BL          ?C?FPADD?T  ; T=0x0001  (2) ; ?C?FPADD?T
 0000001A  1C01      MOV         R1,R0
 0000001C  4800      LDR         R0,=0x40000000
 0000001E  F7FF      BL          ?C?FPDIV?T  ; T=0x0001  (1) ; ?C?FPDIV?T
 00000020  FFEF      BL          ?C?FPDIV?T  ; T=0x0001  (2) ; ?C?FPDIV?T
 00000022  4800      LDR         R1,=0x3F800000
 00000024  F7FF      BL          ?C?FPSUB?T  ; T=0x0001  (1) ; ?C?FPSUB?T
 00000026  FFEC      BL          ?C?FPSUB?T  ; T=0x0001  (2) ; ?C?FPSUB?T
 00000028            ; SCOPE-END
 1838: }
 00000028  BC08      POP         {R3}
 0000002A  4718      BX          R3
 0000002C          ENDP ; 'tansig?T'


*** CODE SEGMENT '?PR?simulateNN?T?Fart':
 1840: double simulateNN(int mode)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C05      MOV         R5,R0 ; mode
 00000004  ---- Variable 'mode' assigned to Register 'R5' ----
 00000004  B097      SUB         R13,#0x5C
 00000006  ---- Variable 'n' assigned to Register 'R4' ----
 1841: {
 00000006            ; SCOPE-START
 1842:     int i, n, nn, nh, id1=0, id2=0, lp;
 00000006  2600      MOV         R6,#0x0
 00000008  ---- Variable 'id1' assigned to Register 'R6' ----
 00000008  2000      MOV         R0,#0x0
 0000000A  9002      STR         R0,[R13,#0x8] ; id2
 1845:     unsigned int t0=Clock_GetTicks();
 0000000C  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 0000000E  FFF8      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000010  9015      STR         R0,[R13,#0x54] ; t0
 1847:     int id = mode;
 00000012  9516      STR         R5,[R13,#0x58] ; mode
 1848:     if (mode == -1)id = (int) rBuffer[1];
 00000014  2101      MOV         R1,#0x1
 00000016  42CD      CMN         R5,R1 ; mode
 00000018  D104      BNE         L_477  ; T=0x00000024
 0000001A  4800      LDR         R0,=rBuffer + 0x4 ; rBuffer+4
 0000001C  6800      LDR         R0,[R0,#0x0] ; rBuffer+4
 0000001E  F7FF      BL          ?C?CASTF?T  ; T=0x0001  (1) ; ?C?CASTF?T
 00000020  FFEF      BL          ?C?CASTF?T  ; T=0x0001  (2) ; ?C?CASTF?T
 00000022  9016      STR         R0,[R13,#0x58] ; id
 00000024          L_477:
 1849:     if (id <  0) {id1 = 0;  id2 = 3;}
 00000024  9816      LDR         R0,[R13,#0x58] ; id
 00000026  2800      CMP         R0,#0x0
 00000028  DA02      BGE         L_478  ; T=0x00000030
 0000002A  2600      MOV         R6,#0x0
 0000002C  2103      MOV         R1,#0x3
 0000002E  9102      STR         R1,[R13,#0x8] ; id2
 00000030          L_478:
 1850:     if (id > -1) {id1 = id; id2 = id;}
 00000030  2101      MOV         R1,#0x1
 00000032  42C8      CMN         R0,R1
 00000034  DD01      BLE         L_479  ; T=0x0000003A
 00000036  1C06      MOV         R6,R0 ; id1
 00000038  9002      STR         R0,[R13,#0x8] ; id2
 0000003A          L_479:
 1851:     if (id == -1)
 0000003A  2101      MOV         R1,#0x1
 0000003C  42C8      CMN         R0,R1
 0000003E  D103      BNE         L_480  ; T=0x00000048
 1853:         id1 = 0;
 00000040  2600      MOV         R6,#0x0
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 144 

 1854:         id2 = 3;
 00000042  2103      MOV         R1,#0x3
 00000044  9102      STR         R1,[R13,#0x8] ; id2
 1855:     }
 00000046  E001      B           L_481  ; T=0x0000004C
 00000048          L_480:
 1858:         id1 = id;
 00000048  1C06      MOV         R6,R0 ; id1
 1859:         id2 = id;
 0000004A  9002      STR         R0,[R13,#0x8] ; id2
 1860:     }
 0000004C          L_481:
 1862:     val = 0;
 0000004C  2000      MOV         R0,#0x0
 0000004E  900A      STR         R0,[R13,#0x28] ; val
 1863:     for (i=0; i<4; i++) values[i] = 0;
 00000050  2000      MOV         R0,#0x0
 00000052  9000      STR         R0,[R13,#0x0] ; i
 00000054          L_485:
 00000054  2100      MOV         R1,#0x0
 00000056  9800      LDR         R0,[R13,#0x0] ; i
 00000058  0083      LSL         R3,R0,#0x2
 0000005A  AA0B      ADD         R2,R13,#0x2C
 0000005C  50D1      STR         R1,[R2,R3]
 0000005E  3001      ADD         R0,#0x1
 00000060  9000      STR         R0,[R13,#0x0] ; i
 00000062  9800      LDR         R0,[R13,#0x0] ; i
 00000064  2804      CMP         R0,#0x4
 00000066  DBF5      BLT         L_485  ; T=0x00000054
 1864:     for (lp=id1; lp<=id2; lp++)
 00000068  ---- Variable 'lp' assigned to Register 'R6' ----
 00000068  E097      B           L_489  ; T=0x0000019A
 0000006A          L_490:
 1866:         if (NNs[lp].active == 1)
 0000006A  49B9      LDR         R1,=0x2E4
 0000006C  4371      MUL         R1,R6 ; lp
 0000006E  4800      LDR         R0,=NNs ; NNs
 00000070  5840      LDR         R0,[R0,R1]
 00000072  2801      CMP         R0,#0x1
 00000074  D000      BNE         $+4
 00000076  E089      B           L_492  ; T=0x0000018C
 1868:             for (nn=0;nn<NNs[lp].nInput;nn++)
 0000007A  2700      MOV         R7,#0x0
 0000007C  ---- Variable 'nn' assigned to Register 'R7' ----
 0000007C  E020      B           L_495  ; T=0x000000C0
 0000007E          L_496:
 1870:                 inp[nn]  =  AdcBuffer.data[NNs[lp].channels[nn]-1][0];
 0000007E  00BA      LSL         R2,R7,#0x2 ; nn
 00000080  49B9      LDR         R1,=0x2E4
 00000082  4371      MUL         R1,R6 ; lp
 00000084  1889      ADD         R1,R2 ; lp
 00000086  4800      LDR         R0,=NNs + 0x10 ; NNs+16
 00000088  5841      LDR         R1,[R0,R1]
 0000008A  202C      MOV         R0,#0x2C
 0000008C  4341      MUL         R1,R0
 0000008E  4800      LDR         R0,=AdcBuffer + 0xFFFFFFD4 ; AdcBuffer-44
 00000090  5840      LDR         R0,[R0,R1]
 00000092  A90F      ADD         R1,R13,#0x3C
 00000094  5088      STR         R0,[R1,R2]
 1871:                    test[nn] =  NNs[lp].scaleInput[nn][0]*inp[nn]+NNs[lp].scaleInput[nn][1];
 00000096  00FB      LSL         R3,R7,#0x3 ; nn
 00000098  49B9      LDR         R1,=0x2E4
 0000009A  4371      MUL         R1,R6 ; lp
 0000009C  18C9      ADD         R1,R3 ; lp
 0000009E  4800      LDR         R0,=NNs + 0x28 ; NNs+40
 000000A0  5840      LDR         R0,[R0,R1]
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 145 

 000000A2  00BA      LSL         R2,R7,#0x2 ; nn
 000000A4  A90F      ADD         R1,R13,#0x3C
 000000A6  5889      LDR         R1,[R1,R2]
 000000A8  F7FF      BL          ?C?FPMUL?T  ; T=0x0001  (1) ; ?C?FPMUL?T
 000000AA  FFAA      BL          ?C?FPMUL?T  ; T=0x0001  (2) ; ?C?FPMUL?T
 000000AC  4AB9      LDR         R2,=0x2E4
 000000AE  4372      MUL         R2,R6 ; lp
 000000B0  18D2      ADD         R2,R3 ; lp
 000000B2  4800      LDR         R1,=NNs + 0x2C ; NNs+44
 000000B4  5889      LDR         R1,[R1,R2]
 000000B6  F7FF      BL          ?C?FPADD?T  ; T=0x0001  (1) ; ?C?FPADD?T
 000000B8  FFA3      BL          ?C?FPADD?T  ; T=0x0001  (2) ; ?C?FPADD?T
 000000BA  00BA      LSL         R2,R7,#0x2 ; nn
 000000BC  A904      ADD         R1,R13,#0x10
 000000BE  5088      STR         R0,[R1,R2]
 1872:             }
 000000C0  3701      ADD         R7,#0x1
 000000C2          L_495:
 000000C2  49B9      LDR         R1,=0x2E4
 000000C4  4371      MUL         R1,R6 ; lp
 000000C6  4800      LDR         R0,=NNs + 0x4 ; NNs+4
 000000C8  5840      LDR         R0,[R0,R1]
 000000CA  4287      CMP         R7,R0 ; nn
 000000CC  DBD7      BLT         L_496  ; T=0x0000007E
 1874:             val = 0;
 000000CE  2000      MOV         R0,#0x0
 000000D0  900A      STR         R0,[R13,#0x28] ; val
 1875:             for (nh=0;nh<NNs[lp].nHidden;nh++)
 000000D2  2000      MOV         R0,#0x0
 000000D4  9001      STR         R0,[R13,#0x4] ; nh
 000000D6  E03B      B           L_500  ; T=0x00000150
 000000D8          L_501:
 1877:                 temp = 0;
 000000D8  2000      MOV         R0,#0x0
 000000DA  9003      STR         R0,[R13,#0xC] ; temp
 1878:                 for (nn=0;nn<NNs[lp].nInput;nn++)
 000000DC  2700      MOV         R7,#0x0
 000000DE  E013      B           L_505  ; T=0x00000108
 000000E0          L_506:
 1880:                     temp = temp + test[nn]*NNs[lp].weightsHidden[nn][nh];
 000000E0  2050      MOV         R0,#0x50
 000000E2  4378      MUL         R0,R7 ; nn
 000000E4  49B9      LDR         R1,=0x2E4
 000000E6  4371      MUL         R1,R6 ; lp
 000000E8  1809      ADD         R1,R0 ; lp
 000000EA  9801      LDR         R0,[R13,#0x4] ; nh
 000000EC  0080      LSL         R0,R0,#0x2
 000000EE  1809      ADD         R1,R0
 000000F0  4800      LDR         R0,=NNs + 0xB4 ; NNs+180
 000000F2  5841      LDR         R1,[R0,R1]
 000000F4  00BA      LSL         R2,R7,#0x2 ; nn
 000000F6  A804      ADD         R0,R13,#0x10
 000000F8  5880      LDR         R0,[R0,R2]
 000000FA  F7FF      BL          ?C?FPMUL?T  ; T=0x0001  (1) ; ?C?FPMUL?T
 000000FC  FF81      BL          ?C?FPMUL?T  ; T=0x0001  (2) ; ?C?FPMUL?T
 000000FE  1C01      MOV         R1,R0
 00000100  9803      LDR         R0,[R13,#0xC] ; temp
 00000102  F7FF      BL          ?C?FPADD?T  ; T=0x0001  (1) ; ?C?FPADD?T
 00000104  FF7D      BL          ?C?FPADD?T  ; T=0x0001  (2) ; ?C?FPADD?T
 00000106  9003      STR         R0,[R13,#0xC] ; temp
 1881:                 }
 00000108  3701      ADD         R7,#0x1
 0000010A          L_505:
 0000010A  49B9      LDR         R1,=0x2E4
 0000010C  4371      MUL         R1,R6 ; lp
 0000010E  4800      LDR         R0,=NNs + 0x4 ; NNs+4
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 146 

 00000110  5840      LDR         R0,[R0,R1]
 00000112  4287      CMP         R7,R0 ; nn
 00000114  DBE4      BLT         L_506  ; T=0x000000E0
 1882:                 val = val + NNs[lp].weightsOutput[nh]*tansig(temp+NNs[lp].biasHidden[nh]);
 00000116  9801      LDR         R0,[R13,#0x4] ; nh
 00000118  0080      LSL         R0,R0,#0x2
 0000011A  49B9      LDR         R1,=0x2E4
 0000011C  4371      MUL         R1,R6 ; lp
 0000011E  1809      ADD         R1,R0 ; lp
 00000120  4800      LDR         R0,=NNs + 0x60 ; NNs+96
 00000122  5841      LDR         R1,[R0,R1]
 00000124  9803      LDR         R0,[R13,#0xC] ; temp
 00000126  F7FF      BL          ?C?FPADD?T  ; T=0x0001  (1) ; ?C?FPADD?T
 00000128  FF6B      BL          ?C?FPADD?T  ; T=0x0001  (2) ; ?C?FPADD?T
 0000012A  F7FF      BL          tansig?T  ; T=0x0001  (1)
 0000012C  FF69      BL          tansig?T  ; T=0x0001  (2)
 0000012E  1C01      MOV         R1,R0
 00000130  9A01      LDR         R2,[R13,#0x4] ; nh
 00000132  0090      LSL         R0,R2,#0x2
 00000134  4BB9      LDR         R3,=0x2E4
 00000136  4373      MUL         R3,R6 ; lp
 00000138  181B      ADD         R3,R0 ; lp
 0000013A  4800      LDR         R0,=NNs + 0x294 ; NNs+660
 0000013C  58C0      LDR         R0,[R0,R3]
 0000013E  F7FF      BL          ?C?FPMUL?T  ; T=0x0001  (1) ; ?C?FPMUL?T
 00000140  FF5F      BL          ?C?FPMUL?T  ; T=0x0001  (2) ; ?C?FPMUL?T
 00000142  1C01      MOV         R1,R0
 00000144  980A      LDR         R0,[R13,#0x28] ; val
 00000146  F7FF      BL          ?C?FPADD?T  ; T=0x0001  (1) ; ?C?FPADD?T
 00000148  FF5B      BL          ?C?FPADD?T  ; T=0x0001  (2) ; ?C?FPADD?T
 0000014A  900A      STR         R0,[R13,#0x28] ; val
 1883:             }
 0000014C  1C10      MOV         R0,R2
 0000014E  3001      ADD         R0,#0x1
 00000150  9001      STR         R0,[R13,#0x4] ; nh
 00000152          L_500:
 00000152  4AB9      LDR         R2,=0x2E4
 00000154  4372      MUL         R2,R6 ; lp
 00000156  4800      LDR         R0,=NNs + 0xC ; NNs+12
 00000158  5881      LDR         R1,[R0,R2]
 0000015A  9801      LDR         R0,[R13,#0x4] ; nh
 0000015C  4288      CMP         R0,R1
 0000015E  DBBB      BLT         L_501  ; T=0x000000D8
 1884:             val = val + NNs[lp].biasOutput;
 00000160  4800      LDR         R0,=NNs + 0xB0 ; NNs+176
 00000162  5881      LDR         R1,[R0,R2]
 00000164  980A      LDR         R0,[R13,#0x28] ; val
 00000166  F7FF      BL          ?C?FPADD?T  ; T=0x0001  (1) ; ?C?FPADD?T
 00000168  FF4B      BL          ?C?FPADD?T  ; T=0x0001  (2) ; ?C?FPADD?T
 0000016A  900A      STR         R0,[R13,#0x28] ; val
 1885:             val = NNs[lp].scaleOutput[0]*val+NNs[lp].scaleOutput[1];
 0000016C  4800      LDR         R0,=NNs + 0x58 ; NNs+88
 0000016E  5880      LDR         R0,[R0,R2]
 00000170  990A      LDR         R1,[R13,#0x28] ; val
 00000172  F7FF      BL          ?C?FPMUL?T  ; T=0x0001  (1) ; ?C?FPMUL?T
 00000174  FF45      BL          ?C?FPMUL?T  ; T=0x0001  (2) ; ?C?FPMUL?T
 00000176  4AB9      LDR         R2,=0x2E4
 00000178  4372      MUL         R2,R6 ; lp
 0000017A  4800      LDR         R1,=NNs + 0x5C ; NNs+92
 0000017C  5889      LDR         R1,[R1,R2]
 0000017E  F7FF      BL          ?C?FPADD?T  ; T=0x0001  (1) ; ?C?FPADD?T
 00000180  FF3F      BL          ?C?FPADD?T  ; T=0x0001  (2) ; ?C?FPADD?T
 00000182  900A      STR         R0,[R13,#0x28] ; val
 1886:             values[lp] = val;
 00000184  980A      LDR         R0,[R13,#0x28] ; val
 00000186  00B2      LSL         R2,R6,#0x2 ; lp
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 147 

 00000188  A90B      ADD         R1,R13,#0x2C
 0000018A  5088      STR         R0,[R1,R2]
 1887:         }
 0000018C  E004      B           L_487  ; T=0x00000198
 0000018E          L_492:
 1890:             val = 0;
 0000018E  2000      MOV         R0,#0x0
 00000190  900A      STR         R0,[R13,#0x28] ; val
 1891:             values[lp] = val;
 00000192  980A      LDR         R0,[R13,#0x28] ; val
 00000194  00B2      LSL         R2,R6,#0x2 ; lp
 00000196  A90B      ADD         R1,R13,#0x2C
 00000198  5088      STR         R0,[R1,R2]
 1893:     }
 0000019A          L_487:
 0000019A  3601      ADD         R6,#0x1
 0000019C          L_489:
 0000019C  9802      LDR         R0,[R13,#0x8] ; id2
 0000019E  4286      CMP         R6,R0 ; lp
 000001A0  DC00      BLE         $+4
 000001A2  E762      B           L_490  ; T=0x0000006A
 1894:     if (mode > -1)
 000001A6  2101      MOV         R1,#0x1
 000001A8  42CD      CMN         R5,R1 ; mode
 000001AA  DDFF      BLE         L_509  ; T=0x000001AC
 1896:         return val;
 000001AC  980A      LDR         R0,[R13,#0x28] ; val
 000001AE  E04E      B           L_510  ; T=0x0000024E
 1897:     }
 000001B0          L_509:
 1898:     t0= Clock_GetTicks() - t0;
 000001B0  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 000001B2  FF26      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 000001B4  9915      LDR         R1,[R13,#0x54] ; t0
 000001B6  1A40      SUB         R0,R1 ; Clock_GetTicks?T
 000001B8  9015      STR         R0,[R13,#0x54] ; t0
 1899:     n = sprintf(outBuf,"%d ",t0); 
 000001BA  4800      LDR         R0,=outBuf ; outBuf
 000001BC  4800      LDR         R1,=??S_13 ; ??S_13
 000001BE  9A15      LDR         R2,[R13,#0x54] ; t0
 000001C0  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 000001C2  FF1E      BL          sprintf?T  ; T=0x0001  (2)
 000001C4  1C04      MOV         R4,R0 ; n
 1900:     if (id > -1)
 000001C6  9816      LDR         R0,[R13,#0x58] ; id
 000001C8  2101      MOV         R1,#0x1
 000001CA  42C8      CMN         R0,R1
 000001CC  DD1D      BLE         L_522  ; T=0x0000020A
 1902:         for (i=0;i<NNs[id].nInput;i++)
 000001CE  2000      MOV         R0,#0x0
 000001D0  9000      STR         R0,[R13,#0x0] ; i
 000001D2  E00A      B           L_514  ; T=0x000001EA
 000001D4          L_515:
 1904:             n += sprintf(outBuf+n," %f",inp[i]);
 000001D4  9900      LDR         R1,[R13,#0x0] ; i
 000001D6  0089      LSL         R1,R1,#0x2
 000001D8  A80F      ADD         R0,R13,#0x3C
 000001DA  5842      LDR         R2,[R0,R1]
 000001DC  4800      LDR         R0,=outBuf ; outBuf
 000001DE  1900      ADD         R0,R4 ; outBuf
 000001E0  4800      LDR         R1,=??S_14 ; ??S_14
 000001E2  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 000001E4  FF0D      BL          sprintf?T  ; T=0x0001  (2)
 000001E6  1824      ADD         R4,R0 ; n
 1905:         }
 000001E8  9800      LDR         R0,[R13,#0x0] ; i
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 148 

 000001EA  3001      ADD         R0,#0x1
 000001EC  9000      STR         R0,[R13,#0x0] ; i
 000001EE          L_514:
 000001EE  9916      LDR         R1,[R13,#0x58] ; id
 000001F0  48B9      LDR         R0,=0x2E4
 000001F2  4341      MUL         R1,R0
 000001F4  4800      LDR         R0,=NNs + 0x4 ; NNs+4
 000001F6  5841      LDR         R1,[R0,R1]
 000001F8  9800      LDR         R0,[R13,#0x0] ; i
 000001FA  4288      CMP         R0,R1
 000001FC  DBEA      BLT         L_515  ; T=0x000001D4
 1906:         n += sprintf(outBuf+n," %f\n",val);
 000001FE  4800      LDR         R0,=outBuf ; outBuf
 00000200  1900      ADD         R0,R4 ; outBuf
 00000202  4800      LDR         R1,=??S_15 ; ??S_15
 00000204  9A0A      LDR         R2,[R13,#0x28] ; val
 00000206  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000208  FEFB      BL          sprintf?T  ; T=0x0001  (2)
 0000020A  1824      ADD         R4,R0 ; n
 1907:     }
 0000020C  E016      B           L_517  ; T=0x0000023C
 1910:         for (i=0;i<3;i++)
 0000020E          L_522:
 0000020E  2000      MOV         R0,#0x0
 00000210  9000      STR         R0,[R13,#0x0] ; i
 00000212          L_521:
 1912:             n += sprintf(outBuf+n," %f",values[i]);
 00000212  9900      LDR         R1,[R13,#0x0] ; i
 00000214  0089      LSL         R1,R1,#0x2
 00000216  A80B      ADD         R0,R13,#0x2C
 00000218  5842      LDR         R2,[R0,R1]
 0000021A  4800      LDR         R0,=outBuf ; outBuf
 0000021C  1900      ADD         R0,R4 ; outBuf
 0000021E  4800      LDR         R1,=??S_14 ; ??S_14
 00000220  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000222  FEEE      BL          sprintf?T  ; T=0x0001  (2)
 00000224  1824      ADD         R4,R0 ; n
 1913:         }
 00000226  9800      LDR         R0,[R13,#0x0] ; i
 00000228  3001      ADD         R0,#0x1
 0000022A  9000      STR         R0,[R13,#0x0] ; i
 0000022C  9800      LDR         R0,[R13,#0x0] ; i
 0000022E  2803      CMP         R0,#0x3
 00000230  DBEF      BLT         L_521  ; T=0x00000212
 1914:         n += sprintf(outBuf+n," %f\n",values[3]);
 00000232  4800      LDR         R0,=outBuf ; outBuf
 00000234  1900      ADD         R0,R4 ; outBuf
 00000236  4800      LDR         R1,=??S_15 ; ??S_15
 00000238  9A0E      LDR         R2,[R13,#0x38] ; values
 0000023A  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 0000023C  FEE1      BL          sprintf?T  ; T=0x0001  (2)
 0000023E  1824      ADD         R4,R0 ; n
 1915:     }
 00000240          L_517:
 1917:     i = UART0_Str(outBuf, n);
 00000240  4800      LDR         R0,=outBuf ; outBuf
 00000242  1C21      MOV         R1,R4
 00000244  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 00000246  FEDC      BL          UART0_Str?T  ; T=0x0001  (2)
 00000248  9000      STR         R0,[R13,#0x0] ; i
 1918:     nBuffer[1] = 0;
 0000024A  2100      MOV         R1,#0x0
 0000024C  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 0000024E  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 1919:     return 0;
 00000250  2000      MOV         R0,#0x0
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 149 

 00000252            ; SCOPE-END
 1920: }
 00000252          L_510:
 00000252  B017      ADD         R13,#0x5C
 00000254  BCF0      POP         {R4-R7}
 00000256  BC08      POP         {R3}
 00000258  4718      BX          R3
 0000025A          ENDP ; 'simulateNN?T'


*** CODE SEGMENT '?PR?execFixWnd?T?Fart':
 1922: int execFixWnd(int index)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C06      MOV         R6,R0 ; index
 00000004  ---- Variable 'index' assigned to Register 'R6' ----
 1923: {
 00000004            ; SCOPE-START
 1924:     int newTime = Clock_GetTicks() - T_start;
 00000004  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000006  FFFC      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000008  4800      LDR         R1,=T_start ; T_start
 0000000A  6809      LDR         R1,[R1,#0x0] ; T_start
 0000000C  1A45      SUB         R5,R0,R1 ; Clock_GetTicks?T
 0000000E  ---- Variable 'newTime' assigned to Register 'R5' ----
 1925:     int id = stim[index].index;
 0000000E  274C      MOV         R7,#0x4C
 00000010  4377      MUL         R7,R6 ; index
 00000012  4800      LDR         R0,=stim + 0xC ; stim+12
 00000014  59C4      LDR         R4,[R0,R7]
 00000016  ---- Variable 'id' assigned to Register 'R4' ----
 1927:     if (stim[index].status == statInit)
 00000016  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000018  59C0      LDR         R0,[R0,R7]
 0000001A  2801      CMP         R0,#0x1
 0000001C  D11C      BNE         L_523  ; T=0x00000058
 1929:         if ((stim[index].startRef == 0) && (curTime >= stim[index].startTime))
 0000001E  4800      LDR         R0,=stim + 0x24 ; stim+36
 00000020  59C0      LDR         R0,[R0,R7]
 00000022  2800      CMP         R0,#0x0
 00000024  D111      BNE         L_524  ; T=0x0000004A
 00000026  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000028  59C1      LDR         R1,[R0,R7]
 0000002A  4800      LDR         R0,=curTime ; curTime
 0000002C  6800      LDR         R0,[R0,#0x0] ; curTime
 0000002E  4288      CMP         R0,R1
 00000030  D30B      BCC         L_524  ; T=0x0000004A
 1931:             testFixWnd(index);
 00000032  1C30      MOV         R0,R6
 00000034  F7FF      BL          testFixWnd?T  ; T=0x0001  (1)
 00000036  FFE4      BL          testFixWnd?T  ; T=0x0001  (2)
 1932:             stim[index].startTime = newTime;
 00000038  224C      MOV         R2,#0x4C
 0000003A  4372      MUL         R2,R6 ; index
 0000003C  4800      LDR         R0,=stim + 0x28 ; stim+40
 0000003E  5085      STR         R5,[R0,R2] ; newTime
 1933:             stim[index].status    = statRun;
 00000040  200A      MOV         R0,#0xA
 00000042  4800      LDR         R1,=stim + 0x4 ; stim+4
 00000044  5088      STR         R0,[R1,R2]
 1934:             return 1;
 00000046  2001      MOV         R0,#0x1
 00000048  E043      B           L_525  ; T=0x000000D2
 1935:         }
 0000004A          L_524:
 1936:         fixWindows[id].fix = 0;
 0000004A  2000      MOV         R0,#0x0
 0000004C  221C      MOV         R2,#0x1C
 0000004E  4362      MUL         R2,R4 ; id
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 150 

 00000050  4800      LDR         R1,=fixWindows ; fixWindows
 00000052  5088      STR         R0,[R1,R2]
 1937:         return 2;
 00000054  2002      MOV         R0,#0x2
 00000056  E03C      B           L_525  ; T=0x000000D2
 1938:     }
 00000058          L_523:
 1940:     if (stim[index].status == statRun)
 00000058  4800      LDR         R0,=stim + 0x4 ; stim+4
 0000005A  59C0      LDR         R0,[R0,R7]
 0000005C  280A      CMP         R0,#0xA
 0000005E  D137      BNE         L_526  ; T=0x000000D0
 1942:         if ((stim[index].stopRef == 0) && (curTime >= stim[index].stopTime))
 00000060  214C      MOV         R1,#0x4C
 00000062  4371      MUL         R1,R6 ; index
 00000064  4800      LDR         R0,=stim + 0x2C ; stim+44
 00000066  5840      LDR         R0,[R0,R1]
 00000068  2800      CMP         R0,#0x0
 0000006A  D117      BNE         L_527  ; T=0x0000009C
 0000006C  214C      MOV         R1,#0x4C
 0000006E  4371      MUL         R1,R6 ; index
 00000070  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000072  5841      LDR         R1,[R0,R1]
 00000074  4800      LDR         R0,=curTime ; curTime
 00000076  6800      LDR         R0,[R0,#0x0] ; curTime
 00000078  4288      CMP         R0,R1
 0000007A  D30F      BCC         L_527  ; T=0x0000009C
 1944:             stim[index].stopTime = newTime;
 0000007C  214C      MOV         R1,#0x4C
 0000007E  4371      MUL         R1,R6 ; index
 00000080  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000082  5045      STR         R5,[R0,R1] ; newTime
 1945:             stim[index].delay    = fixWindows[id].time;
 00000084  211C      MOV         R1,#0x1C
 00000086  4361      MUL         R1,R4 ; id
 00000088  4800      LDR         R0,=fixWindows + 0x18 ; fixWindows+24
 0000008A  5841      LDR         R1,[R0,R1]
 0000008C  224C      MOV         R2,#0x4C
 0000008E  4372      MUL         R2,R6 ; index
 00000090  4800      LDR         R0,=stim + 0x38 ; stim+56
 00000092  5081      STR         R1,[R0,R2]
 1946:             execError();
 00000094  F7FF      BL          execError?T  ; T=0x0001  (1)
 00000096  FFB4      BL          execError?T  ; T=0x0001  (2)
 1947:             return 0;
 00000098  2000      MOV         R0,#0x0
 0000009A  E01A      B           L_525  ; T=0x000000D2
 1948:         }
 0000009C          L_527:
 1951:             if (testFixWnd(index) == 1)
 0000009C  1C30      MOV         R0,R6
 0000009E  F7FF      BL          testFixWnd?T  ; T=0x0001  (1)
 000000A0  FFAF      BL          testFixWnd?T  ; T=0x0001  (2)
 000000A2  2801      CMP         R0,#0x1 ; testFixWnd?T
 000000A4  D112      BNE         L_529  ; T=0x000000CC
 1953:                 stim[index].stopTime = newTime;
 000000A6  214C      MOV         R1,#0x4C
 000000A8  4371      MUL         R1,R6 ; index
 000000AA  4800      LDR         R0,=stim + 0x30 ; stim+48
 000000AC  5045      STR         R5,[R0,R1] ; newTime
 1954:                 stim[index].status   = statDone;
 000000AE  2005      MOV         R0,#0x5
 000000B0  4800      LDR         R2,=stim + 0x4 ; stim+4
 000000B2  5050      STR         R0,[R2,R1]
 1955:                 stim[index].delay    = fixWindows[id].time;
 000000B4  221C      MOV         R2,#0x1C
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 151 

 000000B6  4362      MUL         R2,R4 ; id
 000000B8  4800      LDR         R0,=fixWindows + 0x18 ; fixWindows+24
 000000BA  5880      LDR         R0,[R0,R2]
 000000BC  4800      LDR         R2,=stim + 0x38 ; stim+56
 000000BE  5050      STR         R0,[R2,R1]
 1956:                 execEvent(stim[index].event);
 000000C0  4800      LDR         R0,=stim + 0x3C ; stim+60
 000000C2  5840      LDR         R0,[R0,R1]
 000000C4  F7FF      BL          execEvent?T  ; T=0x0001  (1)
 000000C6  FF9C      BL          execEvent?T  ; T=0x0001  (2)
 1957:                 return 0;
 000000C8  2000      MOV         R0,#0x0
 000000CA  E002      B           L_525  ; T=0x000000D2
 1958:             }
 000000CC          L_529:
 1959:             return 1;
 000000CC  2001      MOV         R0,#0x1
 000000CE  E000      B           L_525  ; T=0x000000D2
 1961:     }
 000000D0          L_526:
 1962:     return 0;
 000000D0  2000      MOV         R0,#0x0
 000000D2            ; SCOPE-END
 1963: }
 000000D2          L_525:
 000000D2  BCF0      POP         {R4-R7}
 000000D4  BC08      POP         {R3}
 000000D6  4718      BX          R3
 000000D8          ENDP ; 'execFixWnd?T'


*** CODE SEGMENT '?PR?testFixWnd?T?Fart':
 1965: int testFixWnd(int index)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C06      MOV         R6,R0 ; index
 00000004  ---- Variable 'index' assigned to Register 'R6' ----
 00000004  B08A      SUB         R13,#0x28
 00000006  ---- Variable 'time' assigned to Register 'R5' ----
 1966: {
 00000006            ; SCOPE-START
 1970:     double Xm    = (double) stim[index].posX;
 00000006  214C      MOV         R1,#0x4C
 00000008  4371      MUL         R1,R6 ; index
 0000000A  4800      LDR         R0,=stim + 0x18 ; stim+24
 0000000C  5840      LDR         R0,[R0,R1]
 0000000E  F7FF      BL          ?C?FCAST?T  ; T=0x0001  (1) ; ?C?FCAST?T
 00000010  FFF7      BL          ?C?FCAST?T  ; T=0x0001  (2) ; ?C?FCAST?T
 00000012  9001      STR         R0,[R13,#0x4] ; Xm
 1971:     double Ym    = (double) stim[index].posY;
 00000014  4800      LDR         R0,=stim + 0x1C ; stim+28
 00000016  5840      LDR         R0,[R0,R1]
 00000018  F7FF      BL          ?C?FCAST?T  ; T=0x0001  (1) ; ?C?FCAST?T
 0000001A  FFF2      BL          ?C?FCAST?T  ; T=0x0001  (2) ; ?C?FCAST?T
 0000001C  9002      STR         R0,[R13,#0x8] ; Ym
 1972:     double Sx    = (double) stim[index].winX;
 0000001E  4800      LDR         R0,=stim + 0x44 ; stim+68
 00000020  5840      LDR         R0,[R0,R1]
 00000022  F7FF      BL          ?C?FCAST?T  ; T=0x0001  (1) ; ?C?FCAST?T
 00000024  FFED      BL          ?C?FCAST?T  ; T=0x0001  (2) ; ?C?FCAST?T
 00000026  9003      STR         R0,[R13,#0xC] ; Sx
 1973:     double Sy    = (double) stim[index].winY;
 00000028  4800      LDR         R0,=stim + 0x48 ; stim+72
 0000002A  5840      LDR         R0,[R0,R1]
 0000002C  F7FF      BL          ?C?FCAST?T  ; T=0x0001  (1) ; ?C?FCAST?T
 0000002E  FFE8      BL          ?C?FCAST?T  ; T=0x0001  (2) ; ?C?FCAST?T
 00000030  9004      STR         R0,[R13,#0x10] ; Sy
 1974:     int id    = stim[index].index;
 00000032  4800      LDR         R0,=stim + 0xC ; stim+12
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 152 

 00000034  5847      LDR         R7,[R0,R1]
 00000036  ---- Variable 'id' assigned to Register 'R7' ----
 1975:     int fix   = fixWindows[id].fix;
 00000036  211C      MOV         R1,#0x1C
 00000038  4379      MUL         R1,R7 ; id
 0000003A  4800      LDR         R0,=fixWindows ; fixWindows
 0000003C  5840      LDR         R0,[R0,R1]
 0000003E  9005      STR         R0,[R13,#0x14] ; fix
 1976:     int t0    = fixWindows[id].t0;
 00000040  4800      LDR         R0,=fixWindows + 0x4 ; fixWindows+4
 00000042  5840      LDR         R0,[R0,R1]
 00000044  9006      STR         R0,[R13,#0x18] ; t0
 1977:     int nx    = fixWindows[id].Xnet;
 00000046  4800      LDR         R0,=fixWindows + 0x8 ; fixWindows+8
 00000048  5842      LDR         R2,[R0,R1]
 0000004A  ---- Variable 'nx' assigned to Register 'R2' ----
 1978:     int ny    = fixWindows[id].Ynet;
 0000004A  4800      LDR         R0,=fixWindows + 0xC ; fixWindows+12
 0000004C  5844      LDR         R4,[R0,R1]
 0000004E  ---- Variable 'ny' assigned to Register 'R4' ----
 1979:     double Xh = (double) fixWindows[id].Xh/10.0;  // to use integers, the value
 0000004E  4800      LDR         R0,=fixWindows + 0x10 ; fixWindows+16
 00000050  5840      LDR         R0,[R0,R1]
 00000052  4800      LDR         R1,=0x41200000
 00000054  F7FF      BL          ?C?FPDIV?T  ; T=0x0001  (1) ; ?C?FPDIV?T
 00000056  FFD4      BL          ?C?FPDIV?T  ; T=0x0001  (2) ; ?C?FPDIV?T
 00000058  9007      STR         R0,[R13,#0x1C] ; Xh
 1980:     double Yh = (double) fixWindows[id].Yh/10.0;  // was multiplied by 10
 0000005A  211C      MOV         R1,#0x1C
 0000005C  4379      MUL         R1,R7 ; id
 0000005E  4800      LDR         R0,=fixWindows + 0x14 ; fixWindows+20
 00000060  5840      LDR         R0,[R0,R1]
 00000062  4800      LDR         R1,=0x41200000
 00000064  F7FF      BL          ?C?FPDIV?T  ; T=0x0001  (1) ; ?C?FPDIV?T
 00000066  FFCC      BL          ?C?FPDIV?T  ; T=0x0001  (2) ; ?C?FPDIV?T
 00000068  9008      STR         R0,[R13,#0x20] ; Yh
 1981:     double x  = simulateNN(nx);
 0000006A  1C10      MOV         R0,R2
 0000006C  F7FF      BL          simulateNN?T  ; T=0x0001  (1)
 0000006E  FFC8      BL          simulateNN?T  ; T=0x0001  (2)
 00000070  9009      STR         R0,[R13,#0x24] ; x
 1982:     double y  = simulateNN(ny);
 00000072  1C20      MOV         R0,R4
 00000074  F7FF      BL          simulateNN?T  ; T=0x0001  (1)
 00000076  FFC4      BL          simulateNN?T  ; T=0x0001  (2)
 00000078  1C02      MOV         R2,R0 ; y
 0000007A  ---- Variable 'y' assigned to Register 'R2' ----
 1984:     if (fix == 1)
 0000007A  9805      LDR         R0,[R13,#0x14] ; fix
 0000007C  2801      CMP         R0,#0x1
 0000007E  D13E      BNE         L_530  ; T=0x000000FE
 1986:         if ((x > (Xm-Sx-Xh)) && (x < (Xm+Sx+Xh)) &&
 00000080  9903      LDR         R1,[R13,#0xC] ; Sx
 00000082  9B01      LDR         R3,[R13,#0x4] ; Xm
 00000084  1C18      MOV         R0,R3
 00000086  F7FF      BL          ?C?FPSUB?T  ; T=0x0001  (1) ; ?C?FPSUB?T
 00000088  FFBB      BL          ?C?FPSUB?T  ; T=0x0001  (2) ; ?C?FPSUB?T
 0000008A  9907      LDR         R1,[R13,#0x1C] ; Xh
 0000008C  F7FF      BL          ?C?FPSUB?T  ; T=0x0001  (1) ; ?C?FPSUB?T
 0000008E  FFB8      BL          ?C?FPSUB?T  ; T=0x0001  (2) ; ?C?FPSUB?T
 00000090  1C04      MOV         R4,R0
 00000092  9809      LDR         R0,[R13,#0x24] ; x
 00000094  1C21      MOV         R1,R4
 00000096  F7FF      BL          ?C?FPCMP?T  ; T=0x0001  (1) ; ?C?FPCMP?T
 00000098  FFB3      BL          ?C?FPCMP?T  ; T=0x0001  (2) ; ?C?FPCMP?T
 0000009A  D92C      BLS         L_531  ; T=0x000000F6
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 153 

 0000009C  9903      LDR         R1,[R13,#0xC] ; Sx
 0000009E  1C18      MOV         R0,R3
 000000A0  F7FF      BL          ?C?FPADD?T  ; T=0x0001  (1) ; ?C?FPADD?T
 000000A2  FFAE      BL          ?C?FPADD?T  ; T=0x0001  (2) ; ?C?FPADD?T
 000000A4  9907      LDR         R1,[R13,#0x1C] ; Xh
 000000A6  F7FF      BL          ?C?FPADD?T  ; T=0x0001  (1) ; ?C?FPADD?T
 000000A8  FFAB      BL          ?C?FPADD?T  ; T=0x0001  (2) ; ?C?FPADD?T
 000000AA  1C04      MOV         R4,R0
 000000AC  9809      LDR         R0,[R13,#0x24] ; x
 000000AE  1C21      MOV         R1,R4
 000000B0  F7FF      BL          ?C?FPCMP?T  ; T=0x0001  (1) ; ?C?FPCMP?T
 000000B2  FFA6      BL          ?C?FPCMP?T  ; T=0x0001  (2) ; ?C?FPCMP?T
 000000B4  D21F      BCS         L_531  ; T=0x000000F6
 000000B6  9904      LDR         R1,[R13,#0x10] ; Sy
 000000B8  9B02      LDR         R3,[R13,#0x8] ; Ym
 000000BA  1C18      MOV         R0,R3
 000000BC  F7FF      BL          ?C?FPSUB?T  ; T=0x0001  (1) ; ?C?FPSUB?T
 000000BE  FFA0      BL          ?C?FPSUB?T  ; T=0x0001  (2) ; ?C?FPSUB?T
 000000C0  9908      LDR         R1,[R13,#0x20] ; Yh
 000000C2  F7FF      BL          ?C?FPSUB?T  ; T=0x0001  (1) ; ?C?FPSUB?T
 000000C4  FF9D      BL          ?C?FPSUB?T  ; T=0x0001  (2) ; ?C?FPSUB?T
 000000C6  1C04      MOV         R4,R0
 000000C8  1C10      MOV         R0,R2 ; y
 000000CA  1C21      MOV         R1,R4
 000000CC  F7FF      BL          ?C?FPCMP?T  ; T=0x0001  (1) ; ?C?FPCMP?T
 000000CE  FF98      BL          ?C?FPCMP?T  ; T=0x0001  (2) ; ?C?FPCMP?T
 000000D0  D911      BLS         L_531  ; T=0x000000F6
 000000D2  9904      LDR         R1,[R13,#0x10] ; Sy
 000000D4  1C18      MOV         R0,R3
 000000D6  F7FF      BL          ?C?FPADD?T  ; T=0x0001  (1) ; ?C?FPADD?T
 000000D8  FF93      BL          ?C?FPADD?T  ; T=0x0001  (2) ; ?C?FPADD?T
 000000DA  9908      LDR         R1,[R13,#0x20] ; Yh
 000000DC  F7FF      BL          ?C?FPADD?T  ; T=0x0001  (1) ; ?C?FPADD?T
 000000DE  FF90      BL          ?C?FPADD?T  ; T=0x0001  (2) ; ?C?FPADD?T
 000000E0  1C04      MOV         R4,R0
 000000E2  1C10      MOV         R0,R2 ; y
 000000E4  1C21      MOV         R1,R4
 000000E6  F7FF      BL          ?C?FPCMP?T  ; T=0x0001  (1) ; ?C?FPCMP?T
 000000E8  FF8B      BL          ?C?FPCMP?T  ; T=0x0001  (2) ; ?C?FPCMP?T
 000000EA  D204      BCS         L_531  ; T=0x000000F6
 1989:             time = curTime-t0;
 000000EC  9806      LDR         R0,[R13,#0x18] ; t0
 000000EE  4800      LDR         R1,=curTime ; curTime
 000000F0  680D      LDR         R5,[R1,#0x0] ; curTime
 000000F2  1A2D      SUB         R5,R0
 1990:         }
 000000F4  E042      B           L_533  ; T=0x0000017C
 000000F6          L_531:
 1993:             time = 0;
 000000F6  2500      MOV         R5,#0x0
 1994:             fix  = 0;
 000000F8  2000      MOV         R0,#0x0
 000000FA  9005      STR         R0,[R13,#0x14] ; fix
 1996:     }
 000000FC  E03E      B           L_533  ; T=0x0000017C
 000000FE          L_530:
 1999:         time = 0;
 000000FE  2500      MOV         R5,#0x0
 2000:         if ((x > (Xm-Sx+Xh)) && (x < (Xm+Sx-Xh)) &&
 00000100  9903      LDR         R1,[R13,#0xC] ; Sx
 00000102  9B01      LDR         R3,[R13,#0x4] ; Xm
 00000104  1C18      MOV         R0,R3
 00000106  F7FF      BL          ?C?FPSUB?T  ; T=0x0001  (1) ; ?C?FPSUB?T
 00000108  FF7B      BL          ?C?FPSUB?T  ; T=0x0001  (2) ; ?C?FPSUB?T
 0000010A  9907      LDR         R1,[R13,#0x1C] ; Xh
 0000010C  F7FF      BL          ?C?FPADD?T  ; T=0x0001  (1) ; ?C?FPADD?T
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 154 

 0000010E  FF78      BL          ?C?FPADD?T  ; T=0x0001  (2) ; ?C?FPADD?T
 00000110  1C04      MOV         R4,R0
 00000112  9809      LDR         R0,[R13,#0x24] ; x
 00000114  1C21      MOV         R1,R4
 00000116  F7FF      BL          ?C?FPCMP?T  ; T=0x0001  (1) ; ?C?FPCMP?T
 00000118  FF73      BL          ?C?FPCMP?T  ; T=0x0001  (2) ; ?C?FPCMP?T
 0000011A  D92F      BLS         L_533  ; T=0x0000017C
 0000011C  9903      LDR         R1,[R13,#0xC] ; Sx
 0000011E  1C18      MOV         R0,R3
 00000120  F7FF      BL          ?C?FPADD?T  ; T=0x0001  (1) ; ?C?FPADD?T
 00000122  FF6E      BL          ?C?FPADD?T  ; T=0x0001  (2) ; ?C?FPADD?T
 00000124  9907      LDR         R1,[R13,#0x1C] ; Xh
 00000126  F7FF      BL          ?C?FPSUB?T  ; T=0x0001  (1) ; ?C?FPSUB?T
 00000128  FF6B      BL          ?C?FPSUB?T  ; T=0x0001  (2) ; ?C?FPSUB?T
 0000012A  1C04      MOV         R4,R0
 0000012C  9809      LDR         R0,[R13,#0x24] ; x
 0000012E  1C21      MOV         R1,R4
 00000130  F7FF      BL          ?C?FPCMP?T  ; T=0x0001  (1) ; ?C?FPCMP?T
 00000132  FF66      BL          ?C?FPCMP?T  ; T=0x0001  (2) ; ?C?FPCMP?T
 00000134  D222      BCS         L_533  ; T=0x0000017C
 00000136  9904      LDR         R1,[R13,#0x10] ; Sy
 00000138  9B02      LDR         R3,[R13,#0x8] ; Ym
 0000013A  1C18      MOV         R0,R3
 0000013C  F7FF      BL          ?C?FPSUB?T  ; T=0x0001  (1) ; ?C?FPSUB?T
 0000013E  FF60      BL          ?C?FPSUB?T  ; T=0x0001  (2) ; ?C?FPSUB?T
 00000140  9908      LDR         R1,[R13,#0x20] ; Yh
 00000142  F7FF      BL          ?C?FPADD?T  ; T=0x0001  (1) ; ?C?FPADD?T
 00000144  FF5D      BL          ?C?FPADD?T  ; T=0x0001  (2) ; ?C?FPADD?T
 00000146  1C04      MOV         R4,R0
 00000148  1C10      MOV         R0,R2 ; y
 0000014A  1C21      MOV         R1,R4
 0000014C  F7FF      BL          ?C?FPCMP?T  ; T=0x0001  (1) ; ?C?FPCMP?T
 0000014E  FF58      BL          ?C?FPCMP?T  ; T=0x0001  (2) ; ?C?FPCMP?T
 00000150  D914      BLS         L_533  ; T=0x0000017C
 00000152  9904      LDR         R1,[R13,#0x10] ; Sy
 00000154  1C18      MOV         R0,R3
 00000156  F7FF      BL          ?C?FPADD?T  ; T=0x0001  (1) ; ?C?FPADD?T
 00000158  FF53      BL          ?C?FPADD?T  ; T=0x0001  (2) ; ?C?FPADD?T
 0000015A  9908      LDR         R1,[R13,#0x20] ; Yh
 0000015C  F7FF      BL          ?C?FPSUB?T  ; T=0x0001  (1) ; ?C?FPSUB?T
 0000015E  FF50      BL          ?C?FPSUB?T  ; T=0x0001  (2) ; ?C?FPSUB?T
 00000160  1C04      MOV         R4,R0
 00000162  1C10      MOV         R0,R2 ; y
 00000164  1C21      MOV         R1,R4
 00000166  F7FF      BL          ?C?FPCMP?T  ; T=0x0001  (1) ; ?C?FPCMP?T
 00000168  FF4B      BL          ?C?FPCMP?T  ; T=0x0001  (2) ; ?C?FPCMP?T
 0000016A  D207      BCS         L_533  ; T=0x0000017C
 2003:                 fixWindows[id].t0 = curTime;
 0000016C  4800      LDR         R0,=curTime ; curTime
 0000016E  6800      LDR         R0,[R0,#0x0] ; curTime
 00000170  221C      MOV         R2,#0x1C
 00000172  437A      MUL         R2,R7 ; id
 00000174  4800      LDR         R1,=fixWindows + 0x4 ; fixWindows+4
 00000176  5088      STR         R0,[R1,R2]
 2004:                 fix  = 1;
 00000178  2001      MOV         R0,#0x1
 0000017A  9005      STR         R0,[R13,#0x14] ; fix
 2006:     }
 0000017C          L_533:
 2008:     if (time > fixWindows[id].time)
 0000017C  221C      MOV         R2,#0x1C
 0000017E  437A      MUL         R2,R7 ; id
 00000180  4800      LDR         R0,=fixWindows + 0x18 ; fixWindows+24
 00000182  5880      LDR         R0,[R0,R2]
 00000184  4285      CMP         R5,R0 ; time
 00000186  DD01      BLE         L_535  ; T=0x0000018C
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 155 

 2009:         fixWindows[id].time = time;
 00000188  4800      LDR         R0,=fixWindows + 0x18 ; fixWindows+24
 0000018A  5085      STR         R5,[R0,R2] ; time
 0000018C          L_535:
 2010:     fixWindows[id].fix  = fix;
 0000018C  9805      LDR         R0,[R13,#0x14] ; fix
 0000018E  4800      LDR         R1,=fixWindows ; fixWindows
 00000190  5088      STR         R0,[R1,R2]
 2012:     if (time > stim[index].delay) n = 1; else n = 0;
 00000192  214C      MOV         R1,#0x4C
 00000194  4371      MUL         R1,R6 ; index
 00000196  4800      LDR         R0,=stim + 0x38 ; stim+56
 00000198  5840      LDR         R0,[R0,R1]
 0000019A  4285      CMP         R5,R0 ; time
 0000019C  DD02      BLE         L_536  ; T=0x000001A4
 0000019E  2001      MOV         R0,#0x1
 000001A0  9000      STR         R0,[R13,#0x0] ; n
 000001A2  E001      B           L_537  ; T=0x000001A8
 000001A4          L_536:
 000001A4  2000      MOV         R0,#0x0
 000001A6  9000      STR         R0,[R13,#0x0] ; n
 000001A8          L_537:
 2013:     return n;
 000001A8  9800      LDR         R0,[R13,#0x0] ; n
 000001AA            ; SCOPE-END
 2014: }
 000001AA  B00A      ADD         R13,#0x28
 000001AC  BCF0      POP         {R4-R7}
 000001AE  BC08      POP         {R3}
 000001B0  4718      BX          R3
 000001B2          ENDP ; 'testFixWnd?T'


*** CODE SEGMENT '?PR?execSpeed?T?Fart':
 2029: int execSpeed(int index)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  1C06      MOV         R6,R0 ; index
 00000004  ---- Variable 'index' assigned to Register 'R6' ----
 2030: {
 00000004            ; SCOPE-START
 2032:     int newTime = Clock_GetTicks() - T_start;
 00000004  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 00000006  FFFC      BL          Clock_GetTicks?T  ; T=0x0001  (2)
 00000008  4800      LDR         R1,=T_start ; T_start
 0000000A  6809      LDR         R1,[R1,#0x0] ; T_start
 0000000C  1A45      SUB         R5,R0,R1 ; Clock_GetTicks?T
 0000000E  ---- Variable 'newTime' assigned to Register 'R5' ----
 2035:     if (stim[index].status == statInit)
 0000000E  244C      MOV         R4,#0x4C
 00000010  4374      MUL         R4,R6 ; index
 00000012  4800      LDR         R0,=stim + 0x4 ; stim+4
 00000014  5901      LDR         R1,[R0,R4]
 00000016  2901      CMP         R1,#0x1
 00000018  D11B      BNE         L_539  ; T=0x00000052
 2037:         if ((stim[index].startRef == 0) && (curTime >= stim[index].startTime))
 0000001A  4800      LDR         R0,=stim + 0x24 ; stim+36
 0000001C  5900      LDR         R0,[R0,R4]
 0000001E  2800      CMP         R0,#0x0
 00000020  D115      BNE         L_540  ; T=0x0000004E
 00000022  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000024  5902      LDR         R2,[R0,R4]
 00000026  4800      LDR         R0,=curTime ; curTime
 00000028  6800      LDR         R0,[R0,#0x0] ; curTime
 0000002A  4290      CMP         R0,R2
 0000002C  D30F      BCC         L_540  ; T=0x0000004E
 2039:             stim[index].startTime = newTime;
 0000002E  4800      LDR         R0,=stim + 0x28 ; stim+40
 00000030  5105      STR         R5,[R0,R4] ; newTime
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 156 

 2040:             stim[index].status    = statRun;
 00000032  200A      MOV         R0,#0xA
 00000034  4800      LDR         R2,=stim + 0x4 ; stim+4
 00000036  5110      STR         R0,[R2,R4]
 2041:             pntNN = 0;
 00000038  2200      MOV         R2,#0x0
 0000003A  4800      LDR         R0,=pntNN ; pntNN
 0000003C  6002      STR         R2,[R0,#0x0] ; pntNN
 2042:             speed[0] = 0;
 0000003E  2200      MOV         R2,#0x0
 00000040  4800      LDR         R0,=speed ; speed
 00000042  6002      STR         R2,[R0,#0x0] ; speed
 2043:             speed[1] = 0;
 00000044  2200      MOV         R2,#0x0
 00000046  4800      LDR         R0,=speed + 0x4 ; speed+4
 00000048  6002      STR         R2,[R0,#0x0] ; speed+4
 2044:             return 1;
 0000004A  2001      MOV         R0,#0x1
 0000004C  E0DC      B           L_541  ; T=0x00000208
 2045:         }
 0000004E          L_540:
 2046:         return 2;
 0000004E  2002      MOV         R0,#0x2
 00000050  E0DA      B           L_541  ; T=0x00000208
 2047:     }
 00000052          L_539:
 2049:     if (stim[index].status == statRun)
 00000052  290A      CMP         R1,#0xA
 00000054  D000      BNE         $+4
 00000056  E0D6      B           L_542  ; T=0x00000206
 2051:         if ((stim[index].stopRef == 0) && (curTime >= stim[index].stopTime))
 0000005A  4800      LDR         R0,=stim + 0x2C ; stim+44
 0000005C  5900      LDR         R0,[R0,R4]
 0000005E  2800      CMP         R0,#0x0
 00000060  D10A      BNE         L_543  ; T=0x00000078
 00000062  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000064  5901      LDR         R1,[R0,R4]
 00000066  4800      LDR         R0,=curTime ; curTime
 00000068  6800      LDR         R0,[R0,#0x0] ; curTime
 0000006A  4288      CMP         R0,R1
 0000006C  D304      BCC         L_543  ; T=0x00000078
 2053:             stim[index].stopTime = newTime;
 0000006E  4800      LDR         R0,=stim + 0x30 ; stim+48
 00000070  5105      STR         R5,[R0,R4] ; newTime
 2054:             execError();
 00000072  F7FF      BL          execError?T  ; T=0x0001  (1)
 00000074  FFC5      BL          execError?T  ; T=0x0001  (2)
 2055:             return 0;
 00000076  2000      MOV         R0,#0x0
 00000078  E0C6      B           L_541  ; T=0x00000208
 2056:         }
 0000007A          L_543:
 2057:         nx = stim[index].mode & 3;
 0000007A  4800      LDR         R0,=stim + 0x40 ; stim+64
 0000007C  5907      LDR         R7,[R0,R4]
 0000007E  2403      MOV         R4,#0x3
 00000080  403C      AND         R4,R7
 00000082  ---- Variable 'nx' assigned to Register 'R4' ----
 2058:         ny = ((stim[index].mode & 12) >> 2);
 00000082  200C      MOV         R0,#0xC
 00000084  4007      AND         R7,R0
 00000086  10BF      ASR         R7,R7,#0x2
 00000088  ---- Variable 'ny' assigned to Register 'R7' ----
 2059:         X[pntNN] = Clock_GetTicks() - T_start;
 00000088  F7FF      BL          Clock_GetTicks?T  ; T=0x0001  (1)
 0000008A  FFBA      BL          Clock_GetTicks?T  ; T=0x0001  (2)
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 157 

 0000008C  4800      LDR         R1,=T_start ; T_start
 0000008E  6809      LDR         R1,[R1,#0x0] ; T_start
 00000090  1A40      SUB         R0,R1 ; Clock_GetTicks?T
 00000092  F7FF      BL          ?C?FCASTU?T  ; T=0x0001  (1) ; ?C?FCASTU?T
 00000094  FFB5      BL          ?C?FCASTU?T  ; T=0x0001  (2) ; ?C?FCASTU?T
 00000096  4800      LDR         R1,=pntNN ; pntNN
 00000098  680A      LDR         R2,[R1,#0x0] ; pntNN
 0000009A  0092      LSL         R2,R2,#0x2
 0000009C  4800      LDR         R1,=X ; X
 0000009E  5088      STR         R0,[R1,R2]
 2060:         NNx = simulateNN(nx)-stim[index].posX;
 000000A0  1C20      MOV         R0,R4
 000000A2  F7FF      BL          simulateNN?T  ; T=0x0001  (1)
 000000A4  FFAD      BL          simulateNN?T  ; T=0x0001  (2)
 000000A6  1C02      MOV         R2,R0
 000000A8  214C      MOV         R1,#0x4C
 000000AA  4371      MUL         R1,R6 ; index
 000000AC  4800      LDR         R0,=stim + 0x18 ; stim+24
 000000AE  5840      LDR         R0,[R0,R1]
 000000B0  F7FF      BL          ?C?FCAST?T  ; T=0x0001  (1) ; ?C?FCAST?T
 000000B2  FFA6      BL          ?C?FCAST?T  ; T=0x0001  (2) ; ?C?FCAST?T
 000000B4  1C01      MOV         R1,R0
 000000B6  1C10      MOV         R0,R2 ; simulateNN?T
 000000B8  F7FF      BL          ?C?FPSUB?T  ; T=0x0001  (1) ; ?C?FPSUB?T
 000000BA  FFA2      BL          ?C?FPSUB?T  ; T=0x0001  (2) ; ?C?FPSUB?T
 000000BC  1C04      MOV         R4,R0 ; NNx
 000000BE  ---- Variable 'NNx' assigned to Register 'R4' ----
 2061:         NNy = simulateNN(ny)-stim[index].posY;
 000000BE  1C38      MOV         R0,R7
 000000C0  F7FF      BL          simulateNN?T  ; T=0x0001  (1)
 000000C2  FF9E      BL          simulateNN?T  ; T=0x0001  (2)
 000000C4  1C02      MOV         R2,R0
 000000C6  214C      MOV         R1,#0x4C
 000000C8  4371      MUL         R1,R6 ; index
 000000CA  4800      LDR         R0,=stim + 0x1C ; stim+28
 000000CC  5840      LDR         R0,[R0,R1]
 000000CE  F7FF      BL          ?C?FCAST?T  ; T=0x0001  (1) ; ?C?FCAST?T
 000000D0  FF97      BL          ?C?FCAST?T  ; T=0x0001  (2) ; ?C?FCAST?T
 000000D2  1C01      MOV         R1,R0
 000000D4  1C10      MOV         R0,R2 ; simulateNN?T
 000000D6  F7FF      BL          ?C?FPSUB?T  ; T=0x0001  (1) ; ?C?FPSUB?T
 000000D8  FF93      BL          ?C?FPSUB?T  ; T=0x0001  (2) ; ?C?FPSUB?T
 000000DA  ---- Variable 'NNy' assigned to Register 'R0' ----
 2062:         NNy = 0;
 000000DA  2000      MOV         R0,#0x0
 2063:         Y[pntNN] = NNx*NNx+NNy*NNy;
 000000DC  1C01      MOV         R1,R0 ; NNy
 000000DE  F7FF      BL          ?C?FPMUL?T  ; T=0x0001  (1) ; ?C?FPMUL?T
 000000E0  FF8F      BL          ?C?FPMUL?T  ; T=0x0001  (2) ; ?C?FPMUL?T
 000000E2  1C02      MOV         R2,R0
 000000E4  1C20      MOV         R0,R4 ; NNx
 000000E6  1C21      MOV         R1,R4 ; NNx
 000000E8  F7FF      BL          ?C?FPMUL?T  ; T=0x0001  (1) ; ?C?FPMUL?T
 000000EA  FF8A      BL          ?C?FPMUL?T  ; T=0x0001  (2) ; ?C?FPMUL?T
 000000EC  1C11      MOV         R1,R2 ; NNy
 000000EE  F7FF      BL          ?C?FPADD?T  ; T=0x0001  (1) ; ?C?FPADD?T
 000000F0  FF87      BL          ?C?FPADD?T  ; T=0x0001  (2) ; ?C?FPADD?T
 000000F2  4800      LDR         R1,=pntNN ; pntNN
 000000F4  680B      LDR         R3,[R1,#0x0] ; pntNN
 000000F6  009B      LSL         R3,R3,#0x2
 000000F8  4800      LDR         R1,=Y ; Y
 000000FA  50C8      STR         R0,[R1,R3]
 2064:         if (Y[pntNN] > 0) Y[pntNN] = sqrt(Y[pntNN]);
 000000FC  2400      MOV         R4,#0x0
 000000FE  4800      LDR         R0,=Y ; Y
 00000100  58C2      LDR         R2,[R0,R3]
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 158 

 00000102  1C10      MOV         R0,R2
 00000104  1C21      MOV         R1,R4
 00000106  F7FF      BL          ?C?FPCMP?T  ; T=0x0001  (1) ; ?C?FPCMP?T
 00000108  FF7B      BL          ?C?FPCMP?T  ; T=0x0001  (2) ; ?C?FPCMP?T
 0000010A  D906      BLS         L_544  ; T=0x0000011A
 0000010C  1C10      MOV         R0,R2
 0000010E  F7FF      BL          sqrt?T  ; T=0x0001  (1)
 00000110  FF77      BL          sqrt?T  ; T=0x0001  (2)
 00000112  4800      LDR         R1,=pntNN ; pntNN
 00000114  680A      LDR         R2,[R1,#0x0] ; pntNN
 00000116  0092      LSL         R2,R2,#0x2
 00000118  4800      LDR         R1,=Y ; Y
 0000011A  5088      STR         R0,[R1,R2]
 0000011C          L_544:
 2065:         pntNN++;
 0000011C  4800      LDR         R0,=pntNN ; pntNN
 0000011E  6801      LDR         R1,[R0,#0x0] ; pntNN
 00000120  3101      ADD         R1,#0x1
 00000122  6001      STR         R1,[R0,#0x0] ; pntNN
 2066:         if (pntNN == 5)
 00000124  4800      LDR         R0,=pntNN ; pntNN
 00000126  6800      LDR         R0,[R0,#0x0] ; pntNN
 00000128  2805      CMP         R0,#0x5
 0000012A  D147      BNE         L_545  ; T=0x000001BC
 2068:             calculateSpeed();
 0000012C  F7FF      BL          calculateSpeed?T  ; T=0x0001  (1)
 0000012E  FF68      BL          calculateSpeed?T  ; T=0x0001  (2)
 2069:             pntNN = 4;
 00000130  2104      MOV         R1,#0x4
 00000132  4800      LDR         R0,=pntNN ; pntNN
 00000134  6001      STR         R1,[R0,#0x0] ; pntNN
 2070:             range[0] = X[0]-X[0];
 00000136  2100      MOV         R1,#0x0
 00000138  4800      LDR         R0,=range ; range
 0000013A  6001      STR         R1,[R0,#0x0] ; range
 2071:             range[1] = X[1]-X[0];
 0000013C  4800      LDR         R0,=X ; X
 0000013E  6802      LDR         R2,[R0,#0x0] ; X
 00000140  4800      LDR         R0,=X + 0x4 ; X+4
 00000142  6800      LDR         R0,[R0,#0x0] ; X+4
 00000144  1C11      MOV         R1,R2
 00000146  F7FF      BL          ?C?FPSUB?T  ; T=0x0001  (1) ; ?C?FPSUB?T
 00000148  FF5B      BL          ?C?FPSUB?T  ; T=0x0001  (2) ; ?C?FPSUB?T
 0000014A  4800      LDR         R1,=range + 0x4 ; range+4
 0000014C  6008      STR         R0,[R1,#0x0] ; range+4
 2072:             range[2] = X[2]-X[0];
 0000014E  4800      LDR         R0,=X + 0x8 ; X+8
 00000150  6800      LDR         R0,[R0,#0x0] ; X+8
 00000152  1C11      MOV         R1,R2
 00000154  F7FF      BL          ?C?FPSUB?T  ; T=0x0001  (1) ; ?C?FPSUB?T
 00000156  FF54      BL          ?C?FPSUB?T  ; T=0x0001  (2) ; ?C?FPSUB?T
 00000158  4800      LDR         R1,=range + 0x8 ; range+8
 0000015A  6008      STR         R0,[R1,#0x0] ; range+8
 2073:             range[3] = X[3]-X[0];
 0000015C  4800      LDR         R0,=X + 0xC ; X+12
 0000015E  6800      LDR         R0,[R0,#0x0] ; X+12
 00000160  1C11      MOV         R1,R2
 00000162  F7FF      BL          ?C?FPSUB?T  ; T=0x0001  (1) ; ?C?FPSUB?T
 00000164  FF4D      BL          ?C?FPSUB?T  ; T=0x0001  (2) ; ?C?FPSUB?T
 00000166  4800      LDR         R1,=range + 0xC ; range+12
 00000168  6008      STR         R0,[R1,#0x0] ; range+12
 2074:             range[4] = X[4]-X[0];
 0000016A  4800      LDR         R0,=X + 0x10 ; X+16
 0000016C  6800      LDR         R0,[R0,#0x0] ; X+16
 0000016E  1C11      MOV         R1,R2
 00000170  F7FF      BL          ?C?FPSUB?T  ; T=0x0001  (1) ; ?C?FPSUB?T
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 159 

 00000172  FF46      BL          ?C?FPSUB?T  ; T=0x0001  (2) ; ?C?FPSUB?T
 00000174  4800      LDR         R1,=range + 0x10 ; range+16
 00000176  6008      STR         R0,[R1,#0x0] ; range+16
 2075:             range[5] = Y[0];
 00000178  4800      LDR         R1,=Y ; Y
 0000017A  680A      LDR         R2,[R1,#0x0] ; Y
 0000017C  4800      LDR         R1,=range + 0x14 ; range+20
 0000017E  600A      STR         R2,[R1,#0x0] ; range+20
 2076:             range[6] = Y[1];
 00000180  4800      LDR         R1,=Y + 0x4 ; Y+4
 00000182  680A      LDR         R2,[R1,#0x0] ; Y+4
 00000184  4800      LDR         R1,=range + 0x18 ; range+24
 00000186  600A      STR         R2,[R1,#0x0] ; range+24
 2077:             range[7] = Y[2];
 00000188  4800      LDR         R1,=Y + 0x8 ; Y+8
 0000018A  680A      LDR         R2,[R1,#0x0] ; Y+8
 0000018C  4800      LDR         R1,=range + 0x1C ; range+28
 0000018E  600A      STR         R2,[R1,#0x0] ; range+28
 2078:             range[8] = Y[3];
 00000190  4800      LDR         R1,=Y + 0xC ; Y+12
 00000192  680A      LDR         R2,[R1,#0x0] ; Y+12
 00000194  4800      LDR         R1,=range + 0x20 ; range+32
 00000196  600A      STR         R2,[R1,#0x0] ; range+32
 2079:             range[9] = Y[4];
 00000198  4800      LDR         R1,=Y + 0x10 ; Y+16
 0000019A  680A      LDR         R2,[R1,#0x0] ; Y+16
 0000019C  4800      LDR         R1,=range + 0x24 ; range+36
 0000019E  600A      STR         R2,[R1,#0x0] ; range+36
 2080:             range[10] = X[4]-X[0];
 000001A0  4800      LDR         R1,=range + 0x28 ; range+40
 000001A2  6008      STR         R0,[R1,#0x0] ; range+40
 2081:             for (i=1; i<5; i++)
 000001A4  2001      MOV         R0,#0x1
 000001A6  ---- Variable 'i' assigned to Register 'R0' ----
 000001A6          L_549:
 2083:                 X[i-1] = X[i];
 000001A6  0083      LSL         R3,R0,#0x2 ; i
 000001A8  4800      LDR         R1,=X ; X
 000001AA  58C9      LDR         R1,[R1,R3]
 000001AC  4800      LDR         R2,=X + 0xFFFFFFFC ; X-4
 000001AE  50D1      STR         R1,[R2,R3]
 2084:                 Y[i-1] = Y[i];
 000001B0  4800      LDR         R1,=Y ; Y
 000001B2  58C9      LDR         R1,[R1,R3]
 000001B4  4800      LDR         R2,=Y + 0xFFFFFFFC ; Y-4
 000001B6  50D1      STR         R1,[R2,R3]
 2085:             }
 000001B8  3001      ADD         R0,#0x1
 000001BA  2805      CMP         R0,#0x5 ; i
 000001BC  DBF3      BLT         L_549  ; T=0x000001A6
 2086:         }
 000001BE          L_545:
 2087:         d1 = 1000.0*speed[0]/range[10];
 000001BE  4800      LDR         R0,=speed ; speed
 000001C0  6801      LDR         R1,[R0,#0x0] ; speed
 000001C2  4800      LDR         R0,=0x447A0000
 000001C4  F7FF      BL          ?C?FPMUL?T  ; T=0x0001  (1) ; ?C?FPMUL?T
 000001C6  FF1C      BL          ?C?FPMUL?T  ; T=0x0001  (2) ; ?C?FPMUL?T
 000001C8  4800      LDR         R1,=range + 0x28 ; range+40
 000001CA  6809      LDR         R1,[R1,#0x0] ; range+40
 000001CC  F7FF      BL          ?C?FPDIV?T  ; T=0x0001  (1) ; ?C?FPDIV?T
 000001CE  FF18      BL          ?C?FPDIV?T  ; T=0x0001  (2) ; ?C?FPDIV?T
 000001D0  1C01      MOV         R1,R0 ; d1
 000001D2  ---- Variable 'd1' assigned to Register 'R1' ----
 2088:         range[10] = d1;
 000001D2  4800      LDR         R0,=range + 0x28 ; range+40
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 160 

 000001D4  6001      STR         R1,[R0,#0x0] ; d1
 2089:         d2 = stim[index].level;
 000001D6  224C      MOV         R2,#0x4C
 000001D8  4372      MUL         R2,R6 ; index
 000001DA  4800      LDR         R0,=stim + 0x20 ; stim+32
 000001DC  5880      LDR         R0,[R0,R2]
 000001DE  F7FF      BL          ?C?FCAST?T  ; T=0x0001  (1) ; ?C?FCAST?T
 000001E0  FF0F      BL          ?C?FCAST?T  ; T=0x0001  (2) ; ?C?FCAST?T
 000001E2  1C04      MOV         R4,R0 ; d2
 000001E4  ---- Variable 'd2' assigned to Register 'R4' ----
 2090:         if (d1 < d2)
 000001E4  1C08      MOV         R0,R1 ; d1
 000001E6  1C21      MOV         R1,R4 ; d2
 000001E8  F7FF      BL          ?C?FPCMP?T  ; T=0x0001  (1) ; ?C?FPCMP?T
 000001EA  FF0A      BL          ?C?FPCMP?T  ; T=0x0001  (2) ; ?C?FPCMP?T
 000001EC  D209      BCS         L_551  ; T=0x00000202
 2092:             stim[index].stopTime = newTime;
 000001EE  4800      LDR         R0,=stim + 0x30 ; stim+48
 000001F0  5085      STR         R5,[R0,R2] ; newTime
 2093:             stim[index].status   = statDone;
 000001F2  2005      MOV         R0,#0x5
 000001F4  4800      LDR         R1,=stim + 0x4 ; stim+4
 000001F6  5088      STR         R0,[R1,R2]
 2094:             execEvent(stim[index].event);
 000001F8  4800      LDR         R0,=stim + 0x3C ; stim+60
 000001FA  5880      LDR         R0,[R0,R2]
 000001FC  F7FF      BL          execEvent?T  ; T=0x0001  (1)
 000001FE  FF00      BL          execEvent?T  ; T=0x0001  (2)
 2095:             return 0;
 00000200  2000      MOV         R0,#0x0
 00000202  E001      B           L_541  ; T=0x00000208
 2096:         }
 00000204          L_551:
 2097:         return 1;
 00000204  2001      MOV         R0,#0x1
 00000206  E7FF      B           L_541  ; T=0x00000208
 2098:     }
 00000208          L_542:
 2100:     return 0;
 00000208  2000      MOV         R0,#0x0
 0000020A            ; SCOPE-END
 2101: }
 0000020A          L_541:
 0000020A  BCF0      POP         {R4-R7}
 0000020C  BC08      POP         {R3}
 0000020E  4718      BX          R3
 00000210          ENDP ; 'execSpeed?T'


*** CODE SEGMENT '?PR?calculateSpeed?T?Fart':
 2103: void calculateSpeed(void)
 00000000  B5F0      PUSH        {R4-R7,LR}
 00000002  B087      SUB         R13,#0x1C
 2104: {
 00000004            ; SCOPE-START
 2109:     sumX = 0; sumY = 0; sumXY = 0; sumXX = 0;
 00000004  2300      MOV         R3,#0x0
 00000006  ---- Variable 'sumX' assigned to Register 'R3' ----
 00000006  2500      MOV         R5,#0x0
 00000008  ---- Variable 'sumY' assigned to Register 'R5' ----
 00000008  2400      MOV         R4,#0x0
 0000000A  ---- Variable 'sumXY' assigned to Register 'R4' ----
 0000000A  2600      MOV         R6,#0x0
 0000000C  ---- Variable 'sumXX' assigned to Register 'R6' ----
 2110:     for (n=0;n<5;n++) 
 0000000C  2200      MOV         R2,#0x0
 0000000E  ---- Variable 'n' assigned to Register 'R2' ----
 0000000E          L_555:
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 161 

 2112:         X1[n] = X[n] - X[0];
 0000000E  0091      LSL         R1,R2,#0x2 ; n
 00000010  4800      LDR         R0,=X ; X
 00000012  5840      LDR         R0,[R0,R1]
 00000014  4800      LDR         R1,=X ; X
 00000016  6809      LDR         R1,[R1,#0x0] ; X
 00000018  F7FF      BL          ?C?FPSUB?T  ; T=0x0001  (1) ; ?C?FPSUB?T
 0000001A  FFF2      BL          ?C?FPSUB?T  ; T=0x0001  (2) ; ?C?FPSUB?T
 0000001C  0097      LSL         R7,R2,#0x2 ; n
 0000001E  A900      ADD         R1,R13,#0x0
 00000020  51C8      STR         R0,[R1,R7]
 2113:     }
 00000022  3201      ADD         R2,#0x1
 00000024  2A05      CMP         R2,#0x5 ; n
 00000026  DBF2      BLT         L_555  ; T=0x0000000E
 2114:     X1[0] = 0;
 00000028  2000      MOV         R0,#0x0
 0000002A  9000      STR         R0,[R13,#0x0] ; X1
 2115:     for (n=0;n<5;n++)
 0000002C  2200      MOV         R2,#0x0
 0000002E          L_560:
 2117:         sumX  = sumX  + X1[n];
 0000002E  0097      LSL         R7,R2,#0x2 ; n
 00000030  A800      ADD         R0,R13,#0x0
 00000032  59C1      LDR         R1,[R0,R7]
 00000034  1C18      MOV         R0,R3 ; sumX
 00000036  F7FF      BL          ?C?FPADD?T  ; T=0x0001  (1) ; ?C?FPADD?T
 00000038  FFE3      BL          ?C?FPADD?T  ; T=0x0001  (2) ; ?C?FPADD?T
 0000003A  1C03      MOV         R3,R0 ; sumX
 2118:         sumY  = sumY  + Y[n]; 
 0000003C  4800      LDR         R0,=Y ; Y
 0000003E  59C1      LDR         R1,[R0,R7]
 00000040  1C28      MOV         R0,R5 ; sumY
 00000042  F7FF      BL          ?C?FPADD?T  ; T=0x0001  (1) ; ?C?FPADD?T
 00000044  FFDD      BL          ?C?FPADD?T  ; T=0x0001  (2) ; ?C?FPADD?T
 00000046  1C05      MOV         R5,R0 ; sumY
 2119:         sumXY = sumXY + X1[n]*Y[n];
 00000048  0091      LSL         R1,R2,#0x2 ; n
 0000004A  4800      LDR         R0,=Y ; Y
 0000004C  5841      LDR         R1,[R0,R1]
 0000004E  0097      LSL         R7,R2,#0x2 ; n
 00000050  A800      ADD         R0,R13,#0x0
 00000052  59C0      LDR         R0,[R0,R7]
 00000054  F7FF      BL          ?C?FPMUL?T  ; T=0x0001  (1) ; ?C?FPMUL?T
 00000056  FFD4      BL          ?C?FPMUL?T  ; T=0x0001  (2) ; ?C?FPMUL?T
 00000058  1C01      MOV         R1,R0
 0000005A  1C20      MOV         R0,R4 ; sumXY
 0000005C  F7FF      BL          ?C?FPADD?T  ; T=0x0001  (1) ; ?C?FPADD?T
 0000005E  FFD0      BL          ?C?FPADD?T  ; T=0x0001  (2) ; ?C?FPADD?T
 00000060  1C04      MOV         R4,R0 ; sumXY
 2120:         sumXX = sumXX + X1[n]*X1[n];
 00000062  0091      LSL         R1,R2,#0x2 ; n
 00000064  A800      ADD         R0,R13,#0x0
 00000066  5841      LDR         R1,[R0,R1]
 00000068  0097      LSL         R7,R2,#0x2 ; n
 0000006A  A800      ADD         R0,R13,#0x0
 0000006C  59C0      LDR         R0,[R0,R7]
 0000006E  F7FF      BL          ?C?FPMUL?T  ; T=0x0001  (1) ; ?C?FPMUL?T
 00000070  FFC7      BL          ?C?FPMUL?T  ; T=0x0001  (2) ; ?C?FPMUL?T
 00000072  1C01      MOV         R1,R0
 00000074  1C30      MOV         R0,R6 ; sumXX
 00000076  F7FF      BL          ?C?FPADD?T  ; T=0x0001  (1) ; ?C?FPADD?T
 00000078  FFC3      BL          ?C?FPADD?T  ; T=0x0001  (2) ; ?C?FPADD?T
 0000007A  1C06      MOV         R6,R0 ; sumXX
 2121:         meanX = sumX/5.0;
 0000007C  4800      LDR         R1,=0x40A00000
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 162 

 0000007E  1C18      MOV         R0,R3 ; sumX
 00000080  F7FF      BL          ?C?FPDIV?T  ; T=0x0001  (1) ; ?C?FPDIV?T
 00000082  FFBE      BL          ?C?FPDIV?T  ; T=0x0001  (2) ; ?C?FPDIV?T
 00000084  9005      STR         R0,[R13,#0x14] ; meanX
 2122:         meanY = sumY/5.0;
 00000086  4800      LDR         R1,=0x40A00000
 00000088  1C28      MOV         R0,R5 ; sumY
 0000008A  F7FF      BL          ?C?FPDIV?T  ; T=0x0001  (1) ; ?C?FPDIV?T
 0000008C  FFB9      BL          ?C?FPDIV?T  ; T=0x0001  (2) ; ?C?FPDIV?T
 0000008E  9006      STR         R0,[R13,#0x18] ; meanY
 2123:     }                                
 00000090  3201      ADD         R2,#0x1
 00000092  2A05      CMP         R2,#0x5 ; n
 00000094  DBCB      BLT         L_560  ; T=0x0000002E
 2124:     slope = (5.0*sumXY-sumX*sumY)/(5.0*sumXX-sumX*sumX);
 00000096  1C18      MOV         R0,R3 ; sumX
 00000098  1C19      MOV         R1,R3 ; sumX
 0000009A  F7FF      BL          ?C?FPMUL?T  ; T=0x0001  (1) ; ?C?FPMUL?T
 0000009C  FFB1      BL          ?C?FPMUL?T  ; T=0x0001  (2) ; ?C?FPMUL?T
 0000009E  1C02      MOV         R2,R0
 000000A0  4800      LDR         R0,=0x40A00000
 000000A2  1C31      MOV         R1,R6 ; sumXX
 000000A4  F7FF      BL          ?C?FPMUL?T  ; T=0x0001  (1) ; ?C?FPMUL?T
 000000A6  FFAC      BL          ?C?FPMUL?T  ; T=0x0001  (2) ; ?C?FPMUL?T
 000000A8  1C11      MOV         R1,R2 ; sumX
 000000AA  F7FF      BL          ?C?FPSUB?T  ; T=0x0001  (1) ; ?C?FPSUB?T
 000000AC  FFA9      BL          ?C?FPSUB?T  ; T=0x0001  (2) ; ?C?FPSUB?T
 000000AE  1C02      MOV         R2,R0
 000000B0  1C18      MOV         R0,R3 ; sumX
 000000B2  1C29      MOV         R1,R5 ; sumY
 000000B4  F7FF      BL          ?C?FPMUL?T  ; T=0x0001  (1) ; ?C?FPMUL?T
 000000B6  FFA4      BL          ?C?FPMUL?T  ; T=0x0001  (2) ; ?C?FPMUL?T
 000000B8  1C03      MOV         R3,R0
 000000BA  4800      LDR         R0,=0x40A00000
 000000BC  1C21      MOV         R1,R4 ; sumXY
 000000BE  F7FF      BL          ?C?FPMUL?T  ; T=0x0001  (1) ; ?C?FPMUL?T
 000000C0  FF9F      BL          ?C?FPMUL?T  ; T=0x0001  (2) ; ?C?FPMUL?T
 000000C2  1C19      MOV         R1,R3 ; sumX
 000000C4  F7FF      BL          ?C?FPSUB?T  ; T=0x0001  (1) ; ?C?FPSUB?T
 000000C6  FF9C      BL          ?C?FPSUB?T  ; T=0x0001  (2) ; ?C?FPSUB?T
 000000C8  1C11      MOV         R1,R2
 000000CA  F7FF      BL          ?C?FPDIV?T  ; T=0x0001  (1) ; ?C?FPDIV?T
 000000CC  FF99      BL          ?C?FPDIV?T  ; T=0x0001  (2) ; ?C?FPDIV?T
 000000CE  ---- Variable 'slope' assigned to Register 'R0' ----
 2125:     speed[0] = slope;
 000000CE  4800      LDR         R1,=speed ; speed
 000000D0  6008      STR         R0,[R1,#0x0] ; slope
 2126:     speed[1] = meanY -(slope*meanX);
 000000D2  9905      LDR         R1,[R13,#0x14] ; meanX
 000000D4  F7FF      BL          ?C?FPMUL?T  ; T=0x0001  (1) ; ?C?FPMUL?T
 000000D6  FF94      BL          ?C?FPMUL?T  ; T=0x0001  (2) ; ?C?FPMUL?T
 000000D8  1C01      MOV         R1,R0
 000000DA  9806      LDR         R0,[R13,#0x18] ; meanY
 000000DC  F7FF      BL          ?C?FPSUB?T  ; T=0x0001  (1) ; ?C?FPSUB?T
 000000DE  FF90      BL          ?C?FPSUB?T  ; T=0x0001  (2) ; ?C?FPSUB?T
 000000E0  4800      LDR         R1,=speed + 0x4 ; speed+4
 000000E2  6008      STR         R0,[R1,#0x0] ; speed+4
 000000E4            ; SCOPE-END
 2128: }
 000000E4  B007      ADD         R13,#0x1C
 000000E6  BCF0      POP         {R4-R7}
 000000E8  BC08      POP         {R3}
 000000EA  4718      BX          R3
 000000EC          ENDP ; 'calculateSpeed?T'


*** CODE SEGMENT '?PR?getSpeed?T?Fart':
 2130: void getSpeed()
ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 163 

 00000000  B500      PUSH        {LR}
 2131: {
 00000002            ; SCOPE-START
 2135:     slope  = speed[0];
 00000002  4800      LDR         R0,=speed ; speed
 00000004  6802      LDR         R2,[R0,#0x0] ; speed
 00000006  ---- Variable 'slope' assigned to Register 'R2' ----
 2136:     offset = speed[1];
 00000006  4800      LDR         R0,=speed + 0x4 ; speed+4
 00000008  6803      LDR         R3,[R0,#0x0] ; speed+4
 0000000A  ---- Variable 'offset' assigned to Register 'R3' ----
 2138:     n = sprintf(outBuf,"%f %f %f %f %f %f %f %f %f %f %f %f %f\n",slope,offset,range[0],range[1],range[2],range[3],r
             -ange[4],range[5],range[6],range[7],range[8],range[9],range[10]);
 0000000A  4800      LDR         R0,=range + 0x28 ; range+40
 0000000C  6800      LDR         R0,[R0,#0x0] ; range+40
 0000000E  B401      PUSH        {R0}
 00000010  4800      LDR         R0,=range + 0x24 ; range+36
 00000012  6800      LDR         R0,[R0,#0x0] ; range+36
 00000014  B401      PUSH        {R0}
 00000016  4800      LDR         R0,=range + 0x20 ; range+32
 00000018  6800      LDR         R0,[R0,#0x0] ; range+32
 0000001A  B401      PUSH        {R0}
 0000001C  4800      LDR         R0,=range + 0x1C ; range+28
 0000001E  6800      LDR         R0,[R0,#0x0] ; range+28
 00000020  B401      PUSH        {R0}
 00000022  4800      LDR         R0,=range + 0x18 ; range+24
 00000024  6800      LDR         R0,[R0,#0x0] ; range+24
 00000026  B401      PUSH        {R0}
 00000028  4800      LDR         R0,=range + 0x14 ; range+20
 0000002A  6800      LDR         R0,[R0,#0x0] ; range+20
 0000002C  B401      PUSH        {R0}
 0000002E  4800      LDR         R0,=range + 0x10 ; range+16
 00000030  6800      LDR         R0,[R0,#0x0] ; range+16
 00000032  B401      PUSH        {R0}
 00000034  4800      LDR         R0,=range + 0xC ; range+12
 00000036  6800      LDR         R0,[R0,#0x0] ; range+12
 00000038  B401      PUSH        {R0}
 0000003A  4800      LDR         R0,=range + 0x8 ; range+8
 0000003C  6800      LDR         R0,[R0,#0x0] ; range+8
 0000003E  B401      PUSH        {R0}
 00000040  4800      LDR         R0,=range + 0x4 ; range+4
 00000042  6800      LDR         R0,[R0,#0x0] ; range+4
 00000044  B401      PUSH        {R0}
 00000046  4800      LDR         R0,=range ; range
 00000048  6800      LDR         R0,[R0,#0x0] ; range
 0000004A  B401      PUSH        {R0}
 0000004C  4800      LDR         R0,=outBuf ; outBuf
 0000004E  4800      LDR         R1,=??S_16 ; ??S_16
 00000050  F7FF      BL          sprintf?T  ; T=0x0001  (1)
 00000052  FFD6      BL          sprintf?T  ; T=0x0001  (2)
 00000054  B00B      ADD         R13,#0x2C
 00000056  1C01      MOV         R1,R0 ; n
 00000058  ---- Variable 'n' assigned to Register 'R1' ----
 2139:      i = UART0_Str(outBuf, n);
 00000058  4800      LDR         R0,=outBuf ; outBuf
 0000005A  F7FF      BL          UART0_Str?T  ; T=0x0001  (1)
 0000005C  FFD1      BL          UART0_Str?T  ; T=0x0001  (2)
 2140:     nBuffer[1] = 0;
 0000005E  2100      MOV         R1,#0x0
 00000060  4800      LDR         R0,=nBuffer + 0x4 ; nBuffer+4
 00000062  6001      STR         R1,[R0,#0x0] ; nBuffer+4
 00000064            ; SCOPE-END
 2141: }
 00000064  BC08      POP         {R3}
 00000066  4718      BX          R3
 00000068          ENDP ; 'getSpeed?T'

ARM COMPILER V2.11,  Fart                                                                  28/04/10  15:26:51  PAGE 164 



Module Information          Static
----------------------------------
  code size            =    ------
  data size            =      8003
  const size           =       359
End of Module Information.


ARM COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
