%  GOL2SPEC -- Read Golay responses from disk file 
%  (generated by FORDDTF), do Golay analysis,
%  apply speaker correction.
%
%	(John Middlebrooks, 2/25/98)

format compact
NPts= 512;
NFreq= NPts/2;
NLoc= 400;

GolPath= input ('Enter the Golay (*.gol) pathname: ','s');
GolFID= fopen(GolPath, 'rb');
if ~GolFID,
	disp(sprintf('Error in opening %s.  Try again.',GolPath));
	return;
end

% read the golay codes

CodeA= fread(GolFID, [NPts,1], 'int16');
CodeB= fread(GolFID, [NPts,1], 'int16');

% read the speaker calibrations and duplicate the negative frequencies

Cal1= zeros(NPts,1);
Cal2= zeros(NPts,1);

AmpCal= fread(GolFID, [NFreq,1], 'float32');
PhiCal= fread(GolFID, [NFreq,1], 'float32');
r= 10.^(AmpCal/20);
arg= PhiCal;
Cal1(1:NFreq)= r.*cos(arg) - j*r.*sin(arg);
Cal1((NFreq+1))= Cal1(NFreq);
Cal1((NPts+1)-(1:(NFreq-1)))= r(2:NFreq).*cos(arg(2:NFreq)) + j*r(2:NFreq).*sin(arg(2:NFreq));

AmpCal= fread(GolFID, [NFreq,1], 'float32');
PhiCal= fread(GolFID, [NFreq,1], 'float32');
r= 10.^(AmpCal/20);
arg= PhiCal;
Cal2(1:NFreq)= r.*cos(arg) - j*r.*sin(arg);
Cal2((NFreq+1))= Cal2(NFreq);
Cal2((NPts+1)-(1:(NFreq-1)))= r(2:NFreq).*cos(arg(2:NFreq)) + j*r(2:NFreq).*sin(arg(2:NFreq));

% read the Golay responses

RespA= zeros(NPts,NLoc);
RespB= zeros(NPts,NLoc);
Theta= zeros(1,NLoc);
Phi= zeros(1,NLoc);
Spkr= zeros(1,NLoc);

for Loc=1:NLoc,
	Theta(Loc)= fread(GolFID, [1,1], 'float32');
	Phi(Loc)= fread(GolFID, [1,1], 'float32');
	Spkr(Loc)= fread(GolFID, [1,1], 'int16');
	Atten(Loc)= fread(GolFID, [1,1], 'float64');
	RespA(:,Loc)= fread(GolFID, [NPts,1], 'int16');
	RespB(:,Loc)= fread(GolFID, [NPts,1], 'int16');
end
disp('Finished reading the file!');
fclose(GolFID);

% Get impulse responses the time-domain way

ImpTime= zeros(2*NPts-1,NLoc);
for Loc=1:NLoc,
	ImpTime(:,Loc)= xcorr(CodeA, RespA(:,Loc)) + xcorr(CodeB, RespB(:,Loc));
end

% Set up for Golay analysis in freq domain

% get the Golay codes in freq domain and form the complex conjugate

CodeASpec= conj(fft(CodeA));
CodeBSpec= conj(fft(CodeB));
Spec= zeros(NPts,NLoc);

% Get the freq-domain transfer functions by multipling responses by
% conjugates of the codes and adding

for Loc=1:NLoc,
	ASpec= fft(RespA(:,Loc));
	BSpec= fft(RespB(:,Loc));
	Spec(:,Loc)= CodeASpec.*ASpec + CodeBSpec.*BSpec;
end
disp('Finishing the Golay analysis!');

% Convert spectra to time domain    

ImpFFT= zeros(NPts, NLoc);
for Loc=1:NLoc,
	ImpFFT(:,Loc)= real(ifft(Spec(:,Loc)));
end


% Apply the speaker correction to the spectra

for Loc=1:NLoc,
	if Spkr(Loc)==1,
		Spec(:,Loc)= Spec(:,Loc)./Cal1;
	else
		Spec(:,Loc)= Spec(:,Loc)./Cal2;
	end
end

% Convert speaker-corrected spectra to impulse responses

ImpCal= zeros(NPts, NLoc);
for Loc=1:NLoc,
	ImpCal(:,Loc)= real(ifft(Spec(:,Loc)));
end

T=[1:(2*NPts-1)] * .02;
figure(1); plot(T,ImpTime(:,304),T,[ImpFFT(:,304);ImpFFT(1:(NPts-1),304)]);
figure(2); plot(T,[ImpCal(:,304);ImpCal(1:(NPts-1),304)]);
